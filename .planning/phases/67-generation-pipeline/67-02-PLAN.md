---
phase: 67-generation-pipeline
plan: 02
type: execute
wave: 2
depends_on: ["67-01"]
files_modified:
  - App.tsx
autonomous: true

must_haves:
  truths:
    - "Clicking Generate runs the three-pass pipeline and delivers a deck with critical/recommended gaps filled"
    - "A multi-stage progress indicator shows which pass is active (Generating, Checking Coverage, Filling Gaps) with a progress bar"
    - "If gap analysis or gap filling fails, the teacher still receives Pass 1 slides with a warning toast"
    - "Remaining nice-to-have gaps appear in the existing GapAnalysisPanel for optional manual addition"
    - "Gap slides insert at correct positions without corrupting slide order"
    - "The teacher can cancel the pipeline at any point with partial results preserved"
    - "Manual gap analysis flow (PDF upload in editor) continues to work independently"
  artifacts:
    - path: "App.tsx"
      provides: "Pipeline integration, extended progress state, cancel support, remaining gap wiring"
      contains: "runGenerationPipeline"
  key_links:
    - from: "App.tsx"
      to: "services/generationPipeline.ts"
      via: "import and call runGenerationPipeline"
      pattern: "runGenerationPipeline"
    - from: "App.tsx"
      to: "components/GapAnalysisPanel.tsx"
      via: "gapResult state populated from pipeline remainingGaps"
      pattern: "setGapResult"
---

<objective>
Wire the generation pipeline into App.tsx: replace the existing handleGenerate with a pipeline call, extend the progress UI with multi-stage indicators and a cancel button, and connect remaining gaps to the existing GapAnalysisPanel.

Purpose: This is the integration layer that makes the pipeline visible and interactive. The service (Plan 01) handles orchestration; this plan handles state management, UI feedback, and user controls.

Output: Modified App.tsx with pipeline integration, extended progress screen, and cancel support.
</objective>

<execution_context>
@/Users/ricky/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ricky/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/67-generation-pipeline/67-RESEARCH.md
@.planning/phases/67-generation-pipeline/67-01-SUMMARY.md

Key existing code:
@App.tsx — handleGenerate (lines 543-630), generationProgress state (line 318), PROCESSING_TEXT UI (lines 2442-2481), gap analysis state (lines 354-358), GapAnalysisPanel rendering (line 2937)
@services/generationPipeline.ts — runGenerationPipeline, PipelineProgress, PipelineResult (from Plan 01)
@components/GapAnalysisPanel.tsx — existing panel for displaying gaps with add/reanalyze/close
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extend progress state and wire pipeline into handleGenerate</name>
  <files>App.tsx</files>
  <action>
**1. Add imports:**
Add import for `runGenerationPipeline`, `PipelineProgress`, `PipelineResult` from `./services/generationPipeline`.

**2. Extend generationProgress state type (line ~318):**
Change the state type from:
```typescript
const [generationProgress, setGenerationProgress] = useState<{
  phase: 'slides' | 'teleprompter';
  current: number;
  total: number;
} | null>(null);
```
To:
```typescript
const [generationProgress, setGenerationProgress] = useState<{
  phase: 'slides' | 'teleprompter' | 'checking-coverage' | 'filling-gaps';
  current: number;
  total: number;
  stageLabel?: string;
  stageIndex?: number;
  totalStages?: number;
} | null>(null);
```

**3. Add AbortController ref (near other refs, ~line 359):**
```typescript
const pipelineControllerRef = useRef<AbortController | null>(null);
```

**4. Add a coverage percentage state (near gap state, ~line 355):**
```typescript
const [coveragePercentage, setCoveragePercentage] = useState<number | null>(null);
```

**5. Replace handleGenerate (lines 543-630):**
Replace the entire handleGenerate function body. Keep the same outer structure (validation, error handling, finally block), but replace the core generation logic:

```typescript
const handleGenerate = async () => {
  if (!provider) {
    setEnableAIModal({ featureName: 'generate slides' });
    return;
  }

  const hasLessonContent = lessonText.trim() || pageImages.length > 0;
  const hasPptContent = existingPptImages.length > 0;
  if (!hasLessonContent && !hasPptContent) return;

  setIsGenerating(true);
  setAppState(AppState.PROCESSING_TEXT);
  setError(null);
  setCoveragePercentage(null);

  // Create AbortController for pipeline cancellation
  const controller = new AbortController();
  pipelineControllerRef.current = controller;

  try {
    const generationInput: GenerationInput = {
      lessonText: lessonText,
      lessonImages: pageImages.length > 0 ? pageImages : undefined,
      presentationText: existingPptText || undefined,
      presentationImages: existingPptImages.length > 0 ? existingPptImages : undefined,
      mode: uploadMode as GenerationMode,
      verbosity: deckVerbosity,
      gradeLevel: 'Year 6 (10-11 years old)',
    };

    // Map pipeline progress to generationProgress state
    const handlePipelineProgress = (p: PipelineProgress) => {
      setGenerationProgress({
        phase: p.stage === 'generating' ? (p.detail?.includes('teleprompter') ? 'teleprompter' : 'slides') : p.stage,
        current: p.subProgress ?? 0,
        total: 100,
        stageLabel: p.detail,
        stageIndex: p.stageIndex,
        totalStages: p.totalStages,
      });
    };

    const result: PipelineResult = await runGenerationPipeline(
      provider,
      generationInput,
      {
        lessonPlanText: lessonText,
        lessonPlanImages: pageImages,
        deckVerbosity,
        gradeLevel: 'Year 6 (10-11 years old)',
        signal: controller.signal,
        onProgress: handlePipelineProgress,
      }
    );

    // Clear progress
    setGenerationProgress(null);
    setSlides(result.slides);
    setLessonTitle(result.slides[0]?.title || 'New Lesson');
    setActiveSlideIndex(0);
    setAppState(AppState.EDITING);

    // Store coverage percentage
    if (result.coveragePercentage != null) {
      setCoveragePercentage(result.coveragePercentage);
    }

    // Wire remaining gaps to GapAnalysisPanel
    if (result.remainingGaps.length > 0) {
      setGapResult({
        gaps: result.remainingGaps,
        summary: result.wasPartial
          ? 'Some gaps could not be auto-filled. You can add them manually below.'
          : 'These optional gaps were not auto-filled. Add them if you like.',
        coveragePercentage: result.coveragePercentage ?? 0,
      });
      // Store lesson plan data so manual re-analysis works
      setGapLessonPlanText(lessonText);
      setGapLessonPlanImages(pageImages);
    } else if (result.coveragePercentage != null) {
      // No remaining gaps -- clear any stale gap state but keep coverage info
      setGapResult(null);
    }

    // Show warnings as toasts
    for (const warning of result.warnings) {
      addToast(warning, 5000, 'warning');
    }

    // Show coverage success toast if full pipeline completed
    if (result.coveragePercentage != null && !result.wasPartial) {
      addToast(
        `Coverage: ${result.coveragePercentage}% of lesson plan covered`,
        4000,
        'success'
      );
    }

    // Auto-generate images (unchanged from existing logic)
    if (autoGenerateImages) {
      result.slides.forEach(async (s) => {
        setSlides(curr => curr.map(item =>
          item.id === s.id ? { ...item, isGeneratingImage: true } : item
        ));
        const img = await provider.generateSlideImage(s.imagePrompt, s.layout);
        setSlides(curr => curr.map(item =>
          item.id === s.id ? { ...item, imageUrl: img, isGeneratingImage: false } : item
        ));
      });
    }
  } catch (err) {
    if (err instanceof AIProviderError) {
      setErrorModal({ title: 'Generation Failed', message: err.userMessage });
    } else if ((err as Error)?.name === 'AbortError') {
      // Pipeline was cancelled -- don't show error
      addToast('Generation cancelled', 3000, 'info');
    } else {
      setErrorModal({ title: 'Error', message: 'An unexpected error occurred.' });
    }
    // Only go back to INPUT if we have no slides
    if (slides.length === 0) {
      setAppState(AppState.INPUT);
    }
  } finally {
    setIsGenerating(false);
    setGenerationProgress(null);
    pipelineControllerRef.current = null;
  }
};
```

**6. Add handleCancelPipeline function (after handleGenerate):**
```typescript
const handleCancelPipeline = () => {
  pipelineControllerRef.current?.abort();
};
```

**Important notes:**
- Do NOT remove or modify the existing manual gap analysis handlers (handleGapPdfUpload, handleReanalyzeGaps, handleAddSlideFromGap). They must continue to work independently.
- The pipeline stores lessonText/pageImages into gapLessonPlanText/gapLessonPlanImages so that "Re-analyze" in GapAnalysisPanel works after pipeline generation.
- The `coveragePercentage` state is stored separately for potential future display (Phase 68 will surface it in the UI). For now it drives the toast message.
  </action>
  <verify>
`npx tsc --noEmit` passes with no type errors.
  </verify>
  <done>
handleGenerate calls runGenerationPipeline instead of direct provider.generateLessonSlides. Pipeline progress maps to extended generationProgress state. AbortController enables cancellation. Remaining gaps wire to existing GapAnalysisPanel. Warnings display as toasts. Coverage percentage stored and shown in success toast. Manual gap analysis flow unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update PROCESSING_TEXT screen with multi-stage progress UI and cancel button</name>
  <files>App.tsx</files>
  <action>
Replace the PROCESSING_TEXT UI section (lines ~2442-2481) with an enhanced version that shows pipeline stages and a cancel button.

The updated section should:

**1. Dynamic heading based on current stage:**
- `'slides'` or `'teleprompter'` phase: "Deep Learning Architecture" (existing text, familiar to users)
- `'checking-coverage'` phase: "Checking Coverage"
- `'filling-gaps'` phase: "Filling Gaps"

**2. Dynamic description based on current stage:**
- `'slides'` phase: "Generating with {provider}..." (existing)
- `'teleprompter'` phase: "Generating {deckVerbosity} teleprompter: slide {current} of {total}" (existing)
- `'checking-coverage'` phase: "Cross-referencing slides against your lesson plan..."
- `'filling-gaps'` phase: generationProgress?.stageLabel (e.g., "Filling gap 2 of 4") or "Auto-filling content gaps..."

**3. Pipeline stage dots (always visible during generation):**
Three dots with connecting dashes showing: "Generating" -> "Checking Coverage" -> "Filling Gaps"
- Use `generationProgress?.stageIndex` (0, 1, 2) to determine state
- Completed stages (stageIndex > i): solid green dot (`bg-green-500`)
- Active stage (stageIndex === i): pulsing indigo/amber dot (`bg-indigo-500 dark:bg-amber-500 animate-pulse`)
- Pending stages (stageIndex < i): grey dot (`bg-slate-300 dark:bg-slate-600`)
- Labels under each dot in matching color intensity
- If `stageIndex` is undefined (legacy progress), only show the first dot as active
- Connecting dashes between dots: `text-slate-300 dark:text-slate-600`

**4. Sub-progress bar:**
Show when `generationProgress?.current` and `generationProgress?.total` are both > 0:
- Applies to teleprompter regen (slide X of Y) and gap filling (gap X of Y)
- Bar width: `(current / total) * 100`%
- Show detail text below: stageLabel if available, or "{percentage}% complete"
- Bar color: `bg-indigo-600 dark:bg-amber-500`
- Track background: `bg-slate-200 dark:bg-slate-700`
- Width: `w-64`

**5. Cancel button:**
- Position: below the progress bar (or below stage dots if no bar)
- Text: "Cancel (keep current results)"
- Style: ghost/outline button matching existing app style -- `px-4 py-2 text-sm font-medium text-slate-500 dark:text-slate-400 border border-slate-300 dark:border-slate-600 rounded-xl hover:bg-slate-50 dark:hover:bg-slate-800 transition-colors`
- onClick: `handleCancelPipeline`
- Add `mt-8` spacing above

**6. Keep existing page image preview strip** at the bottom (the greyscale thumbnails), unchanged.

**Styling constraints:**
- Use existing Tailwind classes consistent with the app's design system
- Dark mode classes throughout (the app defaults to dark mode)
- Use `font-fredoka` for the heading (matches existing)
- Animate stage transitions with `transition-colors` on dots
  </action>
  <verify>
`npx tsc --noEmit` passes. Visually inspect the PROCESSING_TEXT section in the JSX to confirm: three stage dots exist, cancel button exists, dynamic heading/description logic references all four phase values, progress bar shows conditionally.
  </verify>
  <done>
PROCESSING_TEXT screen shows three pipeline stage indicator dots (Generating / Checking Coverage / Filling Gaps) with active/completed/pending states. Cancel button calls handleCancelPipeline. Sub-progress bar shows during teleprompter regen and gap filling. Dynamic heading and description update per stage. Dark mode styling throughout. Existing page image preview strip preserved.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- no type errors across the project
2. `handleGenerate` calls `runGenerationPipeline` (not direct `provider.generateLessonSlides` for the main flow)
3. `generationProgress` state type includes 'checking-coverage' and 'filling-gaps' phases
4. `pipelineControllerRef` exists and `handleCancelPipeline` aborts it
5. PROCESSING_TEXT UI shows three stage dots, cancel button, and dynamic descriptions
6. Remaining gaps from pipeline wire to `gapResult` state for GapAnalysisPanel
7. Manual gap analysis handlers (handleGapPdfUpload, handleReanalyzeGaps, handleAddSlideFromGap) are unchanged
8. Coverage percentage displayed in toast on successful full pipeline
</verification>

<success_criteria>
- Clicking Generate triggers the three-pass pipeline (not just slide generation)
- Progress UI shows which pipeline stage is active with visual stage dots
- Cancel button aborts the pipeline and preserves partial results
- Warnings from degraded pipeline show as toasts
- Remaining gaps populate the existing GapAnalysisPanel
- Manual gap analysis still works independently (PDF upload in editor toolbar)
- Coverage percentage shown in success toast after full pipeline
- No type errors
</success_criteria>

<output>
After completion, create `.planning/phases/67-generation-pipeline/67-02-SUMMARY.md`
</output>
