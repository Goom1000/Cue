---
phase: 67-generation-pipeline
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - services/generationPipeline.ts
  - utils/gapSlideInsertion.ts
autonomous: true

must_haves:
  truths:
    - "Pipeline orchestrates three passes (generate, check coverage, fill gaps) and returns a merged deck"
    - "Pipeline degrades gracefully -- Pass 2/3 failures return Pass 1 slides with warnings"
    - "Pipeline checks AbortSignal between passes and between individual gap generations"
    - "Gap slides insert at correct positions without corrupting existing slide order"
    - "Pipeline only runs gap analysis in fresh/blend mode, not refine mode"
  artifacts:
    - path: "services/generationPipeline.ts"
      provides: "Three-pass generation pipeline orchestrator"
      exports: ["runGenerationPipeline", "PipelineStage", "PipelineProgress", "PipelineResult"]
    - path: "utils/gapSlideInsertion.ts"
      provides: "Position-aware batch gap slide insertion"
      exports: ["insertGapSlides", "adjustGapPositions"]
  key_links:
    - from: "services/generationPipeline.ts"
      to: "services/aiProvider.ts"
      via: "provider.generateLessonSlides, provider.analyzeGaps, provider.generateSlideFromGap, withRetry"
      pattern: "provider\\.(generateLessonSlides|analyzeGaps|generateSlideFromGap)"
    - from: "services/generationPipeline.ts"
      to: "utils/gapSlideInsertion.ts"
      via: "insertGapSlides import"
      pattern: "insertGapSlides"
---

<objective>
Create the generation pipeline service module and gap slide insertion utility that orchestrate the three-pass generation flow (generate slides, check coverage, fill gaps).

Purpose: This is the core engine for Phase 67. All AI methods already exist (`generateLessonSlides`, `analyzeGaps`, `generateSlideFromGap`). This plan creates the orchestration layer that sequences them with progress callbacks, AbortSignal cancellation, and graceful degradation.

Output: Two new files -- `services/generationPipeline.ts` (pipeline orchestrator) and `utils/gapSlideInsertion.ts` (batch insertion utility).
</objective>

<execution_context>
@/Users/ricky/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ricky/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/67-generation-pipeline/67-RESEARCH.md

Key existing code to reference:
@services/aiProvider.ts — AIProviderInterface (generateLessonSlides, analyzeGaps, generateSlideFromGap, withRetry), GenerationInput, GapAnalysisResult, IdentifiedGap types
@types.ts — Slide, LessonPhase types
@services/phaseDetection/phaseDetector.ts — assignPhasesToSlides (must re-run on merged deck)
@services/geminiService.ts — VerbosityLevel type
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create gap slide insertion utility</name>
  <files>utils/gapSlideInsertion.ts</files>
  <action>
Create `utils/gapSlideInsertion.ts` with two pure functions:

1. `insertGapSlides(existingSlides: Slide[], gapSlides: Array<{ slide: Slide; suggestedPosition: number }>): Slide[]`
   - If gapSlides is empty, return shallow copy of existingSlides
   - Sort gapSlides by suggestedPosition ascending
   - Insert each gap slide at `Math.min(suggestedPosition + cumulativeOffset, result.length)` where cumulativeOffset increments by 1 after each insertion
   - Returns new array (does NOT mutate inputs)

2. `adjustGapPositions(gaps: IdentifiedGap[], insertedPositions: number[]): IdentifiedGap[]`
   - Takes remaining gaps (nice-to-have) and the positions where gap slides were inserted
   - Sort insertedPositions ascending
   - For each gap, count how many insertedPositions are <= gap.suggestedPosition + adjustment, increment adjustment for each
   - Returns new array with adjusted suggestedPosition values
   - This is needed so the GapAnalysisPanel shows correct positions for remaining gaps after batch insertion

Import `Slide` from `../types` and `IdentifiedGap` from `../services/aiProvider`.
  </action>
  <verify>
`npx tsc --noEmit` passes with no type errors on the new file.
  </verify>
  <done>
Both functions exported from utils/gapSlideInsertion.ts. insertGapSlides correctly handles empty input, single insertion, multiple insertions at various positions, and boundary cases (position beyond deck length). adjustGapPositions correctly shifts remaining gap positions after batch insertions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create generation pipeline service</name>
  <files>services/generationPipeline.ts</files>
  <action>
Create `services/generationPipeline.ts` following the `documentEnhancementService.ts` pattern for multi-step AI orchestration with progress callbacks and AbortSignal support.

**Exports:**

```typescript
export type PipelineStage = 'generating' | 'checking-coverage' | 'filling-gaps';

export interface PipelineProgress {
  stage: PipelineStage;
  stageIndex: number;      // 0, 1, or 2
  totalStages: number;     // 3
  detail?: string;         // e.g., "Filling gap 2 of 4"
  subProgress?: number;    // 0-100 within current stage
}

export interface PipelineResult {
  slides: Slide[];
  coveragePercentage: number | null;    // null if Pass 2 failed or mode is refine
  remainingGaps: IdentifiedGap[];       // nice-to-have + failed gaps for GapAnalysisPanel
  warnings: string[];                   // degradation messages for toast display
  wasPartial: boolean;                  // true if Pass 2 or 3 failed or cancelled
}
```

**Main function `runGenerationPipeline`:**

Parameters:
- `provider: AIProviderInterface`
- `input: GenerationInput`
- `options` object with:
  - `lessonPlanText: string` -- raw lesson text for gap analysis
  - `lessonPlanImages: string[]` -- page images (with data URL prefix, pipeline strips it)
  - `deckVerbosity: VerbosityLevel`
  - `gradeLevel: string` -- e.g., "Year 6 (10-11 years old)"
  - `signal?: AbortSignal`
  - `onProgress?: (progress: PipelineProgress) => void`

**Pass 1: Generate slides**
- Report progress: stage 'generating', stageIndex 0, totalStages 3
- Call `provider.generateLessonSlides(input)`
- If `deckVerbosity !== 'standard'`, loop through slides and call `provider.regenerateTeleprompter()` for each slide with context (prevSlide, nextSlide), reporting sub-progress. Catch per-slide errors silently (keep original speakerNotes).
- Check `signal?.aborted` after Pass 1 -- if aborted, return slides immediately with `wasPartial: true`

**Mode gate:**
- `const canAnalyzeGaps = input.mode === 'fresh' || input.mode === 'blend'`
- If NOT canAnalyzeGaps (i.e., refine mode), return slides with `coveragePercentage: null, remainingGaps: [], wasPartial: false`

**Pass 2: Analyze coverage**
- Report progress: stage 'checking-coverage', stageIndex 1, totalStages 3
- Strip data URL prefix from images: `img.replace(/^data:image\/[a-z]+;base64,/, '')`
- Call `withRetry(() => provider.analyzeGaps(slides, lessonPlanText, rawImages, gradeLevel))`
- On failure: add warning "Coverage analysis encountered an issue. Your slides are ready -- you can run gap analysis manually later.", return Pass 1 slides with `wasPartial: true`
- Separate gaps by severity: critical + recommended vs nice-to-have
- If no critical/recommended gaps, return early with coveragePercentage and nice-to-have as remainingGaps
- Check `signal?.aborted` -- if aborted, return slides with all gaps as remainingGaps

**Pass 3: Fill gaps**
- Report progress: stage 'filling-gaps', stageIndex 2, totalStages 3
- Cap auto-fill at 5 critical/recommended gaps maximum (if more than 5, push the rest to remainingGaps). This keeps pipeline duration reasonable.
- Loop through gaps to fill sequentially (NOT parallel -- position integrity + rate limiting):
  - Check `signal?.aborted` before each gap
  - Report sub-progress: `detail: "Filling gap ${i + 1} of ${total}"`, `subProgress: Math.round(((i + 1) / total) * 100)`
  - Call `provider.generateSlideFromGap(gap, slides, slides[0]?.title || 'Lesson', deckVerbosity)`
  - On success: store `{ slide, suggestedPosition: gap.suggestedPosition }`
  - On failure: push gap to failedGaps array, add warning `"Could not auto-fill gap: ${gap.topic}"`
  - Add 500ms delay between gap generations (`await new Promise(r => setTimeout(r, 500))`) to avoid rate limiting

**Merge:**
- Call `insertGapSlides(slides, generatedGapSlides)` from the utility
- Call `adjustGapPositions([...niceToHave, ...failedGaps, ...overflowGaps], insertedPositions)` to fix remaining gap positions
  - `insertedPositions` = array of suggestedPosition values from successfully generated gaps
- Remaining gaps = adjusted nice-to-have + failed + overflow (those beyond the 5-gap cap)

**Post-merge:**
- Re-run `assignPhasesToSlides()` from `phaseDetection/phaseDetector.ts` on the merged deck so gap slides get lessonPhase labels. Import and call it with the lesson text.
  - Only run if `canAnalyzeGaps` (same mode guard as phase detection in providers)

**Return:** `{ slides: mergedSlides, coveragePercentage, remainingGaps, warnings, wasPartial }`

**Important implementation notes:**
- Do NOT modify any provider methods or their signatures
- Do NOT import from geminiService directly -- use VerbosityLevel from aiProvider re-export
- The pipeline is a standalone function, not a class
- All errors from individual operations should be caught and converted to warnings, not re-thrown (except Pass 1 which should throw on failure since there are no slides to fall back to)
  </action>
  <verify>
`npx tsc --noEmit` passes. Manually verify: the file imports from `./aiProvider`, `../utils/gapSlideInsertion`, and `./phaseDetection/phaseDetector`. Verify the function signature matches the documented exports.
  </verify>
  <done>
`runGenerationPipeline` function exported from `services/generationPipeline.ts`. It orchestrates three passes with progress callbacks, AbortSignal checks between every major operation, graceful degradation (Pass 2/3 failures return Pass 1 slides with warnings), mode gating (refine skips gap analysis), 5-gap cap on auto-fill, 500ms delay between gap generations, phase detection re-run on merged deck, and position-adjusted remaining gaps for the panel.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- no type errors across the project
2. Both new files exist and export the documented types/functions
3. `generationPipeline.ts` imports from `aiProvider` (not directly from geminiService or providers)
4. `gapSlideInsertion.ts` is a pure utility with no side effects
5. No existing files were modified
</verification>

<success_criteria>
- services/generationPipeline.ts exists with runGenerationPipeline, PipelineStage, PipelineProgress, PipelineResult exports
- utils/gapSlideInsertion.ts exists with insertGapSlides and adjustGapPositions exports
- Pipeline handles all three passes with proper error boundaries
- AbortSignal checked between every pass and between gap generations
- Mode gate prevents gap analysis in refine mode
- 5-gap cap on auto-fill prevents excessive API calls
- Phase detection re-runs on merged deck
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/67-generation-pipeline/67-01-SUMMARY.md`
</output>
