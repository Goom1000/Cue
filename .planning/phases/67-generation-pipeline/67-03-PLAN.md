---
phase: 67-generation-pipeline
plan: 03
type: execute
wave: 1
depends_on: ["67-01", "67-02"]
files_modified:
  - services/aiProvider.ts
  - services/providers/claudeProvider.ts
  - services/providers/geminiProvider.ts
  - services/geminiService.ts
  - services/generationPipeline.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Clicking Cancel during Pass 1 (slide generation) immediately aborts the in-flight AI request"
    - "Clicking Cancel during verbosity regeneration loop immediately aborts the current AI call"
    - "Both Claude and Gemini providers respect AbortSignal during generateLessonSlides"
  artifacts:
    - path: "services/aiProvider.ts"
      provides: "Updated AIProviderInterface with signal parameter"
      contains: "signal?: AbortSignal"
    - path: "services/providers/claudeProvider.ts"
      provides: "Signal threaded to fetch() in generateLessonSlides"
      contains: "signal"
    - path: "services/providers/geminiProvider.ts"
      provides: "Signal threaded to geminiGenerateLessonSlides"
      contains: "signal"
    - path: "services/geminiService.ts"
      provides: "Signal threaded to ai.models.generateContent config"
      contains: "abortSignal"
    - path: "services/generationPipeline.ts"
      provides: "Signal passed to generateLessonSlides and checked in verbosity loop"
      contains: "provider.generateLessonSlides(input, undefined, signal)"
  key_links:
    - from: "services/generationPipeline.ts"
      to: "AIProviderInterface.generateLessonSlides"
      via: "signal parameter passthrough"
      pattern: "generateLessonSlides.*signal"
    - from: "services/providers/claudeProvider.ts"
      to: "fetch()"
      via: "signal in fetch options"
      pattern: "signal"
    - from: "services/providers/geminiProvider.ts"
      to: "geminiGenerateLessonSlides"
      via: "signal parameter forwarding"
      pattern: "signal"
    - from: "services/geminiService.ts"
      to: "ai.models.generateContent"
      via: "abortSignal in config"
      pattern: "abortSignal.*signal"
---

<objective>
Thread AbortSignal through the entire slide generation call chain so that Cancel during Pass 1 immediately aborts the in-flight AI request rather than waiting for it to complete.

Purpose: UAT Test 3 revealed that Cancel during Pass 1 (slide generation) is unresponsive because AbortSignal is only checked BETWEEN passes, never passed INTO the provider's `generateLessonSlides` call. The fetch/SDK call runs to completion before the signal is noticed.

Output: Updated interface, both providers, Gemini service, and pipeline -- all threading signal to the actual HTTP/SDK call.
</objective>

<execution_context>
@/Users/ricky/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ricky/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/67-generation-pipeline/67-UAT.md
@.planning/phases/67-generation-pipeline/67-01-SUMMARY.md
@.planning/phases/67-generation-pipeline/67-02-SUMMARY.md
@services/aiProvider.ts
@services/generationPipeline.ts
@services/providers/claudeProvider.ts
@services/providers/geminiProvider.ts
@services/geminiService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Thread AbortSignal through interface, both providers, and Gemini service</name>
  <files>
    services/aiProvider.ts
    services/providers/claudeProvider.ts
    services/providers/geminiProvider.ts
    services/geminiService.ts
  </files>
  <action>
**1. Update AIProviderInterface in `services/aiProvider.ts`**

Add `signal?: AbortSignal` as a third parameter to the `generateLessonSlides` method signature on the interface (line ~287):

```ts
generateLessonSlides(
  inputOrText: GenerationInput | string,
  pageImages?: string[],
  signal?: AbortSignal
): Promise<Slide[]>;
```

This mirrors the existing pattern used by `enhanceDocument` which already accepts `signal?: AbortSignal` as a separate parameter.

**2. Thread signal in `services/providers/claudeProvider.ts`**

a) Update the `callClaude` standalone function (line 588) to accept an optional `signal` parameter:

```ts
async function callClaude(
  apiKey: string,
  messages: ClaudeMessage[],
  systemPrompt: string,
  maxTokens: number = 4096,
  signal?: AbortSignal
): Promise<string> {
```

Pass `signal` into the `fetch()` options object (line 597):

```ts
response = await fetch('https://api.anthropic.com/v1/messages', {
  method: 'POST',
  headers: { ... },
  body: JSON.stringify({ ... }),
  signal   // <-- add this
});
```

b) Update `generateLessonSlides` method (line 692) to accept and forward `signal`:

```ts
async generateLessonSlides(
  inputOrText: GenerationInput | string,
  pageImages?: string[],
  signal?: AbortSignal
): Promise<Slide[]> {
```

Pass signal to the `callClaude` call on line 806:

```ts
const response = await callClaude(this.apiKey, messages, systemPrompt, 8192, signal);
```

**3. Thread signal in `services/geminiService.ts`**

Update the exported `generateLessonSlides` function (line 252) to accept `signal`:

```ts
export const generateLessonSlides = async (
  apiKey: string,
  inputOrText: GenerationInput | string,
  pageImages: string[] = [],
  signal?: AbortSignal
): Promise<Slide[]> => {
```

Pass signal into the `ai.models.generateContent` config object (around line 378):

```ts
config: {
  systemInstruction,
  responseMimeType: "application/json",
  responseSchema: { ... },
  abortSignal: signal    // <-- add this (same pattern as generateSingleVersion)
}
```

**4. Thread signal in `services/providers/geminiProvider.ts`**

Update `generateLessonSlides` method (line 175) to accept and forward `signal`:

```ts
async generateLessonSlides(
  inputOrText: GenerationInput | string,
  pageImages?: string[],
  signal?: AbortSignal
): Promise<Slide[]> {
  try {
    return await geminiGenerateLessonSlides(this.apiKey, inputOrText, pageImages || [], signal);
  } catch (error) {
    throw this.wrapError(error);
  }
}
```

**Important: Do NOT modify any other methods on the providers.** Only `generateLessonSlides` and `callClaude` are touched. The existing `enhanceDocument` signal pattern already works correctly and should not be changed.
  </action>
  <verify>
Run `npx tsc --noEmit` from the project root. Zero type errors confirms the interface, both providers, and the Gemini service all agree on the updated signature.
  </verify>
  <done>
AIProviderInterface.generateLessonSlides accepts signal as third parameter. Claude provider threads it to fetch(). Gemini provider threads it to geminiGenerateLessonSlides which threads it to ai.models.generateContent config.abortSignal. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Pass signal from pipeline and add abort checks in verbosity loop</name>
  <files>
    services/generationPipeline.ts
  </files>
  <action>
**1. Thread signal to generateLessonSlides call**

On line 116 of `services/generationPipeline.ts`, change:

```ts
let slides = await provider.generateLessonSlides(input);
```

to:

```ts
let slides = await provider.generateLessonSlides(input, undefined, signal);
```

The `undefined` is for the legacy `pageImages` parameter (the pipeline always uses `GenerationInput` which carries images internally).

**2. Add abort check at the top of the verbosity regeneration loop**

In the verbosity loop (lines 120-145), add an abort check at the start of each iteration, BEFORE the `regenerateTeleprompter` call. This prevents wasting API calls on slides that will be discarded:

```ts
if (deckVerbosity !== 'standard') {
  for (let i = 0; i < slides.length; i++) {
    // Check cancellation before each verbosity regeneration
    if (signal?.aborted) break;

    const slide = slides[i];
    // ... rest of loop unchanged
  }
}
```

The existing abort check after the verbosity loop (line 148 `if (signal?.aborted)`) already handles the early return with partial results, so no additional return logic is needed. The `break` exits the loop, and the existing check handles returning `wasPartial: true`.

**3. Thread signal to regenerateTeleprompter calls (optional improvement)**

The `regenerateTeleprompter` method on the interface does NOT currently accept a signal parameter, and adding it would require changing both providers for a different method. Skip this -- the per-iteration abort check before each call is sufficient since individual teleprompter calls are fast (~2-3 seconds each). The signal threaded into `generateLessonSlides` handles the long Pass 1 call which is the actual UAT issue.

**Do NOT change any other abort checks in the file.** The existing checks between Pass 2 and Pass 3 (lines 148, 227, 256) are correct and should remain unchanged.
  </action>
  <verify>
1. `npx tsc --noEmit` passes with zero errors.
2. Grep for `generateLessonSlides(input, undefined, signal)` in generationPipeline.ts confirms signal is passed.
3. Grep for `signal?.aborted.*break` in generationPipeline.ts confirms abort check in verbosity loop.
  </verify>
  <done>
Pipeline passes AbortSignal to the Pass 1 generateLessonSlides call, and checks abort before each iteration of the verbosity regeneration loop. When user clicks Cancel during Pass 1, the in-flight fetch/SDK call is immediately aborted via the signal, and the existing AbortError handling in App.tsx (from Plan 67-02) catches and displays the info toast.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` compiles with zero errors
2. In `services/aiProvider.ts`: `AIProviderInterface.generateLessonSlides` has `signal?: AbortSignal` as third parameter
3. In `services/providers/claudeProvider.ts`: `callClaude` accepts and passes `signal` to `fetch()`, `generateLessonSlides` forwards signal to `callClaude`
4. In `services/providers/geminiProvider.ts`: `generateLessonSlides` forwards signal to `geminiGenerateLessonSlides`
5. In `services/geminiService.ts`: `generateLessonSlides` accepts signal and passes it as `abortSignal` in Gemini SDK config
6. In `services/generationPipeline.ts`: line 116 passes signal to `provider.generateLessonSlides`, verbosity loop checks `signal?.aborted` before each iteration
</verification>

<success_criteria>
- AbortSignal flows from pipeline -> provider interface -> Claude fetch() / Gemini SDK generateContent()
- Cancel during Pass 1 immediately aborts the HTTP request (not just checked after completion)
- Verbosity regeneration loop exits early on cancel instead of running all remaining slides
- All TypeScript compiles cleanly with zero errors
- No changes to any other provider methods or unrelated code
</success_criteria>

<output>
After completion, create `.planning/phases/67-generation-pipeline/67-03-SUMMARY.md`
</output>
