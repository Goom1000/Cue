---
phase: 34-deck-wide-verbosity
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - components/PresentationView.tsx
autonomous: true

must_haves:
  truths:
    - "Verbosity selector in teleprompter panel changes deck-wide level"
    - "Changing verbosity shows confirmation dialog with slide count"
    - "After confirmation, progress indicator shows regeneration progress"
    - "All slides contain new teleprompter content at selected verbosity"
    - "Per-slide verbosity caches are cleared when deck verbosity changes"
    - "User can cancel regeneration mid-process"
    - "Cancellation restores all slides to pre-regeneration state"
  artifacts:
    - path: "components/PresentationView.tsx"
      provides: "Deck-wide verbosity toggle with batch regeneration"
      contains: "deckVerbosity"
  key_links:
    - from: "components/PresentationView.tsx"
      to: "provider.regenerateTeleprompter"
      via: "sequential batch loop"
      pattern: "provider\\.regenerateTeleprompter"
    - from: "verbosity selector buttons"
      to: "confirmation dialog"
      via: "setPendingVerbosity + setShowVerbosityConfirm"
      pattern: "setShowVerbosityConfirm\\(true\\)"
---

<objective>
Replace per-slide verbosity selector with deck-wide verbosity toggle that regenerates all slides.

Purpose: Allow teachers to change teleprompter style for entire presentation in one action, with confirmation, progress tracking, cancellation support, and error handling.

Output: Modified PresentationView.tsx with deck-wide verbosity state, confirmation dialog, batch regeneration with progress overlay, and cancel/rollback capability.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-deck-wide-verbosity/34-CONTEXT.md
@.planning/phases/34-deck-wide-verbosity/34-RESEARCH.md
@components/PresentationView.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace per-slide verbosity with deck-wide state and UI</name>
  <files>components/PresentationView.tsx</files>
  <action>
Replace the per-slide verbosity system with deck-wide verbosity:

1. **State changes** (around line 143-146):
   - Rename `verbosityLevel` to `deckVerbosity`
   - Keep `isRegenerating` but rename to clarify single-slide use
   - Add batch state:
     ```typescript
     const [deckVerbosity, setDeckVerbosity] = useState<VerbosityLevel>('standard');
     const [showVerbosityConfirm, setShowVerbosityConfirm] = useState(false);
     const [pendingVerbosity, setPendingVerbosity] = useState<VerbosityLevel | null>(null);
     const [batchState, setBatchState] = useState<{
       isActive: boolean;
       totalSlides: number;
       completedSlides: number;
       currentSlideIndex: number;
       failedSlides: Set<string>;
       abortController: AbortController | null;
       snapshot: Slide[] | null;
     }>({
       isActive: false,
       totalSlides: 0,
       completedSlides: 0,
       currentSlideIndex: 0,
       failedSlides: new Set(),
       abortController: null,
       snapshot: null,
     });
     ```

2. **Update the verbosity effect** (around line 298-308):
   - Change `verbosityLevel` references to `deckVerbosity`
   - Update cache lookup to use `deckVerbosity`

3. **Update currentScriptSegment** (around line 1112):
   - Change to use `deckVerbosity` instead of `regeneratedScript`:
     ```typescript
     const currentScriptSegment = useMemo(() => {
       let rawScript: string;
       if (deckVerbosity === 'standard') {
         rawScript = currentSlide.speakerNotes || "";
       } else {
         rawScript = currentSlide.verbosityCache?.[deckVerbosity] || currentSlide.speakerNotes || "";
       }
       // ... rest of segment parsing unchanged
     }, [currentIndex, currentSlide, deckVerbosity, showFullScript, /* other deps */]);
     ```
   - Remove dependency on `regeneratedScript` state

4. **Update verbosity selector UI** (around line 1491-1532):
   - Change label from "Script Style" to "Deck Style"
   - Update onClick to trigger confirmation instead of direct change:
     ```tsx
     onClick={() => {
       if (level === deckVerbosity) return;  // No-op for same level
       setPendingVerbosity(level);
       setShowVerbosityConfirm(true);
     }}
     ```
   - Update disabled check: `batchState.isActive || (!isAIAvailable && level !== 'standard')`
   - Update selected state check: `deckVerbosity === level`
   - Remove the "Regen" button (no longer needed for deck-wide - regeneration happens on level change)

5. **Add confirmation dialog** (after verbosity selector, before script content):
   ```tsx
   {showVerbosityConfirm && pendingVerbosity && (
     <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
       <div className="bg-slate-800 rounded-2xl p-6 max-w-md mx-4 shadow-2xl border border-slate-700">
         <h3 className="text-lg font-bold text-white mb-2">
           Change Teleprompter Style
         </h3>
         <p className="text-slate-300 mb-6">
           This will regenerate all {slides.length} slides at <span className="font-bold text-indigo-400">{pendingVerbosity}</span> verbosity.
         </p>
         <div className="flex gap-3 justify-end">
           <button
             onClick={() => { setShowVerbosityConfirm(false); setPendingVerbosity(null); }}
             className="px-4 py-2 text-sm font-medium text-slate-400 hover:text-white transition-colors"
           >
             Cancel
           </button>
           <button
             onClick={handleConfirmDeckRegeneration}
             className="px-4 py-2 bg-indigo-600 text-white rounded-lg font-medium hover:bg-indigo-500 transition-colors"
           >
             Regenerate
           </button>
         </div>
       </div>
     </div>
   )}
   ```

6. **Remove per-slide verbosity handler** (around line 947-992):
   - Delete or comment out `handleVerbosityChange` function (no longer needed)
   - Keep `handleRegenerateScript` but update it to use `deckVerbosity` instead of `verbosityLevel`

7. **Update any remaining `verbosityLevel` references** to `deckVerbosity`:
   - Search for all occurrences and update
   - Update the single-slide regenerate handler if kept
  </action>
  <verify>
    - `npm run build` passes with no type errors
    - Search for "verbosityLevel" shows no remaining references (all renamed to deckVerbosity)
    - Confirmation dialog JSX present in file
    - Selector shows "Deck Style" label
  </verify>
  <done>
    - deckVerbosity state replaces verbosityLevel
    - Batch state added for tracking regeneration
    - Confirmation dialog appears when changing level
    - Selector disabled during batch regeneration
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement batch regeneration with progress, cancel, and error handling</name>
  <files>components/PresentationView.tsx</files>
  <action>
Implement the batch regeneration logic triggered by confirmation:

1. **Add handleConfirmDeckRegeneration function** (near other handlers):
   ```typescript
   const handleConfirmDeckRegeneration = async () => {
     if (!provider || !pendingVerbosity) return;

     const newLevel = pendingVerbosity;
     setShowVerbosityConfirm(false);
     setPendingVerbosity(null);

     const abortController = new AbortController();
     // Snapshot current state for rollback (deep copy speakerNotes and verbosityCache)
     const snapshot = slides.map(s => ({
       id: s.id,
       speakerNotes: s.speakerNotes,
       verbosityCache: s.verbosityCache ? { ...s.verbosityCache } : undefined
     }));

     setBatchState({
       isActive: true,
       totalSlides: slides.length,
       completedSlides: 0,
       currentSlideIndex: 0,
       failedSlides: new Set(),
       abortController,
       snapshot,
     });

     // Clear all per-slide caches upfront (DECK-04)
     for (const slide of slides) {
       onUpdateSlide(slide.id, { verbosityCache: undefined });
     }

     const failedIds = new Set<string>();

     for (let i = 0; i < slides.length; i++) {
       // Check for cancellation
       if (abortController.signal.aborted) {
         // Rollback all slides to snapshot
         for (const s of snapshot) {
           onUpdateSlide(s.id, {
             speakerNotes: s.speakerNotes,
             verbosityCache: s.verbosityCache,
           });
         }
         setBatchState(prev => ({ ...prev, isActive: false, snapshot: null, abortController: null }));
         return;
       }

       const slide = slides[i];
       setBatchState(prev => ({ ...prev, currentSlideIndex: i }));

       let success = false;
       // Retry once on failure (per CONTEXT.md)
       for (let attempt = 0; attempt < 2 && !success; attempt++) {
         try {
           const prevSlide = i > 0 ? slides[i - 1] : undefined;
           const nextSlide = i < slides.length - 1 ? slides[i + 1] : undefined;

           const newScript = await provider.regenerateTeleprompter(
             slide,
             newLevel,
             prevSlide,
             nextSlide
           );

           // Update slide based on verbosity level
           if (newLevel === 'standard') {
             onUpdateSlide(slide.id, {
               speakerNotes: newScript,
               verbosityCache: undefined,
             });
           } else {
             onUpdateSlide(slide.id, {
               verbosityCache: { [newLevel]: newScript },
             });
           }

           success = true;
         } catch (err) {
           if (attempt === 0) {
             // Wait 1 second before retry
             await new Promise(r => setTimeout(r, 1000));
           }
         }
       }

       if (!success) {
         failedIds.add(slide.id);
       }

       setBatchState(prev => ({
         ...prev,
         completedSlides: prev.completedSlides + 1,
         failedSlides: new Set(failedIds),
       }));
     }

     // Complete - update deck verbosity level
     setDeckVerbosity(newLevel);
     setBatchState(prev => ({
       ...prev,
       isActive: false,
       snapshot: null,
       abortController: null,
     }));
   };
   ```

2. **Add progress overlay** (render at component level, after confirmation dialog):
   ```tsx
   {batchState.isActive && (
     <div className="fixed inset-0 bg-black/70 flex items-center justify-center z-50">
       <div className="bg-slate-800 rounded-2xl p-8 max-w-md mx-4 shadow-2xl border border-slate-700 text-center">
         <div className="w-12 h-12 border-4 border-indigo-500 border-t-transparent rounded-full animate-spin mx-auto mb-4" />
         <h3 className="text-lg font-bold text-white mb-2">
           Regenerating Slides
         </h3>
         <p className="text-slate-300 mb-4">
           Regenerating slide {batchState.currentSlideIndex + 1} of {batchState.totalSlides}...
         </p>
         <div className="w-full bg-slate-700 rounded-full h-2 mb-4">
           <div
             className="bg-indigo-500 h-2 rounded-full transition-all duration-300"
             style={{ width: `${(batchState.completedSlides / batchState.totalSlides) * 100}%` }}
           />
         </div>
         <p className="text-slate-500 text-sm mb-4">
           {batchState.completedSlides} of {batchState.totalSlides} complete
         </p>
         <button
           onClick={() => batchState.abortController?.abort()}
           className="px-4 py-2 text-slate-400 hover:text-white transition-colors border border-slate-600 rounded-lg hover:border-slate-500"
         >
           Cancel
         </button>
       </div>
     </div>
   )}
   ```

3. **Add failed slides notification** (after progress overlay):
   ```tsx
   {batchState.failedSlides.size > 0 && !batchState.isActive && (
     <div className="fixed bottom-4 right-4 bg-amber-900/90 border border-amber-700 rounded-xl p-4 shadow-2xl z-40 max-w-sm">
       <div className="flex items-start gap-3">
         <div className="w-8 h-8 bg-amber-600 rounded-full flex items-center justify-center shrink-0">
           <svg className="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
             <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
           </svg>
         </div>
         <div className="flex-1">
           <p className="text-amber-300 font-medium text-sm">
             {batchState.failedSlides.size} slide{batchState.failedSlides.size > 1 ? 's' : ''} failed to regenerate
           </p>
           <p className="text-amber-400/70 text-xs mt-1">
             These slides kept their original scripts.
           </p>
         </div>
         <button
           onClick={() => setBatchState(prev => ({ ...prev, failedSlides: new Set() }))}
           className="text-amber-400 hover:text-white transition-colors"
         >
           <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
             <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
           </svg>
         </button>
       </div>
     </div>
   )}
   ```

4. **Clean up unused state**:
   - Remove `regeneratedScript` state if no longer needed
   - Remove `setRegeneratedScript` calls
   - Keep `isRegenerating` only if single-slide regenerate button is retained; otherwise remove

5. **Update the single-slide "Regen" button** (if kept):
   - If keeping the regenerate button for single slides, update it to use `deckVerbosity`
   - If removing (since deck-wide handles all cases), remove the button and `handleRegenerateScript`
   - Recommendation: REMOVE the Regen button since changing deck verbosity regenerates all slides. The "Regen" was for single-slide regeneration which is now superseded.
  </action>
  <verify>
    - `npm run build` passes with no type errors
    - `handleConfirmDeckRegeneration` function exists
    - Progress overlay JSX present with spinner, counter, progress bar, and cancel button
    - Failed slides notification JSX present
    - No TypeScript errors about unused variables
  </verify>
  <done>
    - Batch regeneration runs sequentially through all slides
    - Progress overlay shows "Regenerating slide X of Y"
    - Cancel button triggers AbortController.abort()
    - Cancellation rolls back all slides to snapshot state
    - Failed slides tracked and displayed in notification
    - Retry logic attempts each slide twice before marking failed
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Build check:**
   ```bash
   npm run build
   ```
   Must pass with no errors.

2. **Code verification:**
   - `deckVerbosity` state exists in PresentationView.tsx
   - `batchState` with isActive, totalSlides, completedSlides, currentSlideIndex, failedSlides, abortController, snapshot
   - `showVerbosityConfirm` and `pendingVerbosity` state for dialog
   - `handleConfirmDeckRegeneration` async function
   - Confirmation dialog JSX with slide count message
   - Progress overlay JSX with spinner, counter, progress bar, cancel button
   - Failed slides notification JSX

3. **Requirement mapping:**
   - DECK-01: Selector labeled "Deck Style", uses deckVerbosity
   - DECK-02: Confirmation dialog shows on level change
   - DECK-03: handleConfirmDeckRegeneration loops through all slides
   - DECK-04: verbosityCache cleared before regeneration starts
   - DECK-05: Progress overlay with "slide X of Y" counter
</verification>

<success_criteria>
- Verbosity selector in presentation mode is deck-wide (not per-slide)
- Changing verbosity level shows confirmation dialog with slide count
- Confirming triggers batch regeneration of all slides
- Progress overlay shows during regeneration with cancel option
- Cancellation restores all slides to pre-regeneration state
- Failed slides tracked and user notified
- All per-slide verbosity caches cleared on deck-wide change
- Build passes with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/34-deck-wide-verbosity/34-01-SUMMARY.md`
</output>
