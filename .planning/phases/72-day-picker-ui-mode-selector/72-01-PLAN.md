---
phase: 72-day-picker-ui-mode-selector
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - services/scriptedParser/scriptedParser.ts
  - services/aiProvider.ts
  - services/generationPipeline.ts
autonomous: true
requirements: [MODE-01, MODE-02]

must_haves:
  truths:
    - "detectScriptedMarkers() returns true for text containing Say:/Ask:/Write on board:/Activity: markers"
    - "detectScriptedMarkers() returns false for text with no scripted markers"
    - "Pipeline filters days by selectedDays when provided, flattens all days when not"
    - "GenerationInput accepts optional selectedDays number array"
  artifacts:
    - path: "services/scriptedParser/scriptedParser.ts"
      provides: "detectScriptedMarkers() pure function export"
      contains: "export function detectScriptedMarkers"
    - path: "services/aiProvider.ts"
      provides: "selectedDays field on GenerationInput"
      contains: "selectedDays"
    - path: "services/generationPipeline.ts"
      provides: "Day filtering in scripted mode block"
      contains: "selectedDays"
  key_links:
    - from: "services/generationPipeline.ts"
      to: "services/aiProvider.ts"
      via: "GenerationInput.selectedDays consumed in scripted mode block"
      pattern: "input\\.selectedDays"
    - from: "services/scriptedParser/scriptedParser.ts"
      to: "MARKER_PATTERNS"
      via: "detectScriptedMarkers reuses existing MARKER_PATTERNS array"
      pattern: "MARKER_PATTERNS"
---

<objective>
Add backend infrastructure for scripted mode detection and day selection filtering.

Purpose: Plan 02 (UI) needs a lightweight marker detection function to auto-suggest scripted mode, and the pipeline needs to filter days by the user's selection before mapping blocks to slides. These are pure-function additions with no UI changes.

Output: `detectScriptedMarkers()` export, `GenerationInput.selectedDays` field, pipeline day filtering logic
</objective>

<execution_context>
@/Users/ricky/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ricky/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/72-day-picker-ui-mode-selector/72-RESEARCH.md

@services/scriptedParser/scriptedParser.ts
@services/scriptedParser/types.ts
@services/aiProvider.ts
@services/generationPipeline.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add detectScriptedMarkers() pure function to scriptedParser.ts</name>
  <files>services/scriptedParser/scriptedParser.ts</files>
  <action>
Add a new exported function `detectScriptedMarkers(text: string): boolean` to `scriptedParser.ts`.

This function checks whether the given text contains any scripted markers (Say:, Ask:, Write on board:, Activity:) without doing a full parse. It should be cheap -- stop at first match.

Implementation approach:
- Reuse the existing `MARKER_PATTERNS` array already defined in the file (it has `.regex` for each marker)
- Iterate lines, test each line against each pattern, return `true` on first match
- Return `false` if no marker found in any line

```typescript
/**
 * Quick detection of scripted markers in text.
 * Returns true if at least one explicit marker (Say:, Ask:, etc.) is found.
 * Used by UI to auto-suggest scripted import mode (MODE-01).
 * Much cheaper than a full parse -- stops at first match.
 */
export function detectScriptedMarkers(text: string): boolean {
  const lines = text.split('\n');
  for (const line of lines) {
    for (const pattern of MARKER_PATTERNS) {
      if (pattern.regex.test(line)) return true;
    }
  }
  return false;
}
```

Place the function after `parseScriptedLessonPlan()` at the end of the file, before any closing comments.

IMPORTANT: The regex patterns in `MARKER_PATTERNS` may have `lastIndex` state if they use the `g` flag. Check the existing patterns -- if they do NOT use `g` flag, the `.test()` approach is safe. If they DO use `g` flag, reset `.lastIndex = 0` before each test or use `.test()` on a fresh regex. Looking at the codebase, MARKER_PATTERNS uses non-global regexes, so `.test()` is safe.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no TypeScript errors. Grep for `detectScriptedMarkers` in scriptedParser.ts to confirm export exists.
  </verify>
  <done>
`detectScriptedMarkers()` is exported from scriptedParser.ts, returns true for text with markers and false for text without.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add selectedDays to GenerationInput and pipeline day filtering</name>
  <files>services/aiProvider.ts, services/generationPipeline.ts</files>
  <action>
**In `services/aiProvider.ts`:**

Add `selectedDays?: number[]` field to the `GenerationInput` interface (after `supplementaryResourceText`):

```typescript
  selectedDays?: number[];  // Day numbers to include in scripted import (omit = all days)
```

**In `services/generationPipeline.ts`:**

Replace the current day flattening at lines 179-181:
```typescript
    const parseResult = parseScriptedLessonPlan(lessonPlanText);
    // Flatten all days' blocks (day selection is Phase 72)
    const allBlocks = parseResult.days.flatMap(day => day.blocks);
```

With day filtering logic:
```typescript
    const parseResult = parseScriptedLessonPlan(lessonPlanText);
    // Filter days by selection (Phase 72), or include all if no selection provided
    const selectedDaySet = input.selectedDays
      ? new Set(input.selectedDays)
      : null;
    const filteredDays = selectedDaySet
      ? parseResult.days.filter(d => selectedDaySet.has(d.dayNumber))
      : parseResult.days;
    const allBlocks = filteredDays.flatMap(day => day.blocks);
```

This is backward-compatible: when `selectedDays` is undefined (existing callers), all days are included. When provided (Phase 72 UI), only selected days are mapped to slides.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no TypeScript errors. Verify the comment "day selection is Phase 72" is replaced with actual filtering logic.
  </verify>
  <done>
`GenerationInput` has `selectedDays?: number[]` field. Pipeline scripted mode filters days by selection before flattening blocks. Existing behavior (no selection = all days) is preserved.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `detectScriptedMarkers` is exported from scriptedParser.ts
3. `selectedDays` field exists on GenerationInput interface in aiProvider.ts
4. Pipeline scripted mode block uses `input.selectedDays` for day filtering
5. All existing tests pass: `npx jest --passWithNoTests`
</verification>

<success_criteria>
- detectScriptedMarkers() returns true for "Say: Hello class" and false for "Hello class"
- GenerationInput.selectedDays is typed as `number[] | undefined`
- Pipeline day filtering preserves backward compatibility (undefined = all days)
- Zero TypeScript errors, zero test regressions
</success_criteria>

<output>
After completion, create `.planning/phases/72-day-picker-ui-mode-selector/72-01-SUMMARY.md`
</output>
