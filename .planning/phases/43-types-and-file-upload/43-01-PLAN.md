---
phase: 43-types-and-file-upload
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - types.ts
  - services/uploadService.ts
  - services/documentProcessors/pdfProcessor.ts
  - services/documentProcessors/imageProcessor.ts
  - services/documentProcessors/docxProcessor.ts
autonomous: true

must_haves:
  truths:
    - "PDF files can be processed to extract thumbnail and page count"
    - "Image files can be processed to generate thumbnail"
    - "Word documents can be processed to extract text and estimate page count"
    - "File size validation rejects files over 25MB"
    - "Page count validation rejects documents over 20 pages"
  artifacts:
    - path: "types.ts"
      provides: "UploadedResource interface"
      contains: "interface UploadedResource"
    - path: "services/uploadService.ts"
      provides: "File validation and processing orchestration"
      exports: ["processUploadedFile", "validateFile"]
    - path: "services/documentProcessors/pdfProcessor.ts"
      provides: "PDF thumbnail and page count extraction"
      exports: ["processPdf"]
    - path: "services/documentProcessors/imageProcessor.ts"
      provides: "Image thumbnail generation"
      exports: ["processImage"]
    - path: "services/documentProcessors/docxProcessor.ts"
      provides: "Word document text extraction via mammoth.js"
      exports: ["processDocx"]
  key_links:
    - from: "services/uploadService.ts"
      to: "services/documentProcessors/*.ts"
      via: "imports and routing by file type"
      pattern: "import.*from.*documentProcessors"
    - from: "services/uploadService.ts"
      to: "types.ts"
      via: "UploadedResource type"
      pattern: "import.*UploadedResource.*from"
---

<objective>
Create the type definitions and document processing services for resource file upload.

Purpose: Establish the foundation for processing PDF, image, and Word document uploads. This includes the UploadedResource type that will be used throughout the enhancement pipeline, validation utilities for file size/page limits, and format-specific processors that extract thumbnails and content.

Output: Complete type definitions in types.ts, uploadService.ts for orchestration, and three document processors (PDF, image, docx) in a new services/documentProcessors/ directory.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/43-types-and-file-upload/43-RESEARCH.md

Key codebase patterns:
- Existing processPdf in App.tsx uses pdf.js CDN (already loaded)
- File processing returns promises with structured results
- Types are centralized in types.ts at project root
- Services are in services/ directory (flat structure currently)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install mammoth.js and add UploadedResource type</name>
  <files>package.json, types.ts</files>
  <action>
1. Install mammoth.js for Word document processing:
   ```bash
   npm install mammoth
   ```

2. Add UploadedResource interface to types.ts (after LessonResource interface, around line 252):
   ```typescript
   // Uploaded resource for AI enhancement (Phase 43+)
   export type UploadedResourceType = 'pdf' | 'image' | 'docx';

   export interface UploadedResource {
     id: string;                    // crypto.randomUUID()
     filename: string;              // Original filename
     type: UploadedResourceType;
     thumbnail: string;             // Base64 data URL
     pageCount: number;             // Actual for PDF, 1 for images, estimate for docx
     sizeBytes: number;
     uploadedAt: string;            // ISO 8601
     // Raw content for AI processing (populated during enhancement phase)
     content?: {
       text?: string;               // Extracted text (all types)
       images?: string[];           // Page images as base64 (PDF only)
     };
   }
   ```

3. Add validation error type:
   ```typescript
   // Upload validation error (Phase 43+)
   export interface UploadValidationError {
     code: 'FILE_TOO_LARGE' | 'TOO_MANY_PAGES' | 'UNSUPPORTED_TYPE' | 'PROCESSING_ERROR';
     message: string;
   }
   ```
  </action>
  <verify>
- `npm ls mammoth` shows mammoth installed
- TypeScript compiles without errors: `npx tsc --noEmit`
  </verify>
  <done>
- mammoth.js is installed as a dependency
- UploadedResource interface is defined in types.ts
- UploadValidationError interface is defined in types.ts
  </done>
</task>

<task type="auto">
  <name>Task 2: Create document processors</name>
  <files>services/documentProcessors/pdfProcessor.ts, services/documentProcessors/imageProcessor.ts, services/documentProcessors/docxProcessor.ts</files>
  <action>
1. Create services/documentProcessors/ directory

2. Create pdfProcessor.ts:
   - Use existing pdf.js CDN pattern from App.tsx (pdfjsLib.GlobalWorkerOptions.workerSrc already set)
   - Extract page count via pdf.numPages
   - Generate thumbnail from first page at scale 0.5 (smaller than full render)
   - Return { thumbnail, pageCount, type: 'pdf' }
   - Throw error with code 'TOO_MANY_PAGES' if pageCount > 20

   ```typescript
   declare const pdfjsLib: any;

   export interface PdfProcessResult {
     thumbnail: string;
     pageCount: number;
     type: 'pdf';
   }

   export async function processPdf(file: File): Promise<PdfProcessResult> {
     const arrayBuffer = await file.arrayBuffer();
     pdfjsLib.GlobalWorkerOptions.workerSrc =
       'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

     const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
     const pageCount = pdf.numPages;

     if (pageCount > 20) {
       throw { code: 'TOO_MANY_PAGES', message: `PDF has ${pageCount} pages (maximum 20)` };
     }

     // Generate thumbnail from first page
     const page = await pdf.getPage(1);
     const viewport = page.getViewport({ scale: 0.5 });
     const canvas = document.createElement('canvas');
     const context = canvas.getContext('2d')!;
     canvas.height = viewport.height;
     canvas.width = viewport.width;
     await page.render({ canvasContext: context, viewport }).promise;
     const thumbnail = canvas.toDataURL('image/jpeg', 0.7);

     return { thumbnail, pageCount, type: 'pdf' };
   }
   ```

3. Create imageProcessor.ts:
   - Read file as base64 using FileReader
   - Generate thumbnail by resizing to max 200px dimension (maintain aspect ratio)
   - Return { thumbnail, pageCount: 1, type: 'image', base64 }

   ```typescript
   export interface ImageProcessResult {
     thumbnail: string;
     pageCount: 1;
     type: 'image';
     base64: string;  // Full resolution for AI processing
   }

   export async function processImage(file: File): Promise<ImageProcessResult> {
     return new Promise((resolve, reject) => {
       const reader = new FileReader();
       reader.onload = (e) => {
         const base64 = e.target?.result as string;

         const img = new Image();
         img.onload = () => {
           const canvas = document.createElement('canvas');
           const MAX_SIZE = 200;
           const scale = Math.min(MAX_SIZE / img.width, MAX_SIZE / img.height);
           canvas.width = img.width * scale;
           canvas.height = img.height * scale;
           const ctx = canvas.getContext('2d')!;
           ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

           resolve({
             thumbnail: canvas.toDataURL('image/jpeg', 0.7),
             pageCount: 1,
             type: 'image',
             base64
           });
         };
         img.onerror = () => reject({ code: 'PROCESSING_ERROR', message: 'Failed to load image' });
         img.src = base64;
       };
       reader.onerror = () => reject({ code: 'PROCESSING_ERROR', message: 'Failed to read image file' });
       reader.readAsDataURL(file);
     });
   }
   ```

4. Create docxProcessor.ts:
   - Import mammoth from 'mammoth'
   - Extract raw text using mammoth.extractRawText()
   - Estimate page count: Math.ceil(text.length / 3000)
   - Generate a placeholder thumbnail (Word icon SVG as data URL)
   - Throw error if estimated pages > 20

   ```typescript
   import mammoth from 'mammoth';

   export interface DocxProcessResult {
     thumbnail: string;
     pageCount: number;  // Estimated
     type: 'docx';
     text: string;
   }

   // Simple Word document icon as inline SVG data URL
   const DOCX_ICON = `data:image/svg+xml,${encodeURIComponent(`
     <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 96 96" fill="none">
       <rect x="12" y="8" width="72" height="80" rx="4" fill="#2B579A"/>
       <path d="M24 28h48M24 40h48M24 52h48M24 64h32" stroke="white" stroke-width="4" stroke-linecap="round"/>
       <text x="48" y="82" text-anchor="middle" fill="white" font-size="14" font-weight="bold">DOCX</text>
     </svg>
   `)}`;

   export async function processDocx(file: File): Promise<DocxProcessResult> {
     const arrayBuffer = await file.arrayBuffer();
     const result = await mammoth.extractRawText({ arrayBuffer });
     const text = result.value;

     // Estimate pages (~3000 chars per page)
     const pageCount = Math.max(1, Math.ceil(text.length / 3000));

     if (pageCount > 20) {
       throw { code: 'TOO_MANY_PAGES', message: `Document has approximately ${pageCount} pages (maximum 20)` };
     }

     return {
       thumbnail: DOCX_ICON,
       pageCount,
       type: 'docx',
       text
     };
   }
   ```
  </action>
  <verify>
- All three files exist in services/documentProcessors/
- TypeScript compiles without errors: `npx tsc --noEmit`
- Each processor exports its main function
  </verify>
  <done>
- pdfProcessor.ts extracts thumbnail and page count using existing pdf.js
- imageProcessor.ts generates thumbnails and preserves full resolution
- docxProcessor.ts uses mammoth.js to extract text and estimate pages
- All processors validate page count and throw structured errors
  </done>
</task>

<task type="auto">
  <name>Task 3: Create upload service with validation and routing</name>
  <files>services/uploadService.ts</files>
  <action>
Create services/uploadService.ts that orchestrates file validation and routes to appropriate processor:

```typescript
import { UploadedResource, UploadValidationError } from '../types';
import { processPdf } from './documentProcessors/pdfProcessor';
import { processImage } from './documentProcessors/imageProcessor';
import { processDocx } from './documentProcessors/docxProcessor';

// File size limit: 25MB
const MAX_FILE_SIZE_BYTES = 25 * 1024 * 1024;

// Accepted MIME types mapped to our resource types
const ACCEPTED_TYPES: Record<string, 'pdf' | 'image' | 'docx'> = {
  'application/pdf': 'pdf',
  'image/png': 'image',
  'image/jpeg': 'image',
  'image/jpg': 'image',
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document': 'docx'
};

// Accepted file extensions (fallback for MIME detection)
const EXTENSION_MAP: Record<string, 'pdf' | 'image' | 'docx'> = {
  '.pdf': 'pdf',
  '.png': 'image',
  '.jpg': 'image',
  '.jpeg': 'image',
  '.docx': 'docx'
};

/**
 * Detect file type from MIME type or extension fallback.
 * Returns null if unsupported.
 */
export function getFileType(file: File): 'pdf' | 'image' | 'docx' | null {
  // Check MIME type first
  if (ACCEPTED_TYPES[file.type]) {
    return ACCEPTED_TYPES[file.type];
  }

  // Fallback to extension (some browsers don't set MIME correctly)
  const ext = '.' + file.name.split('.').pop()?.toLowerCase();
  return EXTENSION_MAP[ext] || null;
}

/**
 * Validate file before processing.
 * Returns null if valid, or error object if invalid.
 */
export function validateFile(file: File): UploadValidationError | null {
  // Check file size
  if (file.size > MAX_FILE_SIZE_BYTES) {
    const sizeMB = (file.size / (1024 * 1024)).toFixed(1);
    return {
      code: 'FILE_TOO_LARGE',
      message: `File size (${sizeMB}MB) exceeds 25MB limit`
    };
  }

  // Check file type
  const fileType = getFileType(file);
  if (!fileType) {
    return {
      code: 'UNSUPPORTED_TYPE',
      message: `Unsupported file type. Please upload PDF, PNG, JPG, or DOCX files.`
    };
  }

  return null;
}

/**
 * Process an uploaded file and return an UploadedResource.
 * Validates first, then routes to appropriate processor.
 * Throws UploadValidationError on failure.
 */
export async function processUploadedFile(file: File): Promise<UploadedResource> {
  // Validate first
  const validationError = validateFile(file);
  if (validationError) {
    throw validationError;
  }

  const fileType = getFileType(file)!; // Safe - validated above

  // Route to appropriate processor
  let result: { thumbnail: string; pageCount: number; type: 'pdf' | 'image' | 'docx'; text?: string; base64?: string };

  try {
    switch (fileType) {
      case 'pdf':
        result = await processPdf(file);
        break;
      case 'image':
        result = await processImage(file);
        break;
      case 'docx':
        result = await processDocx(file);
        break;
    }
  } catch (err: any) {
    // Re-throw structured errors from processors
    if (err.code) {
      throw err as UploadValidationError;
    }
    // Wrap unexpected errors
    throw {
      code: 'PROCESSING_ERROR',
      message: err.message || 'Failed to process file'
    } as UploadValidationError;
  }

  // Build UploadedResource
  const resource: UploadedResource = {
    id: crypto.randomUUID(),
    filename: file.name,
    type: result.type,
    thumbnail: result.thumbnail,
    pageCount: result.pageCount,
    sizeBytes: file.size,
    uploadedAt: new Date().toISOString()
  };

  // Attach extracted content if available (for AI processing in later phases)
  if (result.type === 'docx' && 'text' in result) {
    resource.content = { text: result.text };
  } else if (result.type === 'image' && 'base64' in result) {
    resource.content = { images: [result.base64] };
  }
  // Note: PDF content (text + page images) will be extracted in Phase 44 (AI Analysis)

  return resource;
}

/**
 * Get accepted file extensions for input accept attribute.
 */
export function getAcceptedExtensions(): string {
  return '.pdf,.png,.jpg,.jpeg,.docx';
}
```
  </action>
  <verify>
- File exists at services/uploadService.ts
- TypeScript compiles without errors: `npx tsc --noEmit`
- Exports validateFile, processUploadedFile, getFileType, getAcceptedExtensions
  </verify>
  <done>
- uploadService.ts validates file size (25MB) and type (PDF, PNG, JPG, DOCX)
- uploadService.ts routes to appropriate processor based on detected file type
- uploadService.ts returns UploadedResource with id, thumbnail, pageCount, etc.
- getAcceptedExtensions() helper for input accept attribute
  </done>
</task>

</tasks>

<verification>
1. Dependencies installed:
   - `npm ls mammoth` shows mammoth installed

2. Types compile:
   - `npx tsc --noEmit` completes without errors

3. Service structure:
   - services/uploadService.ts exists with exports
   - services/documentProcessors/pdfProcessor.ts exists
   - services/documentProcessors/imageProcessor.ts exists
   - services/documentProcessors/docxProcessor.ts exists
</verification>

<success_criteria>
- mammoth.js is installed as project dependency
- UploadedResource and UploadValidationError types are defined in types.ts
- Three document processors exist with proper typing
- uploadService.ts validates files and orchestrates processing
- All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/43-types-and-file-upload/43-01-SUMMARY.md`
</output>
