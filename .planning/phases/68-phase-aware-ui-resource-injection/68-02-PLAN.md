---
phase: 68-phase-aware-ui-resource-injection
plan: 02
type: execute
wave: 2
depends_on: ["68-01"]
files_modified:
  - utils/resourceInjection.ts
  - services/aiProvider.ts
  - services/generationPipeline.ts
  - services/geminiService.ts
  - services/providers/claudeProvider.ts
  - App.tsx
  - components/ResourceHub.tsx
autonomous: true

must_haves:
  truths:
    - "Resources uploaded on the landing page appear pre-populated in ResourceHub without re-uploading"
    - "AI generation prompt includes supplementary resource text with callout instructions"
    - "Generated slides contain callout references like [See: Resource Title] where resources are relevant"
    - "Resource injection only happens in Pass 1 (generate) -- NOT in Pass 2 (gap analysis) or Pass 3 (fill gaps)"
    - "Both Gemini and Claude providers produce identical resource injection behavior"
  artifacts:
    - path: "utils/resourceInjection.ts"
      provides: "buildResourceInjectionText shared utility"
      exports: ["buildResourceInjectionText"]
    - path: "services/aiProvider.ts"
      provides: "supplementaryResourceText field on GenerationInput"
      contains: "supplementaryResourceText"
    - path: "services/generationPipeline.ts"
      provides: "Resource text passed through pipeline to Pass 1 only"
    - path: "services/geminiService.ts"
      provides: "Resource text appended to user prompt in Gemini generation"
    - path: "services/providers/claudeProvider.ts"
      provides: "Resource text appended to user prompt in Claude generation"
    - path: "App.tsx"
      provides: "supplementaryResources wired to ResourceHub + resource text built for generation"
    - path: "components/ResourceHub.tsx"
      provides: "supplementaryResources prop accepted and merged into initial upload state"
  key_links:
    - from: "App.tsx handleGenerate"
      to: "utils/resourceInjection.ts"
      via: "buildResourceInjectionText called with supplementaryResources"
      pattern: "buildResourceInjectionText"
    - from: "App.tsx handleGenerate"
      to: "GenerationInput"
      via: "supplementaryResourceText field set on generationInput"
      pattern: "supplementaryResourceText"
    - from: "services/generationPipeline.ts"
      to: "provider.generateLessonSlides"
      via: "Pass-through: resource text lives on GenerationInput, consumed by Pass 1 only"
      pattern: "input\\.supplementaryResourceText"
    - from: "services/geminiService.ts"
      to: "utils/resourceInjection.ts"
      via: "NOT direct -- resource text arrives via GenerationInput.supplementaryResourceText"
    - from: "App.tsx ResourceHub render"
      to: "components/ResourceHub.tsx"
      via: "supplementaryResources prop"
      pattern: "supplementaryResources=\\{supplementaryResources\\}"
---

<objective>
Wire supplementary resources into the generation pipeline and pre-populate ResourceHub. The AI will weave resource content into generated slides with callout references, and resources uploaded on the landing page will appear in ResourceHub without re-uploading.

Purpose: Teachers' supplementary resources (worksheets, case studies, handouts) are woven into AI-generated slides, and the ResourceHub shows all resources regardless of where they were uploaded. Both Gemini and Claude handle resource injection identically via a shared utility.

Output: buildResourceInjectionText utility, GenerationInput extension, provider prompt modifications, ResourceHub pre-population, pipeline wiring.
</objective>

<execution_context>
@/Users/ricky/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ricky/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/68-phase-aware-ui-resource-injection/68-RESEARCH.md
@.planning/phases/68-phase-aware-ui-resource-injection/68-01-SUMMARY.md
@.planning/phases/66-resource-processing-upload/66-02-SUMMARY.md
@utils/resourceCapping.ts
@services/aiProvider.ts (GenerationInput interface at line 68-76)
@services/generationPipeline.ts (Pass 1 at line 116, pipeline does NOT touch GenerationInput fields)
@services/geminiService.ts (user prompt construction at lines 329-335)
@services/providers/claudeProvider.ts (user prompt construction at lines 758-773)
@App.tsx (handleGenerate at lines 571-579, ResourceHub render at lines 2161-2172, supplementaryResources state at line 342)
@components/ResourceHub.tsx (props interface at lines 12-23, mount effect at lines 67-88)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create buildResourceInjectionText utility and extend GenerationInput</name>
  <files>utils/resourceInjection.ts, services/aiProvider.ts</files>
  <action>
    1. Create NEW file `utils/resourceInjection.ts`:
       - Import `capResourceContent` from `./resourceCapping`
       - Import `UploadedResource` from `../types`
       - Export function `buildResourceInjectionText(resources: UploadedResource[]): string`
         - If `!resources || resources.length === 0`, return empty string `''`
         - Call `capResourceContent(resources)` to get a `Map<string, string>` of ID -> capped text
         - If capped map is empty (no resources had text content), return empty string
         - Build and return a prompt section string:
           ```
           \n\n---\nSUPPLEMENTARY TEACHING RESOURCES\nWeave content from these resources into relevant slides. Add callout references like "[See: {filename}]" on slides where the resource is most relevant.\n\n
           ```
         - For each resource in the input array, if the capped map has an entry for its ID, append: `### {resource.filename}\n{cappedText}\n\n`
       - This function is provider-agnostic -- both Gemini and Claude will use the same output string.

    2. In `services/aiProvider.ts`, add an optional field to the `GenerationInput` interface (after `gradeLevel` at line 75):
       ```typescript
       supplementaryResourceText?: string;  // Capped resource text for prompt injection (Pass 1 only)
       ```
       This field carries the pre-built resource text from App.tsx into the pipeline and providers. No other changes to aiProvider.ts.
  </action>
  <verify>
    - `utils/resourceInjection.ts` exists and exports `buildResourceInjectionText`
    - `services/aiProvider.ts` has `supplementaryResourceText` on GenerationInput
    - `npx tsc --noEmit` passes
  </verify>
  <done>Shared buildResourceInjectionText utility produces capped, formatted resource text for prompt injection. GenerationInput carries the text to providers.</done>
</task>

<task type="auto">
  <name>Task 2: Inject resource text into both provider generation prompts</name>
  <files>services/geminiService.ts, services/providers/claudeProvider.ts</files>
  <action>
    **Gemini provider (`services/geminiService.ts`):**
    In the `generateLessonSlides` function, after the text prompt is pushed to `contents[]` (lines 329-335) and BEFORE the `addImages` helper calls (line 338), append the resource text to the last text content part:
    - Check if `input.supplementaryResourceText` is truthy
    - If so, the last `contents` entry is the text prompt. Append the resource text to it:
      ```typescript
      if (input.supplementaryResourceText) {
        contents[contents.length - 1].text += input.supplementaryResourceText;
      }
      ```
    - This appends resource text AFTER the lesson text / verbosity instruction, within the same text content block. The AI sees it as part of the user message, not the system prompt.

    **Claude provider (`services/providers/claudeProvider.ts`):**
    In the `generateLessonSlides` method, after the text prompt is pushed to `contentParts[]` (lines 758-773) and BEFORE the `addImages` helper calls (line 776), append the resource text to the last text content part:
    - Check if `input.supplementaryResourceText` is truthy
    - If so, the last `contentParts` entry is the text block. Append:
      ```typescript
      if (input.supplementaryResourceText) {
        const lastPart = contentParts[contentParts.length - 1];
        if (lastPart.type === 'text') {
          lastPart.text += input.supplementaryResourceText;
        }
      }
      ```

    **CRITICAL: Resource injection is ONLY in generateLessonSlides (Pass 1).** Do NOT modify `analyzeGaps` (Pass 2) or `generateSlideFromGap` (Pass 3). The pipeline passes `GenerationInput` to `generateLessonSlides` -- the providers read `input.supplementaryResourceText` there. Gap analysis and gap filling have their own separate prompt structures that must NOT include resource text.

    **CRITICAL: Both providers must produce identical injection.** The text is built by the same `buildResourceInjectionText` utility and arrives as the same string. The injection point is structurally identical: appended to the user prompt text after lesson content.
  </action>
  <verify>
    - Both providers check `input.supplementaryResourceText` and append it to user prompt
    - No changes to `analyzeGaps` or `generateSlideFromGap` methods
    - `npx tsc --noEmit` passes
    - `npx vite build` succeeds
  </verify>
  <done>Both Gemini and Claude append identical resource injection text to the Pass 1 generation prompt. Gap analysis and gap filling are unaffected.</done>
</task>

<task type="auto">
  <name>Task 3: Wire resource text through App.tsx handleGenerate and pre-populate ResourceHub</name>
  <files>App.tsx, components/ResourceHub.tsx</files>
  <action>
    **App.tsx -- Build and pass resource text in handleGenerate:**
    1. Add import: `import { buildResourceInjectionText } from './utils/resourceInjection';`
    2. In `handleGenerate` (line 571-579 area), after building the `generationInput` object, add the resource text:
       ```typescript
       const generationInput: GenerationInput = {
         lessonText: lessonText,
         lessonImages: pageImages.length > 0 ? pageImages : undefined,
         presentationText: existingPptText || undefined,
         presentationImages: existingPptImages.length > 0 ? existingPptImages : undefined,
         mode: uploadMode as GenerationMode,
         verbosity: deckVerbosity,
         gradeLevel: 'Year 6 (10-11 years old)',
         supplementaryResourceText: buildResourceInjectionText(supplementaryResources),  // NEW
       };
       ```
       The `supplementaryResources` state (line 342) is already in scope. `buildResourceInjectionText` handles empty arrays gracefully (returns '').

    **App.tsx -- Pass supplementaryResources to ResourceHub:**
    3. In the ResourceHub render (lines 2162-2172), add a new prop:
       ```tsx
       <ResourceHub
           lessonText={lessonText}
           slideContext={JSON.stringify(slides)}
           slides={slides}
           onClose={() => setShowResourceHub(false)}
           provider={provider}
           onError={handleComponentError}
           onRequestAI={handleRequestAI}
           enhancedResourceStates={enhancedResourceStates}
           onEnhancedResourcesChange={setEnhancedResourceStates}
           supplementaryResources={supplementaryResources}
       />
       ```

    **ResourceHub.tsx -- Accept and merge supplementaryResources:**
    4. Add `supplementaryResources` to the props interface (line 12-23):
       ```typescript
       interface ResourceHubProps {
         // ... existing props ...
         supplementaryResources?: UploadedResource[];
       }
       ```
    5. Destructure in the component function (line 25-35): add `supplementaryResources = []` to the destructuring.
    6. Import `UploadedResource` from types if not already imported (check -- it IS already imported on line 3).
    7. In the mount useEffect (lines 67-88), AFTER the existing `enhancedResourceStates` restore block, add a block to merge supplementary resources:
       ```typescript
       // Pre-populate with supplementary resources from landing page (RES-06)
       if (supplementaryResources.length > 0) {
         setUploadedResources(prev => {
           // Deduplicate by resource ID -- enhancedResourceStates may overlap
           const existingIds = new Set(prev.map(r => r.id));
           const newResources = supplementaryResources.filter(r => !existingIds.has(r.id));
           return newResources.length > 0 ? [...prev, ...newResources] : prev;
         });
       }
       ```
       This COPIES supplementary resources into local state (no reference sharing) and deduplicates by ID in case the same resource appears in both `enhancedResourceStates` and `supplementaryResources`.

    **Note on generationPipeline.ts:** No changes needed. The pipeline passes the full `GenerationInput` object to `provider.generateLessonSlides(input, undefined, signal)` at line 116. The `supplementaryResourceText` field travels through automatically. Gap analysis (Pass 2) and gap filling (Pass 3) use separate method calls (`provider.analyzeGaps`, `provider.generateSlideFromGap`) that do NOT receive GenerationInput, so resource text is naturally excluded.
  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `npx vite build` succeeds
    - In App.tsx handleGenerate: generationInput includes supplementaryResourceText
    - In App.tsx ResourceHub render: supplementaryResources prop is passed
    - In ResourceHub: prop is accepted, destructured, and merged into uploadedResources on mount
    - generationPipeline.ts is NOT modified (resource text passes through automatically via GenerationInput)
  </verify>
  <done>
    handleGenerate builds resource injection text from supplementaryResources and passes it through the pipeline to Pass 1 only. ResourceHub pre-populates with landing-page resources on mount with ID-based deduplication. Both Gemini and Claude receive identical resource-augmented prompts. Provider parity (PROV-01, PROV-02) is achieved via the shared buildResourceInjectionText utility.
  </done>
</task>

</tasks>

<verification>
1. Upload a lesson plan PDF + 1-2 supplementary resources (PPTX/PDF) on the landing page
2. Generate slides -- the AI should produce slides that reference the supplementary resources with callout markers like "[See: worksheet.pptx]"
3. Open ResourceHub in the editor -- supplementary resources from the landing page appear without re-uploading
4. Verify the same lesson + resources produces callout references on BOTH Gemini and Claude providers
5. Run gap analysis manually after generation -- resource text should NOT appear in gap analysis prompts (no resource-related gaps suggested by AI)
6. TypeScript compiles with no errors
7. Vite build succeeds
</verification>

<success_criteria>
- buildResourceInjectionText produces formatted, capped resource text with callout instructions
- GenerationInput carries supplementaryResourceText to providers
- Both providers append resource text to user prompt identically (Pass 1 only)
- App.tsx builds resource text in handleGenerate and passes supplementaryResources to ResourceHub
- ResourceHub merges landing-page resources into its local state on mount with deduplication
- Gap analysis and gap filling are completely unaffected by resource injection
- Build compiles cleanly
</success_criteria>

<output>
After completion, create `.planning/phases/68-phase-aware-ui-resource-injection/68-02-SUMMARY.md`
</output>
