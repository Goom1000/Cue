---
phase: 02-display-targeting
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - components/PermissionExplainer.tsx
  - components/ManualPlacementGuide.tsx
  - components/PresentationView.tsx
autonomous: true

must_haves:
  truths:
    - "On Chromium with multiple monitors, user sees explanation UI before browser permission prompt"
    - "After permission granted, Launch button shows target display name"
    - "After permission granted, student window opens directly on secondary display"
    - "On Firefox/Safari (or permission denied), user sees manual placement instructions"
    - "Manual instructions include copyable student URL"
  artifacts:
    - path: "components/PermissionExplainer.tsx"
      provides: "Pre-permission explanation UI component"
      exports: ["default"]
      min_lines: 40
    - path: "components/ManualPlacementGuide.tsx"
      provides: "Fallback instructions for non-Chromium browsers"
      exports: ["default"]
      min_lines: 30
    - path: "components/PresentationView.tsx"
      provides: "Integrated display targeting in launch flow"
      contains: "useWindowManagement"
  key_links:
    - from: "components/PresentationView.tsx"
      to: "hooks/useWindowManagement.ts"
      via: "hook import and usage"
      pattern: "useWindowManagement"
    - from: "components/PresentationView.tsx"
      to: "window.open with coordinates"
      via: "secondaryScreen.left/top/width/height"
      pattern: "left=.*secondaryScreen"
    - from: "components/PermissionExplainer.tsx"
      to: "requestPermission callback"
      via: "button onClick"
      pattern: "onRequestPermission"
---

<objective>
Create the display targeting UI components and integrate them into PresentationView, completing the automatic projector placement feature for Chromium users and providing graceful fallback for others.

Purpose: Teachers on Chrome/Edge get seamless auto-placement of student window on projector. Teachers on Firefox/Safari get clear instructions for manual placement.

Output: PermissionExplainer.tsx, ManualPlacementGuide.tsx components; PresentationView.tsx updated with display targeting integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-display-targeting/02-RESEARCH.md
@.planning/phases/02-display-targeting/02-01-SUMMARY.md
@components/PresentationView.tsx
@hooks/useWindowManagement.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Permission Explainer and Manual Placement Guide Components</name>
  <files>components/PermissionExplainer.tsx, components/ManualPlacementGuide.tsx</files>
  <action>
Create two new React components for display targeting UI.

**PermissionExplainer.tsx:**

Props interface:
```typescript
interface PermissionExplainerProps {
  onRequestPermission: () => Promise<void>;
  onSkip: () => void;
}
```

Requirements:
- Blue-themed card (bg-blue-50, border-blue-200) matching existing app style
- Icon: monitor/display icon (use emoji or SVG)
- Header: "Auto-Place on Projector"
- Body text explaining the feature: "We can automatically open the student view on your projector instead of your laptop screen."
- Secondary text explaining the permission: "Your browser will ask permission to 'manage windows on all displays' - this just lets us know where your projector is."
- Two buttons:
  - Primary: "Enable Auto-Placement" - calls onRequestPermission, shows "Requesting..." while loading
  - Secondary: "Skip, I'll drag it" - calls onSkip
- Use existing Tailwind classes (rounded-xl, font-poppins, etc.)
- Add loading state with disabled button during request

**ManualPlacementGuide.tsx:**

Props interface:
```typescript
interface ManualPlacementGuideProps {
  studentUrl: string;
}
```

Requirements:
- Amber-themed card (bg-amber-50, border-amber-200) to indicate fallback/attention
- Icon: pointing hand or drag indicator
- Header: "Drag Window to Projector"
- Body text: "Your browser doesn't support automatic display targeting. After the student window opens:"
- Numbered instructions:
  1. Grab the title bar of the new window
  2. Drag it to your projector/external display
  3. Press F11 or double-click to go fullscreen
- Alternative section: "Or open this URL directly on the projector:"
- URL display with copy button (use navigator.clipboard.writeText)
- Copy button shows "Copied!" feedback for 2 seconds

Match the visual style of the existing popup blocked fallback UI in PresentationView.tsx for consistency.
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. Both components can be imported without errors
3. Visual inspection: Components render correctly with appropriate styling
  </verify>
  <done>PermissionExplainer shows explanation with two action buttons. ManualPlacementGuide shows numbered instructions and copyable URL. Both match app styling.</done>
</task>

<task type="auto">
  <name>Task 2: Integrate Display Targeting into PresentationView</name>
  <files>components/PresentationView.tsx</files>
  <action>
Update PresentationView to use the useWindowManagement hook and new UI components.

**1. Add imports:**
```typescript
import useWindowManagement from '../hooks/useWindowManagement';
import PermissionExplainer from './PermissionExplainer';
import ManualPlacementGuide from './ManualPlacementGuide';
```

**2. Add hook and state:**
```typescript
const {
  isSupported,
  hasMultipleScreens,
  permissionState,
  secondaryScreen,
  requestPermission
} = useWindowManagement();

const [showPermissionExplainer, setShowPermissionExplainer] = useState(false);
```

**3. Show PermissionExplainer when appropriate:**
Add useEffect that triggers when entering presentation mode with multi-screen Chromium setup:
```typescript
useEffect(() => {
  if (isSupported && hasMultipleScreens && permissionState === 'prompt') {
    setShowPermissionExplainer(true);
  }
}, [isSupported, hasMultipleScreens, permissionState]);
```

**4. Update window.open logic (CRITICAL: must remain synchronous):**
Modify the existing click handler to use cached secondaryScreen coordinates:
```typescript
const handleLaunchStudent = () => {
  const url = `${window.location.origin}${window.location.pathname}#/student`;

  let features = 'width=1280,height=720';

  // Use pre-cached coordinates from hook (no async!)
  if (secondaryScreen) {
    features = `left=${secondaryScreen.left},top=${secondaryScreen.top},` +
               `width=${secondaryScreen.width},height=${secondaryScreen.height}`;
  }

  const studentWindow = window.open(url, 'pipi-student', features);
  // ... rest of existing popup blocked handling
};
```
Replace the inline onClick with a call to handleLaunchStudent.

**5. Update button text:**
When secondaryScreen is available, show the display name:
```typescript
{secondaryScreen
  ? `Launch on ${secondaryScreen.label}`
  : isStudentWindowOpen
    ? 'Student Active'
    : 'Launch Student'
}
```

**6. Show appropriate UI components:**
Add near the header (after the launch button area or as a modal/toast):

```jsx
{/* Permission Explainer - shown before first launch on Chromium multi-screen */}
{showPermissionExplainer && (
  <PermissionExplainer
    onRequestPermission={async () => {
      await requestPermission();
      setShowPermissionExplainer(false);
    }}
    onSkip={() => setShowPermissionExplainer(false)}
  />
)}

{/* Manual Guide - shown for non-Chromium OR permission denied */}
{hasMultipleScreens && (!isSupported || permissionState === 'denied') && !isStudentWindowOpen && (
  <ManualPlacementGuide
    studentUrl={`${window.location.origin}${window.location.pathname}#/student`}
  />
)}
```

Position these as fixed overlays (similar to existing popupBlocked UI) or inline in the header area.

**7. Cleanup considerations:**
- Remove redundant state if PermissionExplainer handles its own loading
- Keep popupBlocked fallback - it handles a different failure mode
- Don't show both ManualPlacementGuide AND popupBlocked at same time

**Key constraint from research:** The window.open() call MUST remain synchronous. All permission and screen detection happens BEFORE the click. The click handler only uses cached secondaryScreen values.
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `npm run build` succeeds
3. Manual test on Chrome with single monitor: No permission UI shown
4. Manual test on Chrome with multiple monitors: PermissionExplainer appears on presentation start
5. Manual test on Firefox: ManualPlacementGuide shown (isSupported=false)
6. After granting permission: Button text shows display name, window opens on correct screen
  </verify>
  <done>
- PresentationView uses useWindowManagement hook
- PermissionExplainer shows on Chromium multi-screen with prompt state
- ManualPlacementGuide shows for non-Chromium or denied permission
- Launch button uses cached coordinates for secondary screen targeting
- Button text shows target display name when available
- All flows work: auto-placement, skip to manual, permission denied, non-Chromium
  </done>
</task>

</tasks>

<verification>
**Chromium (Chrome/Edge) with external monitor:**
1. Enter presentation mode
2. PermissionExplainer appears explaining the feature
3. Click "Enable Auto-Placement" -> browser permission prompt appears
4. Grant permission -> button shows "Launch on [Display Name]"
5. Click launch -> student window opens directly on secondary display
6. Window is sized to fill secondary screen

**Chromium with permission denied:**
1. Enter presentation mode
2. PermissionExplainer appears
3. Grant then revoke permission (or deny)
4. ManualPlacementGuide appears with instructions
5. Launch still works, opens on primary, user drags to projector

**Firefox/Safari:**
1. Enter presentation mode
2. ManualPlacementGuide appears immediately (no permission explainer)
3. Launch works, opens on primary
4. User follows instructions to drag

**Single monitor (any browser):**
1. No display targeting UI shown
2. Launch works normally
</verification>

<success_criteria>
- On Chrome/Edge with external monitor, student window automatically opens on secondary display
- Permission prompt is preceded by explanation UI so teacher understands why
- On Firefox/Safari (or when permission denied), clear instructions appear for dragging window to projector
- TypeScript compiles, build succeeds
- All three phase success criteria met
</success_criteria>

<output>
After completion, create `.planning/phases/02-display-targeting/02-02-SUMMARY.md`
</output>
