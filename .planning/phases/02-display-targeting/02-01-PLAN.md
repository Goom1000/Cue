---
phase: 02-display-targeting
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - types.ts
  - hooks/useWindowManagement.ts
autonomous: true

must_haves:
  truths:
    - "Window Management API types compile without errors"
    - "Hook detects multi-screen setup without permission (screen.isExtended)"
    - "Hook tracks permission state (prompt/granted/denied/unavailable)"
    - "Hook provides cached secondary screen coordinates when permission granted"
    - "Hook exposes requestPermission function that returns success boolean"
  artifacts:
    - path: "types.ts"
      provides: "ScreenDetailed, ScreenDetails, Window.getScreenDetails types"
      contains: "interface ScreenDetailed"
    - path: "hooks/useWindowManagement.ts"
      provides: "useWindowManagement hook"
      exports: ["default"]
      min_lines: 80
  key_links:
    - from: "hooks/useWindowManagement.ts"
      to: "window.getScreenDetails"
      via: "API call with type assertions"
      pattern: "getScreenDetails"
    - from: "hooks/useWindowManagement.ts"
      to: "navigator.permissions.query"
      via: "permission state check"
      pattern: "permissions\\.query"
---

<objective>
Create the Window Management API infrastructure: TypeScript type declarations and a React hook that encapsulates all multi-screen detection and permission handling logic.

Purpose: Establish type-safe foundation for display targeting. The hook abstracts browser API complexity so PresentationView can use simple state values.

Output: types.ts with Window Management API types, hooks/useWindowManagement.ts with complete hook implementation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-display-targeting/02-RESEARCH.md
@types.ts
@hooks/useBroadcastSync.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Window Management API Type Declarations</name>
  <files>types.ts</files>
  <action>
Add TypeScript interface declarations for the experimental Window Management API at the end of types.ts (after the existing Window.PptxGenJS declaration).

Add these interfaces:
1. **ScreenDetailed** extending Screen with:
   - readonly availLeft: number (left edge of available area)
   - readonly availTop: number (top edge of available area)
   - readonly left: number (left edge of screen)
   - readonly top: number (top edge of screen)
   - readonly isPrimary: boolean
   - readonly isInternal: boolean
   - readonly devicePixelRatio: number
   - readonly label: string

2. **ScreenDetails** extending EventTarget with:
   - readonly screens: ReadonlyArray<ScreenDetailed>
   - readonly currentScreen: ScreenDetailed
   - addEventListener overloads for 'screenschange' and 'currentscreenchange'

3. Extend the existing **Window** interface inside the `declare global` block:
   - Add optional getScreenDetails method: `getScreenDetails?(): Promise<ScreenDetails>`

4. Extend **Screen** interface to add:
   - readonly isExtended?: boolean

Note: The Window Management API is experimental and not in lib.dom.d.ts, so we must declare these types ourselves. Use `declare global` to merge with existing window types.
  </action>
  <verify>Run `npx tsc --noEmit` - should pass with no errors</verify>
  <done>TypeScript compiles with new Window Management types. No red squiggles in IDE for getScreenDetails, ScreenDetailed, etc.</done>
</task>

<task type="auto">
  <name>Task 2: Create useWindowManagement Hook</name>
  <files>hooks/useWindowManagement.ts</files>
  <action>
Create a new hook that encapsulates Window Management API logic. Follow the pattern from useBroadcastSync.ts for consistent code style.

**Export interface (return type of hook):**
```typescript
interface UseWindowManagementResult {
  isSupported: boolean;            // API exists in browser
  hasMultipleScreens: boolean;     // screen.isExtended === true
  permissionState: 'prompt' | 'granted' | 'denied' | 'unavailable';
  secondaryScreen: ScreenTarget | null;  // Cached coordinates for window.open
  requestPermission: () => Promise<boolean>;  // Returns true if granted
}

interface ScreenTarget {
  left: number;
  top: number;
  width: number;
  height: number;
  label: string;
}
```

**Implementation requirements:**

1. **Initial state detection (no permission needed):**
   - Check `'getScreenDetails' in window` for API support
   - Check `(window.screen as Screen).isExtended === true` for multi-screen
   - If no API support: permissionState = 'unavailable'
   - If API but single screen: permissionState = 'unavailable'

2. **Permission state check:**
   - Use `navigator.permissions.query({ name: 'window-management' as PermissionName })`
   - Handle rejection (some browsers don't support this query)
   - Listen for permission changes via status.addEventListener('change', ...)

3. **Screen details fetching:**
   - When permission is 'granted', call window.getScreenDetails()
   - Find secondary screen: `screens.find(s => !s.isPrimary)`
   - Extract ScreenTarget: { left: availLeft, top: availTop, width: availWidth, height: availHeight, label }
   - Listen for 'screenschange' event to update when monitors change

4. **requestPermission function:**
   - Call window.getScreenDetails() (triggers browser prompt if needed)
   - Update state with result
   - Return true if granted, false if denied/error
   - Use useCallback for stable reference

5. **Cleanup:**
   - Remove event listeners on unmount
   - Handle component unmount during async operations (use mounted ref pattern)

**Critical patterns from research:**
- screen.isExtended is available WITHOUT permission - use it for feature detection
- Permission state can be checked without prompting via navigator.permissions.query
- getScreenDetails() prompts if permission not yet granted
- screenschange event fires when monitors connect/disconnect

Type assertions needed because these are experimental APIs:
- `(window as Window).getScreenDetails!()`
- `(window.screen as Screen).isExtended`
- `{ name: 'window-management' as PermissionName }`
  </action>
  <verify>
1. `npx tsc --noEmit` passes
2. `npm run build` succeeds
3. Manually test: Import hook in a component, check isSupported/hasMultipleScreens values render correctly
  </verify>
  <done>Hook exports useWindowManagement, correctly detects screen.isExtended, tracks permission state, provides cached secondaryScreen coordinates when granted, and exposes requestPermission function.</done>
</task>

</tasks>

<verification>
After completing both tasks:
1. `npx tsc --noEmit` - TypeScript compiles without errors
2. `npm run build` - Build succeeds
3. Hook can be imported and used in any component
4. On single-monitor setup: isSupported=true (Chrome), hasMultipleScreens=false
5. On multi-monitor Chromium: hasMultipleScreens=true, permissionState starts as 'prompt'
6. On Firefox/Safari: isSupported=false
</verification>

<success_criteria>
- Window Management API types declared in types.ts
- useWindowManagement hook created in hooks/useWindowManagement.ts
- Hook correctly detects multi-screen setup without requiring permission
- Hook provides secondaryScreen coordinates when permission granted
- TypeScript compiles, build succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/02-display-targeting/02-01-SUMMARY.md`
</output>
