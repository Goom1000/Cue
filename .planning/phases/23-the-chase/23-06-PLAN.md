---
phase: 23-the-chase
plan: 06
type: execute
wave: 3
depends_on: ["23-01", "23-02"]
files_modified:
  - components/games/the-chase/FinalChaseRound.tsx
autonomous: true

must_haves:
  truths:
    - "Final Chase has two timed phases: contestant 2-min, then chaser 2-min"
    - "Contestant phase accumulates score from correct answers"
    - "Chaser phase targets contestant's score with pushback on wrong answers"
    - "Wrong chaser answer allows contestant pushback if they answer correctly"
    - "Game ends with win/loss when chaser timer expires"
  artifacts:
    - path: "components/games/the-chase/FinalChaseRound.tsx"
      provides: "Final Chase with pushback mechanic"
      min_lines: 200
  key_links:
    - from: "components/games/the-chase/FinalChaseRound.tsx"
      to: "hooks/useTimer.ts"
      via: "2-minute countdown timers"
      pattern: "useTimer"
    - from: "components/games/the-chase/FinalChaseRound.tsx"
      to: "hooks/useChaserAI.ts"
      via: "chaser answer generation"
      pattern: "useChaserAI"
---

<objective>
Create the Final Chase round - the climactic timed round with pushback mechanics.

Purpose: Per CONTEXT.md, Final Chase has contestant get 2 minutes to build a score, then chaser gets 2 minutes to catch up. When chaser answers wrong, contestant can "push back" by answering the same question correctly, moving chaser back 1 step.

Output: FinalChaseRound component with dual timed phases, score tracking, and pushback mechanic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/23-the-chase/23-CONTEXT.md
@.planning/phases/23-the-chase/23-RESEARCH.md
@.planning/phases/23-the-chase/23-01-SUMMARY.md
@.planning/phases/23-the-chase/23-02-SUMMARY.md
@hooks/useTimer.ts
@hooks/useChaserAI.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create FinalChaseRound component with pushback mechanics</name>
  <files>components/games/the-chase/FinalChaseRound.tsx</files>
  <action>
Create the Final Chase round component:

```typescript
import React, { useState, useEffect, useCallback } from 'react';
import { QuizQuestion } from '../../../services/geminiService';
import { useTimer } from '../../../hooks/useTimer';
import { useChaserAI, ChaserDifficulty } from '../../../hooks/useChaserAI';
import ChaserThinking from './ChaserThinking';

type FinalPhase =
  | 'contestant-intro'     // Brief intro before contestant round
  | 'contestant-round'     // 2-min contestant answering
  | 'transition'           // Brief pause between rounds
  | 'chaser-round'         // 2-min chaser chase
  | 'pushback-opportunity' // Contestant can answer to push back
  | 'complete';            // Game over

interface FinalChaseRoundProps {
  questions: QuizQuestion[];
  headStart: number;            // Steps head start from Head-to-Head (dynamic)
  chaserDifficulty: ChaserDifficulty;
  isAIControlled: boolean;
  prizeAmount: number;
  onComplete: (outcome: 'win' | 'loss', contestantScore: number, chaserScore: number) => void;
  onExit: () => void;
}

const ROUND_DURATION = 120; // 2 minutes = 120 seconds

const FinalChaseRound: React.FC<FinalChaseRoundProps> = ({
  questions,
  headStart,
  chaserDifficulty,
  isAIControlled,
  prizeAmount,
  onComplete,
  onExit
}) => {
  const [phase, setPhase] = useState<FinalPhase>('contestant-intro');
  const [currentQuestionIndex, setCurrentQuestionIndex] = useState(0);
  const [contestantScore, setContestantScore] = useState(0);
  const [chaserScore, setChaserScore] = useState(0);
  const [chaserStepsBack, setChaserStepsBack] = useState(0); // Pushbacks earned
  const [lastChaserWrong, setLastChaserWrong] = useState(false);
  const [showAnswer, setShowAnswer] = useState(false);

  const currentQuestion = questions[currentQuestionIndex];
  const { getChaserAnswer, isThinking } = useChaserAI({ difficulty: chaserDifficulty });

  // Contestant's effective lead = base score + pushbacks earned
  const effectiveLead = contestantScore + chaserStepsBack;
  // Chaser needs to match or exceed effective lead to win
  const chaserTarget = effectiveLead;

  // Contestant timer
  const contestantTimer = useTimer({
    initialSeconds: ROUND_DURATION,
    onComplete: () => {
      // Transition to chaser round
      setPhase('transition');
      setTimeout(() => {
        setCurrentQuestionIndex(0);
        setShowAnswer(false);
        setPhase('chaser-round');
        chaserTimer.start();
      }, 3000);
    },
    autoStart: false
  });

  // Chaser timer
  const chaserTimer = useTimer({
    initialSeconds: ROUND_DURATION,
    onComplete: () => {
      // Chaser ran out of time
      setPhase('complete');
      const win = chaserScore < chaserTarget;
      onComplete(win ? 'win' : 'loss', contestantScore, chaserScore);
    },
    autoStart: false
  });

  // Start contestant round after intro
  useEffect(() => {
    if (phase === 'contestant-intro') {
      const timer = setTimeout(() => {
        setPhase('contestant-round');
        contestantTimer.start();
      }, 3000);
      return () => clearTimeout(timer);
    }
  }, [phase]);

  // Handle contestant answer (during contestant round)
  const handleContestantAnswer = useCallback((selectedIndex: number) => {
    if (phase !== 'contestant-round' || showAnswer) return;

    setShowAnswer(true);
    const isCorrect = selectedIndex === currentQuestion.correctAnswerIndex;

    if (isCorrect) {
      setContestantScore(prev => prev + 1);
    }

    // Move to next question after brief delay
    setTimeout(() => {
      setShowAnswer(false);
      if (currentQuestionIndex < questions.length - 1) {
        setCurrentQuestionIndex(prev => prev + 1);
      }
    }, 500);
  }, [phase, showAnswer, currentQuestion, currentQuestionIndex, questions.length]);

  // Handle chaser answer (during chaser round)
  const handleChaserTurn = useCallback(async () => {
    if (phase !== 'chaser-round') return;

    setShowAnswer(false);
    setLastChaserWrong(false);

    if (isAIControlled) {
      // AI chaser
      const chaserAnswerIdx = await getChaserAnswer(currentQuestion);
      const isCorrect = chaserAnswerIdx === currentQuestion.correctAnswerIndex;

      setShowAnswer(true);

      if (isCorrect) {
        const newScore = chaserScore + 1;
        setChaserScore(newScore);

        // Check if chaser caught up
        if (newScore >= chaserTarget) {
          setPhase('complete');
          chaserTimer.pause();
          onComplete('loss', contestantScore, newScore);
          return;
        }

        // Move to next question
        setTimeout(() => {
          setShowAnswer(false);
          if (currentQuestionIndex < questions.length - 1) {
            setCurrentQuestionIndex(prev => prev + 1);
          }
        }, 800);
      } else {
        // Chaser got it wrong - pushback opportunity
        setLastChaserWrong(true);
        setPhase('pushback-opportunity');
        chaserTimer.pause();
      }
    }
  }, [phase, isAIControlled, currentQuestion, chaserScore, chaserTarget, currentQuestionIndex, questions.length, getChaserAnswer, onComplete, contestantScore]);

  // Handle manual chaser answer (teacher-controlled)
  const handleManualChaserAnswer = useCallback((selectedIndex: number) => {
    if (phase !== 'chaser-round' || !showAnswer || isAIControlled) return;

    const isCorrect = selectedIndex === currentQuestion.correctAnswerIndex;

    if (isCorrect) {
      const newScore = chaserScore + 1;
      setChaserScore(newScore);

      if (newScore >= chaserTarget) {
        setPhase('complete');
        chaserTimer.pause();
        onComplete('loss', contestantScore, newScore);
        return;
      }

      setTimeout(() => {
        setShowAnswer(false);
        if (currentQuestionIndex < questions.length - 1) {
          setCurrentQuestionIndex(prev => prev + 1);
        }
      }, 800);
    } else {
      setLastChaserWrong(true);
      setPhase('pushback-opportunity');
      chaserTimer.pause();
    }
  }, [phase, showAnswer, isAIControlled, currentQuestion, chaserScore, chaserTarget, currentQuestionIndex, questions.length, onComplete, contestantScore]);

  // Handle pushback attempt
  const handlePushbackAttempt = useCallback((selectedIndex: number) => {
    if (phase !== 'pushback-opportunity') return;

    const isCorrect = selectedIndex === currentQuestion.correctAnswerIndex;
    setShowAnswer(true);

    if (isCorrect) {
      // Pushback successful!
      setChaserStepsBack(prev => prev + 1);
    }

    // Continue chaser round
    setTimeout(() => {
      setShowAnswer(false);
      setPhase('chaser-round');
      chaserTimer.start();
      if (currentQuestionIndex < questions.length - 1) {
        setCurrentQuestionIndex(prev => prev + 1);
      }
    }, 1500);
  }, [phase, currentQuestion, currentQuestionIndex, questions.length]);

  // Trigger AI chaser turn when entering chaser round
  useEffect(() => {
    if (phase === 'chaser-round' && isAIControlled && !showAnswer) {
      const delay = setTimeout(handleChaserTurn, 1000);
      return () => clearTimeout(delay);
    }
  }, [phase, isAIControlled, showAnswer, currentQuestionIndex, handleChaserTurn]);

  // Render intro screen
  if (phase === 'contestant-intro') {
    return (
      <div className="w-full h-full bg-gradient-to-br from-amber-900 via-orange-900 to-red-900 flex items-center justify-center">
        <div className="text-center animate-pulse">
          <div className="text-8xl mb-6">‚è±Ô∏è</div>
          <h2 className="text-5xl font-black text-white mb-4">FINAL CHASE</h2>
          <p className="text-2xl text-amber-200">Get ready to answer!</p>
          <p className="text-xl text-white mt-4">Head Start: {headStart} steps</p>
        </div>
      </div>
    );
  }

  // Render transition screen
  if (phase === 'transition') {
    return (
      <div className="w-full h-full bg-gradient-to-br from-red-900 via-rose-900 to-red-800 flex items-center justify-center">
        <div className="text-center">
          <div className="text-8xl mb-6 animate-bounce">üòà</div>
          <h2 className="text-5xl font-black text-white mb-4">CHASER'S TURN!</h2>
          <p className="text-2xl text-red-200">
            Target: {chaserTarget} correct answers
          </p>
          <p className="text-xl text-white mt-4">
            (Your score: {contestantScore} + {chaserStepsBack} pushbacks)
          </p>
        </div>
      </div>
    );
  }

  // Main game view
  const isContestantPhase = phase === 'contestant-round';
  const isChaserPhase = phase === 'chaser-round';
  const isPushback = phase === 'pushback-opportunity';

  return (
    <div className={`w-full h-full flex flex-col p-6 ${
      isContestantPhase
        ? 'bg-gradient-to-br from-blue-900 via-blue-800 to-indigo-900'
        : 'bg-gradient-to-br from-red-900 via-red-800 to-rose-900'
    }`}>
      {/* Header with scores and timer */}
      <div className="flex justify-between items-center mb-6">
        {/* Contestant Score */}
        <div className="bg-blue-800/60 rounded-xl px-6 py-4 border-2 border-blue-600">
          <div className="text-xs text-blue-300 uppercase tracking-wider mb-1">Your Score</div>
          <div className="text-5xl font-bold text-white">
            {contestantScore}
            {chaserStepsBack > 0 && (
              <span className="text-2xl text-green-400 ml-2">+{chaserStepsBack}</span>
            )}
          </div>
        </div>

        {/* Phase Label & Timer */}
        <div className="text-center">
          <h2 className="text-3xl font-black text-white uppercase tracking-widest mb-2">
            {isPushback ? 'PUSHBACK!' : isContestantPhase ? 'YOUR TURN' : 'CHASER\'S TURN'}
          </h2>
          <div className={`text-6xl font-mono font-bold ${
            (isContestantPhase ? contestantTimer.timeRemaining : chaserTimer.timeRemaining) <= 10
              ? 'text-red-400 animate-pulse'
              : 'text-white'
          }`}>
            {isContestantPhase ? contestantTimer.formattedTime : chaserTimer.formattedTime}
          </div>
        </div>

        {/* Chaser Score */}
        <div className="bg-red-800/60 rounded-xl px-6 py-4 border-2 border-red-600">
          <div className="text-xs text-red-300 uppercase tracking-wider mb-1">Chaser</div>
          <div className="text-5xl font-bold text-white">{chaserScore}</div>
          <div className="text-xs text-red-300 mt-1">Target: {chaserTarget}</div>
        </div>
      </div>

      {/* Question Card */}
      <div className="flex-1 flex flex-col justify-center max-w-4xl mx-auto w-full">
        {/* Pushback indicator */}
        {isPushback && (
          <div className="bg-green-600 text-white text-center p-4 rounded-xl mb-4 animate-pulse">
            <span className="font-bold text-xl">PUSHBACK OPPORTUNITY!</span>
            <span className="block text-sm">Answer correctly to push the Chaser back 1 step</span>
          </div>
        )}

        {/* Question */}
        <div className="bg-white/10 p-8 rounded-2xl border-2 border-white/20 mb-6">
          <p className="text-2xl md:text-3xl font-bold text-white">
            {currentQuestion?.question}
          </p>
        </div>

        {/* Answer Options */}
        <div className="grid grid-cols-2 gap-4">
          {currentQuestion?.options.map((option, idx) => {
            const isCorrect = idx === currentQuestion.correctAnswerIndex;

            return (
              <button
                key={idx}
                onClick={() => {
                  if (isContestantPhase) handleContestantAnswer(idx);
                  else if (isPushback) handlePushbackAttempt(idx);
                  else if (isChaserPhase && !isAIControlled) handleManualChaserAnswer(idx);
                }}
                disabled={showAnswer || (isChaserPhase && isAIControlled && !isPushback)}
                className={`
                  p-6 rounded-xl text-left font-bold text-lg transition-all border-2
                  ${showAnswer
                    ? isCorrect
                      ? 'bg-green-600 border-green-400 text-white'
                      : 'bg-slate-700 border-slate-600 text-slate-400'
                    : 'bg-white/10 border-white/20 text-white hover:bg-white/20 hover:scale-[1.02]'
                  }
                `}
              >
                <span className="opacity-60 mr-3">{String.fromCharCode(65 + idx)}.</span>
                {option}
              </button>
            );
          })}
        </div>
      </div>

      {/* Chaser Thinking Overlay */}
      <ChaserThinking isVisible={isThinking} />

      {/* Exit button */}
      <div className="mt-4 flex justify-center">
        <button
          onClick={onExit}
          className="px-6 py-2 bg-white/20 hover:bg-white/30 text-white rounded-lg transition-colors"
        >
          End Game
        </button>
      </div>
    </div>
  );
};

export default FinalChaseRound;
```

Key features per CONTEXT.md:
- Contestant gets 2 minutes to answer questions
- Score accumulates for each correct answer
- After 2 min, chaser gets 2 minutes to catch up
- Chaser target = contestant score + any pushbacks
- When chaser answers wrong, pause timer and offer pushback
- Pushback success adds 1 to effective lead
- Chaser wins if they reach/exceed target before time ends
- Contestant wins if chaser's time runs out before catching up
  </action>
  <verify>Run `npm run build` - should compile without errors</verify>
  <done>FinalChaseRound implements 2-min contestant phase, 2-min chaser phase with pushback mechanics, determines win/loss</done>
</task>

</tasks>

<verification>
- `npm run build` passes with no TypeScript errors
- FinalChaseRound starts with contestant intro, then 2-min round
- Contestant score increments on correct answers
- After 2 min, transitions to chaser round with target displayed
- Chaser wrong answer triggers pushback opportunity
- Correct pushback adds to effective lead
- Game ends when chaser timer expires or chaser catches up
</verification>

<success_criteria>
- Final Chase has distinct contestant and chaser phases
- 2-minute countdown timers for each phase
- Contestant builds score, chaser tries to match/exceed
- Pushback mechanic: wrong chaser answer -> contestant can push back
- Successful pushback increases effective lead by 1
- Win: chaser's time expires before matching score
- Loss: chaser matches or exceeds score before time expires
</success_criteria>

<output>
After completion, create `.planning/phases/23-the-chase/23-06-SUMMARY.md`
</output>
