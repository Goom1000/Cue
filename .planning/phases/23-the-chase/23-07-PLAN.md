---
phase: 23-the-chase
plan: 07
type: execute
wave: 4
depends_on: ["23-03", "23-04", "23-05", "23-06"]
files_modified:
  - components/games/TheChaseGame.tsx
  - components/games/GameContainer.tsx
  - components/PresentationView.tsx
autonomous: true

must_haves:
  truths:
    - "TheChaseGame orchestrates all game phases in sequence"
    - "Game flows: Cash Builder -> Offer Selection -> Head-to-Head -> Final Chase"
    - "GameContainer routes to TheChaseGame with proper handlers"
    - "PresentationView launches The Chase with question generation"
  artifacts:
    - path: "components/games/TheChaseGame.tsx"
      provides: "Main game orchestrator with phase management"
      min_lines: 200
    - path: "components/games/GameContainer.tsx"
      provides: "Routing for Chase game handlers"
      contains: "TheChaseGame"
    - path: "components/PresentationView.tsx"
      provides: "Chase game launch with state factory"
      contains: "launchTheChase"
  key_links:
    - from: "components/games/TheChaseGame.tsx"
      to: "components/games/the-chase/CashBuilderRound.tsx"
      via: "phase rendering"
      pattern: "CashBuilderRound"
    - from: "components/PresentationView.tsx"
      to: "services/aiProvider.ts"
      via: "question generation"
      pattern: "generateGameQuestions"
---

<objective>
Integrate all Chase components into a complete game flow with proper orchestration.

Purpose: TheChaseGame needs to manage phase transitions from Cash Builder through Final Chase. GameContainer and PresentationView need updates to launch and handle The Chase properly.

Output: Complete TheChaseGame orchestrator, updated GameContainer routing, PresentationView launch logic.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/23-the-chase/23-CONTEXT.md
@.planning/phases/23-the-chase/23-03-SUMMARY.md
@.planning/phases/23-the-chase/23-04-SUMMARY.md
@.planning/phases/23-the-chase/23-05-SUMMARY.md
@.planning/phases/23-the-chase/23-06-SUMMARY.md
@components/games/GameContainer.tsx
@components/PresentationView.tsx
@types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TheChaseGame orchestrator component</name>
  <files>components/games/TheChaseGame.tsx</files>
  <action>
Replace the placeholder TheChaseGame with full implementation:

```typescript
import React, { useState, useCallback } from 'react';
import { TheChaseState, ChasePhase, ChaseOffer } from '../../types';
import CashBuilderRound from './the-chase/CashBuilderRound';
import OfferSelection from './the-chase/OfferSelection';
import HeadToHeadRound from './the-chase/HeadToHeadRound';
import FinalChaseRound from './the-chase/FinalChaseRound';
import GameOutcome from './the-chase/GameOutcome';
import GameSplash from './shared/GameSplash';

interface TheChaseGameProps {
  state: TheChaseState;
  onClose: () => void;
  onStateUpdate: (updates: Partial<TheChaseState>) => void;
  onRestart?: () => void;
}

const TheChaseGame: React.FC<TheChaseGameProps> = ({
  state,
  onClose,
  onStateUpdate,
  onRestart
}) => {
  // Local UI state for outcomes
  const [showOutcome, setShowOutcome] = useState<'caught' | 'safe' | null>(null);
  const [finalOutcome, setFinalOutcome] = useState<'win' | 'loss' | null>(null);

  // Phase transition handlers
  const handleCashBuilderComplete = useCallback((score: number) => {
    onStateUpdate({
      phase: 'offer-selection',
      cashBuilderScore: score
    });
  }, [onStateUpdate]);

  const handleOfferSelected = useCallback((offer: ChaseOffer, startPosition: number) => {
    onStateUpdate({
      phase: 'head-to-head',
      selectedOfferIndex: state.offers.findIndex(o => o.amount === offer.amount),
      contestantPosition: startPosition,
      chaserPosition: 0
    });
  }, [onStateUpdate, state.offers]);

  const handleHeadToHeadComplete = useCallback((outcome: 'caught' | 'safe', contestantPosition: number) => {
    if (outcome === 'caught') {
      setShowOutcome('caught');
    } else {
      // Calculate head start based on how far contestant got
      // More steps to home = bigger head start
      const stepsToHome = 6 - contestantPosition;
      onStateUpdate({
        phase: 'final-chase-contestant',
        contestantPosition,
        finalChaseContestantScore: 0,
        finalChaseContestantTime: 120,
        finalChaseChaserScore: 0,
        finalChaseChaserTime: 120,
        chaserTargetScore: stepsToHome // Head start becomes target modifier
      });
    }
  }, [onStateUpdate]);

  const handleFinalChaseComplete = useCallback((outcome: 'win' | 'loss', contestantScore: number, chaserScore: number) => {
    setFinalOutcome(outcome);
    onStateUpdate({
      phase: 'game-over',
      finalChaseContestantScore: contestantScore,
      finalChaseChaserScore: chaserScore,
      status: 'result'
    });
  }, [onStateUpdate]);

  const handleOutcomeDismiss = useCallback(() => {
    if (showOutcome === 'caught') {
      onStateUpdate({ phase: 'game-over', status: 'result' });
    }
    setShowOutcome(null);
  }, [showOutcome, onStateUpdate]);

  const handleContinueToFinal = useCallback(() => {
    setShowOutcome(null);
  }, []);

  // Render based on current phase
  const renderPhase = () => {
    // Show splash during loading
    if (state.status === 'loading' || state.status === 'splash') {
      return <GameSplash gameType="the-chase" />;
    }

    // Show outcomes if triggered
    if (showOutcome) {
      return (
        <GameOutcome
          outcome={showOutcome}
          prizeAmount={state.cashBuilderScore * (state.selectedOfferIndex !== null ? [2, 1, 0.5][state.selectedOfferIndex] : 1)}
          onContinue={showOutcome === 'safe' ? handleContinueToFinal : undefined}
          onPlayAgain={onRestart}
          onExit={onClose}
        />
      );
    }

    if (finalOutcome) {
      return (
        <GameOutcome
          outcome={finalOutcome === 'win' ? 'safe' : 'caught'}
          prizeAmount={state.cashBuilderScore * (state.selectedOfferIndex !== null ? [2, 1, 0.5][state.selectedOfferIndex] : 1)}
          onPlayAgain={onRestart}
          onExit={onClose}
        />
      );
    }

    switch (state.phase) {
      case 'cash-builder':
        return (
          <CashBuilderRound
            questions={state.questions}
            onComplete={handleCashBuilderComplete}
            onExit={onClose}
          />
        );

      case 'offer-selection':
        return (
          <OfferSelection
            cashBuilderScore={state.cashBuilderScore}
            onOfferSelected={handleOfferSelected}
            onExit={onClose}
          />
        );

      case 'head-to-head':
        return (
          <HeadToHeadRound
            questions={state.questions.slice(10)} // Use questions after Cash Builder's
            startingPosition={state.contestantPosition}
            chaserDifficulty={state.chaserDifficulty}
            isAIControlled={state.isAIControlled}
            prizeAmount={state.cashBuilderScore * (state.selectedOfferIndex !== null ? [2, 1, 0.5][state.selectedOfferIndex] : 1)}
            onComplete={handleHeadToHeadComplete}
            onExit={onClose}
          />
        );

      case 'final-chase-contestant':
      case 'final-chase-chaser':
        return (
          <FinalChaseRound
            questions={state.questions.slice(20)} // Use remaining questions
            headStart={state.chaserTargetScore}
            chaserDifficulty={state.chaserDifficulty}
            isAIControlled={state.isAIControlled}
            prizeAmount={state.cashBuilderScore * (state.selectedOfferIndex !== null ? [2, 1, 0.5][state.selectedOfferIndex] : 1)}
            onComplete={handleFinalChaseComplete}
            onExit={onClose}
          />
        );

      case 'game-over':
        return (
          <div className="h-full w-full bg-slate-900 flex items-center justify-center">
            <div className="text-center">
              <div className="text-8xl mb-6">{state.finalChaseChaserScore < state.chaserTargetScore ? 'ðŸ†' : 'ðŸ˜ˆ'}</div>
              <h2 className="text-5xl font-black text-white mb-4">
                {state.finalChaseChaserScore < state.chaserTargetScore ? 'YOU WIN!' : 'Chaser Wins'}
              </h2>
              <div className="flex gap-4 justify-center mt-8">
                {onRestart && (
                  <button
                    onClick={onRestart}
                    className="px-8 py-4 bg-indigo-600 hover:bg-indigo-500 text-white font-bold text-xl rounded-xl"
                  >
                    Play Again
                  </button>
                )}
                <button
                  onClick={onClose}
                  className="px-8 py-4 bg-white text-slate-900 font-bold text-xl rounded-xl"
                >
                  Back to Lesson
                </button>
              </div>
            </div>
          </div>
        );

      default:
        return <GameSplash gameType="the-chase" />;
    }
  };

  return (
    <div className="w-full h-full">
      {renderPhase()}
    </div>
  );
};

export default TheChaseGame;
```
  </action>
  <verify>Run `npm run build` - should compile without errors</verify>
  <done>TheChaseGame orchestrates all phases with proper transitions and state updates</done>
</task>

<task type="auto">
  <name>Task 2: Update GameContainer and PresentationView for Chase integration</name>
  <files>components/games/GameContainer.tsx, components/PresentationView.tsx</files>
  <action>
**Update GameContainer.tsx:**

Add Chase-specific handlers to props and route to TheChaseGame:

```typescript
interface GameContainerProps {
  state: GameState;
  onClose: () => void;
  onRevealAnswer: () => void;
  onNextQuestion: () => void;
  onRestart?: () => void;
  // Millionaire-specific handlers (existing)
  onMillionaireSelectOption?: (idx: number) => void;
  onMillionaireLockIn?: () => void;
  onMillionaireNext?: () => void;
  onMillionaireUseLifeline?: (lifeline: 'fiftyFifty' | 'askTheAudience' | 'phoneAFriend') => void;
  isLifelineLoading?: 'phoneAFriend' | null;
  // Chase-specific handlers (new)
  onChaseStateUpdate?: (updates: Partial<TheChaseState>) => void;
}
```

Update the case for 'the-chase':
```typescript
case 'the-chase':
  return (
    <TheChaseGame
      state={state}
      onClose={onClose}
      onStateUpdate={onChaseStateUpdate || (() => {})}
      onRestart={onRestart}
    />
  );
```

**Update PresentationView.tsx:**

1. Add createChaseState factory:
```typescript
const createChaseState = useCallback((questions: QuizQuestion[], difficulty: 'easy' | 'medium' | 'hard'): TheChaseState => ({
  gameType: 'the-chase',
  status: 'playing',
  questions,
  currentQuestionIndex: 0,
  phase: 'cash-builder',
  cashBuilderScore: 0,
  cashBuilderTimeRemaining: 60,
  offers: [],
  selectedOfferIndex: null,
  votes: {},
  isVotingOpen: false,
  contestantPosition: 4, // Middle position default
  chaserPosition: 0,
  chaserDifficulty: difficulty,
  isAIControlled: true,
  isChaserThinking: false,
  finalChaseContestantScore: 0,
  finalChaseContestantTime: 120,
  finalChaseChaserScore: 0,
  finalChaseChaserTime: 120,
  chaserTargetScore: 0,
  currentQuestionAnswered: false,
  contestantAnswer: null,
  chaserAnswer: null,
  showChaserAnswer: false,
}), []);
```

2. Add launchTheChase function (similar pattern to launchMillionaire):
```typescript
const launchTheChase = useCallback(async (difficulty: 'easy' | 'medium' | 'hard') => {
  if (!provider) {
    onRequestAI('start The Chase game');
    return;
  }

  // Show loading state
  setActiveGame({
    ...createChaseState([], difficulty),
    status: 'loading'
  } as TheChaseState);

  try {
    const slideContext = buildSlideContext(slides, currentIndex);
    const request: GameQuestionRequest = {
      gameType: 'the-chase',
      difficulty,
      questionCount: 40, // Need many questions for all phases
      slideContext,
    };

    const questions = await withRetry<QuizQuestion[]>(
      () => provider.generateGameQuestions(request),
      3,
      1000
    );

    if (questions.length === 0) {
      throw new AIProviderError('No questions generated', 'PARSE_ERROR');
    }

    setActiveGame(createChaseState(questions, difficulty));
  } catch (e) {
    console.error(e);
    if (e instanceof AIProviderError) {
      onError('Quiz Generation Failed', e.userMessage);
    } else {
      onError('Quiz Generation Failed', 'An unexpected error occurred');
    }
    setActiveGame(null);
  }
}, [provider, slides, currentIndex, createChaseState, onRequestAI, onError]);
```

3. Add Chase state update handler:
```typescript
const handleChaseStateUpdate = useCallback((updates: Partial<TheChaseState>) => {
  setActiveGame(prev => prev && prev.gameType === 'the-chase'
    ? { ...prev, ...updates }
    : prev
  );
}, []);
```

4. Update handleSelectGame to handle 'the-chase':
```typescript
} else if (gameType === 'the-chase') {
  // Show difficulty selection modal (can reuse a simple confirm or add modal)
  // For now, default to medium difficulty
  launchTheChase('medium');
}
```

5. Pass handler to GameContainer:
```typescript
<GameContainer
  // ... existing props
  onChaseStateUpdate={handleChaseStateUpdate}
/>
```

Import the new Chase types at the top of PresentationView.tsx:
```typescript
import { TheChaseState, ChasePhase } from '../types';
```
  </action>
  <verify>Run `npm run build` - should compile without errors</verify>
  <done>GameContainer routes to TheChaseGame, PresentationView launches Chase with question generation</done>
</task>

</tasks>

<verification>
- `npm run build` passes with no TypeScript errors
- Selecting "The Chase" from GameMenu launches the game
- Questions generate via AI provider
- Cash Builder starts after loading
- Offer Selection follows Cash Builder
- Head-to-Head follows Offer Selection
- Final Chase follows successful Head-to-Head
- Game ends with proper outcome screen
</verification>

<success_criteria>
- TheChaseGame manages all 4 phases with proper transitions
- Phase state updates broadcast to student view
- GameContainer properly routes Chase game type
- PresentationView generates ~40 questions for full game
- Difficulty selection affects chaser accuracy
- Complete game flow works: Cash Builder -> Offers -> Head-to-Head -> Final Chase
</success_criteria>

<output>
After completion, create `.planning/phases/23-the-chase/23-07-SUMMARY.md`
</output>
