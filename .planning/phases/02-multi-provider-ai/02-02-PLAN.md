---
phase: 02-multi-provider-ai
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - services/providers/claudeProvider.ts
autonomous: true

must_haves:
  truths:
    - "Claude provider makes real API calls to Anthropic"
    - "Browser CORS header is included in all requests"
    - "All 9 interface methods are implemented"
    - "Error responses are mapped to AIProviderError with correct codes"
    - "JSON responses are parsed and normalized to match Gemini output format"
  artifacts:
    - path: "services/providers/claudeProvider.ts"
      provides: "Full Claude provider implementation"
      min_lines: 200
  key_links:
    - from: "services/providers/claudeProvider.ts"
      to: "https://api.anthropic.com/v1/messages"
      via: "fetch with CORS header"
      pattern: "anthropic-dangerous-direct-browser-access.*true"
---

<objective>
Implement the Claude provider with full functionality matching Gemini's capabilities.

Purpose: Enable users who prefer Claude to generate slides with the same quality as Gemini. This is the primary alternative provider since OpenAI doesn't support browser CORS.

Output: Fully functional `services/providers/claudeProvider.ts` that can generate slides, images, quizzes, etc.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-multi-provider-ai/02-CONTEXT.md
@.planning/phases/02-multi-provider-ai/02-RESEARCH.md
@.planning/phases/02-multi-provider-ai/02-01-SUMMARY.md (after Plan 1 completes)

Key reference:
@services/geminiService.ts (prompts to adapt)
@services/providers/geminiProvider.ts (interface reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Claude API helper and error mapping</name>
  <files>services/providers/claudeProvider.ts</files>
  <action>
Replace the placeholder claudeProvider.ts with a real implementation.

**1. Add imports:**
```typescript
import { AIProviderInterface, AIProviderError, AIErrorCode, USER_ERROR_MESSAGES } from '../aiProvider';
import { Slide, LessonResource } from '../../types';
import { QuizQuestion } from '../geminiService';
```

**2. Create helper function for Claude API calls:**
```typescript
interface ClaudeMessage {
  role: 'user' | 'assistant';
  content: string | ClaudeContentBlock[];
}

interface ClaudeContentBlock {
  type: 'text' | 'image';
  text?: string;
  source?: { type: 'base64'; media_type: string; data: string };
}

async function callClaude(
  apiKey: string,
  messages: ClaudeMessage[],
  systemPrompt: string,
  maxTokens: number = 4096
): Promise<string> {
  const response = await fetch('https://api.anthropic.com/v1/messages', {
    method: 'POST',
    headers: {
      'content-type': 'application/json',
      'x-api-key': apiKey,
      'anthropic-version': '2023-06-01',
      'anthropic-dangerous-direct-browser-access': 'true',  // REQUIRED for browser
    },
    body: JSON.stringify({
      model: 'claude-sonnet-4-5-20250929',
      max_tokens: maxTokens,
      system: systemPrompt,
      messages,
    }),
  });

  if (!response.ok) {
    const errorBody = await response.json().catch(() => ({}));
    const code = mapHttpToErrorCode(response.status, errorBody);
    throw new AIProviderError(USER_ERROR_MESSAGES[code], code, errorBody);
  }

  const data = await response.json();
  return data.content?.[0]?.text || '';
}
```

**3. Create error mapping function:**
```typescript
function mapHttpToErrorCode(status: number, body: any): AIErrorCode {
  if (status === 429) {
    const msg = (body?.error?.message || '').toLowerCase();
    if (msg.includes('quota') || msg.includes('billing') || msg.includes('insufficient')) {
      return 'QUOTA_EXCEEDED';
    }
    return 'RATE_LIMIT';
  }
  if (status === 401 || status === 403) return 'AUTH_ERROR';
  if (status >= 500 || status === 529) return 'SERVER_ERROR';
  return 'UNKNOWN_ERROR';
}
```

**4. Create JSON extraction helper:**
```typescript
function extractJSON<T>(text: string): T {
  // Claude sometimes wraps JSON in markdown code blocks
  const jsonMatch = text.match(/```(?:json)?\s*([\s\S]*?)```/) || [null, text];
  const jsonStr = jsonMatch[1]?.trim() || text.trim();

  try {
    return JSON.parse(jsonStr);
  } catch (e) {
    throw new AIProviderError(USER_ERROR_MESSAGES.PARSE_ERROR, 'PARSE_ERROR', e);
  }
}
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>callClaude helper function exists with proper CORS header and error mapping</done>
</task>

<task type="auto">
  <name>Task 2: Implement all 9 provider methods</name>
  <files>services/providers/claudeProvider.ts</files>
  <action>
Implement all methods in ClaudeProvider class. Each method has specific behavior:

**1. generateLessonSlides** (returns Slide[]):
- Adapt system prompt from geminiService (educator role, slide structure, speaker note rules)
- Add "Return your response as a valid JSON array. Do not include any text before or after the JSON."
- Handle pageImages by converting to ClaudeContentBlock with base64 (split off data URI prefix if present)
- Parse response with extractJSON<any[]>
- Map each item to Slide, adding `id: slide-${Date.now()}-${index}` and `isGeneratingImage: false`

**2. generateSlideImage** (returns string | undefined):
- Claude API does NOT support image generation
- Return `undefined` immediately (do not call API)
- App will show placeholder or skip image

**3. generateResourceImage** (returns string | undefined):
- Same as generateSlideImage - return `undefined` immediately
- No API call needed

**4. generateQuickQuestion** (returns string):
- Adapt prompt: slide title + content + difficulty level
- Request PLAIN TEXT response (not JSON)
- Return the response text directly (trimmed)
- If response empty, return "Could not generate question."

**5. reviseSlide** (returns Partial<Slide>):
- Send current slide as JSON string + edit instruction
- Request JSON response with only the changed fields
- Parse response with extractJSON
- Return the partial slide object (caller merges with original)

**6. generateContextualSlide** (returns Slide):
- System prompt includes: lesson topic, position context (after prevSlide.title, before nextSlide.title)
- User message: the instruction for what slide to create
- Request full slide JSON
- Parse and add `id: slide-ins-${Date.now()}` and `isGeneratingImage: false`

**7. generateExemplarSlide** (returns Slide):
- Adapt the "Worked Example" prompt from geminiService
- Include previous slide context (title + content) for continuity
- Enforce speaker notes format with emoji delimiter
- Parse and add `id: exemplar-${Date.now()}` and `isGeneratingImage: false`

**8. generateLessonResources** (returns LessonResource[]):
- Adapt resource generation prompt (identify printable resources from lesson)
- Send truncated lesson text + slide context (max 3000 chars each)
- Request JSON array of resources with: title, type, targetAudience, content, imagePrompt
- Parse and add `id: res-${Date.now()}-${index}` to each

**9. generateImpromptuQuiz** (returns QuizQuestion[]):
- Gather context from slides[0..currentIndex]
- Adapt quiz prompt: game show host, numQuestions questions, 4 options each
- Request JSON array with: question, options (4), correctAnswerIndex (0-3), explanation
- Parse and return directly (no id field needed)

**Implementation pattern for each JSON-returning method:**
```typescript
async methodName(...args): Promise<ReturnType> {
  const systemPrompt = `[adapted from geminiService]

  IMPORTANT: Return your response as valid JSON. Do not include any text before or after the JSON.`;

  const response = await callClaude(this.apiKey, [...], systemPrompt, tokenLimit);
  return extractJSON<ReturnType>(response);
}
```

**For generateQuickQuestion (plain text):**
```typescript
async generateQuickQuestion(...): Promise<string> {
  const systemPrompt = `[adapted - request plain text output]`;
  const response = await callClaude(this.apiKey, [...], systemPrompt, 256);
  return response.trim() || "Could not generate question.";
}
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>All 9 methods implemented with proper prompts, error handling, and response parsing</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Compile check**: `npx tsc --noEmit` passes
2. **Method count**: ClaudeProvider has all 9 methods matching interface
3. **CORS header**: grep confirms `anthropic-dangerous-direct-browser-access` is present
4. **Error handling**: All API calls wrapped with proper error mapping
5. **Image methods**: generateSlideImage and generateResourceImage return undefined (not throw)
</verification>

<success_criteria>
1. ClaudeProvider fully implements AIProviderInterface
2. All text generation methods (7 of 9) make real API calls to Anthropic
3. Image generation methods return undefined gracefully
4. Error responses properly mapped to AIProviderError codes
5. JSON responses extracted and normalized to match expected types
6. Browser CORS header included in all requests
7. TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-multi-provider-ai/02-02-SUMMARY.md`
</output>
