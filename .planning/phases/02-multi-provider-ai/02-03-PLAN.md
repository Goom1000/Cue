---
phase: 02-multi-provider-ai
plan: 03
type: execute
wave: 3
depends_on: ["02-02"]
files_modified:
  - services/geminiService.ts
  - services/providers/geminiProvider.ts
  - App.tsx
  - components/PresentationView.tsx
  - components/ResourceHub.tsx
  - components/SettingsModal.tsx
autonomous: false

must_haves:
  truths:
    - "App uses provider from settings, not hardcoded Gemini"
    - "Loading screen shows provider name (Generating with Gemini/Claude...)"
    - "Switching providers in settings works without losing presentation"
    - "User sees warning when changing provider about compatibility"
    - "API errors show user-friendly modal with dismiss button"
    - "Rate limit and quota errors include specific guidance"
  artifacts:
    - path: "App.tsx"
      provides: "Provider integration with settings"
      contains: "createAIProvider"
    - path: "services/geminiService.ts"
      provides: "Functions accepting apiKey parameter"
      contains: "apiKey: string"
  key_links:
    - from: "App.tsx"
      to: "hooks/useSettings.ts"
      via: "useSettings hook"
      pattern: "useSettings\\(\\)"
    - from: "App.tsx"
      to: "services/aiProvider.ts"
      via: "createAIProvider factory"
      pattern: "createAIProvider\\("
---

<objective>
Wire the provider system into the app, replacing hardcoded Gemini calls with settings-based provider selection.

Purpose: This is the integration phase that makes multi-provider support real. Users can now use their chosen provider, see which provider is working, and receive helpful error messages.

Output: App.tsx, PresentationView.tsx, and ResourceHub.tsx use provider from settings. Loading states show provider name. Errors display in modal. Provider switch shows compatibility warning.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-multi-provider-ai/02-CONTEXT.md
@.planning/phases/02-multi-provider-ai/02-01-SUMMARY.md
@.planning/phases/02-multi-provider-ai/02-02-SUMMARY.md

Key files:
@App.tsx (main integration point)
@components/PresentationView.tsx (quiz/question generation)
@components/ResourceHub.tsx (resource generation)
@components/SettingsModal.tsx (provider switch warning)
@services/geminiService.ts (refactor to accept apiKey)
@hooks/useSettings.ts (source of provider/apiKey)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor geminiService to accept apiKey parameter</name>
  <files>services/geminiService.ts</files>
  <action>
Modify all functions in geminiService.ts to accept apiKey as first parameter instead of using process.env.API_KEY.

**For each function:**

1. Add `apiKey: string` as first parameter
2. Remove `if (!process.env.API_KEY)` checks
3. Replace `process.env.API_KEY` with `apiKey` parameter
4. Keep all prompts and logic identical

**Example transformation:**
```typescript
// BEFORE
export const generateLessonSlides = async (rawText: string, pageImages: string[] = []): Promise<Slide[]> => {
  if (!process.env.API_KEY) {
    throw new Error("API Key is missing...");
  }
  const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });
  ...
}

// AFTER
export const generateLessonSlides = async (apiKey: string, rawText: string, pageImages: string[] = []): Promise<Slide[]> => {
  const ai = new GoogleGenAI({ apiKey });
  ...
}
```

Apply this pattern to all 9 exported functions:
- generateLessonSlides
- generateSlideImage
- generateResourceImage
- generateQuickQuestion
- reviseSlide
- generateContextualSlide
- generateExemplarSlide
- generateLessonResources
- generateImpromptuQuiz

Keep QuizQuestion interface export unchanged.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>All 9 functions accept apiKey as first parameter</done>
</task>

<task type="auto">
  <name>Task 2: Update GeminiProvider to pass apiKey</name>
  <files>services/providers/geminiProvider.ts</files>
  <action>
Update GeminiProvider to pass this.apiKey to all geminiService function calls.

**Example:**
```typescript
async generateLessonSlides(rawText: string, pageImages?: string[]): Promise<Slide[]> {
  try {
    return await geminiGenerateLessonSlides(this.apiKey, rawText, pageImages || []);
  } catch (e) {
    if (e instanceof AIProviderError) throw e;
    throw new AIProviderError(USER_ERROR_MESSAGES.UNKNOWN_ERROR, 'UNKNOWN_ERROR', e);
  }
}
```

Update all 9 method implementations to pass this.apiKey as first argument.
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>GeminiProvider passes apiKey to all geminiService functions</done>
</task>

<task type="auto">
  <name>Task 3: Wire provider into App.tsx with error modal</name>
  <files>App.tsx</files>
  <action>
**1. Update imports:**
```typescript
// Remove direct geminiService imports
// import { generateLessonSlides, ... } from './services/geminiService';

// Add provider imports
import { createAIProvider, AIProviderError, AIProviderInterface } from './services/aiProvider';
import { useSettings } from './hooks/useSettings';
```

**2. Add settings hook and provider creation:**
```typescript
function App() {
  const [settings] = useSettings();

  // Create provider instance (memoized to avoid recreation on every render)
  const provider = useMemo<AIProviderInterface | null>(() => {
    if (!settings.apiKey) return null;
    try {
      return createAIProvider({ provider: settings.provider, apiKey: settings.apiKey });
    } catch (e) {
      // OpenAI will throw here - show error
      if (e instanceof AIProviderError) {
        setError(e.userMessage);
      }
      return null;
    }
  }, [settings.provider, settings.apiKey]);
  ```

**3. Add error modal state:**
```typescript
const [errorModal, setErrorModal] = useState<{ title: string; message: string } | null>(null);
```

**4. Update handleGenerate to use provider:**
```typescript
const handleGenerate = async () => {
  if (!provider) {
    setErrorModal({
      title: 'API Key Required',
      message: 'Please configure your AI provider in Settings before generating slides.'
    });
    return;
  }

  setIsGenerating(true);
  setAppState(AppState.PROCESSING_TEXT);
  setError(null);

  try {
    const generatedSlides = await provider.generateLessonSlides(lessonText, pageImages);
    // ... rest of existing logic
  } catch (err) {
    if (err instanceof AIProviderError) {
      setErrorModal({ title: 'Generation Failed', message: err.userMessage });
    } else {
      setErrorModal({ title: 'Error', message: 'An unexpected error occurred.' });
    }
    setAppState(AppState.INPUT);
  } finally {
    setIsGenerating(false);
  }
};
```

**5. Update all AI function calls to use provider:**
- generateSlideImage -> provider.generateSlideImage
- reviseSlide -> provider.reviseSlide
- generateExemplarSlide -> provider.generateExemplarSlide

**6. Update loading state to show provider name:**
```typescript
// In PROCESSING_TEXT state
<p className="text-slate-500 mt-2">
  Generating with {settings.provider === 'gemini' ? 'Gemini' :
                   settings.provider === 'claude' ? 'Claude' : 'AI'}...
</p>
```

**7. Add error modal component (at end of return, before closing div):**
```typescript
{errorModal && (
  <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
    <div className="bg-white dark:bg-slate-800 rounded-2xl p-6 max-w-md mx-4 shadow-2xl">
      <h3 className="text-lg font-bold text-slate-800 dark:text-white mb-2">
        {errorModal.title}
      </h3>
      <p className="text-slate-600 dark:text-slate-300 mb-6">
        {errorModal.message}
      </p>
      <div className="flex gap-3 justify-end">
        <button
          onClick={() => { setErrorModal(null); setShowSettings(true); }}
          className="px-4 py-2 text-sm font-medium text-indigo-600 dark:text-amber-400 hover:underline"
        >
          Open Settings
        </button>
        <button
          onClick={() => setErrorModal(null)}
          className="px-4 py-2 bg-indigo-600 dark:bg-amber-500 text-white dark:text-slate-900 rounded-lg font-medium hover:opacity-90"
        >
          OK
        </button>
      </div>
    </div>
  </div>
)}
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`. App starts: `npm run dev`</verify>
  <done>App.tsx uses provider from settings, shows provider name in loading, displays error modal</done>
</task>

<task type="auto">
  <name>Task 4: Wire provider into PresentationView and ResourceHub with error callbacks</name>
  <files>components/PresentationView.tsx, components/ResourceHub.tsx</files>
  <action>
These components need access to the provider AND must propagate errors to App.tsx which owns the error modal.

**Error propagation pattern:** Pass `onError: (err: AIProviderError) => void` callback from App.tsx. Children call onError when API fails, App.tsx displays in error modal.

**Update PresentationView.tsx:**

1. Add props for provider and error callback:
```typescript
interface PresentationViewProps {
  slides: Slide[];
  onExit: () => void;
  studentNames: string[];
  initialSlideIndex: number;
  provider: AIProviderInterface | null;
  onError: (title: string, message: string) => void;
}
```

2. Update function calls with error handling:
```typescript
// generateQuickQuestion
const handleGenerateQuestion = async () => {
  if (!provider) {
    onError('AI Not Configured', 'Please configure your AI provider in Settings.');
    return;
  }
  try {
    const q = await provider.generateQuickQuestion(currentSlide.title, currentSlide.content, level);
    setQuestion(q);
  } catch (err) {
    if (err instanceof AIProviderError) {
      onError('Question Generation Failed', err.userMessage);
    } else {
      onError('Error', 'Could not generate question. Please try again.');
    }
  }
};

// generateImpromptuQuiz - same pattern
const handleStartQuiz = async () => {
  if (!provider) {
    onError('AI Not Configured', 'Please configure your AI provider in Settings.');
    return;
  }
  try {
    const data = await provider.generateImpromptuQuiz(slides, currentIndex, numQuestions);
    setQuizData(data);
  } catch (err) {
    if (err instanceof AIProviderError) {
      onError('Quiz Generation Failed', err.userMessage);
    } else {
      onError('Error', 'Could not generate quiz. Please try again.');
    }
  }
};
```

3. Import AIProviderError at top of file.

**Update ResourceHub.tsx:**

1. Add props:
```typescript
interface ResourceHubProps {
  lessonText: string;
  slideContext: string;
  onClose: () => void;
  provider: AIProviderInterface | null;
  onError: (title: string, message: string) => void;
}
```

2. Update generateLessonResources call:
```typescript
const handleGenerate = async () => {
  if (!provider) {
    onError('AI Not Configured', 'Please configure your AI provider in Settings.');
    return;
  }
  setIsLoading(true);
  try {
    const result = await provider.generateLessonResources(lessonText, slideContext);
    setResources(result);
  } catch (err) {
    if (err instanceof AIProviderError) {
      onError('Resource Generation Failed', err.userMessage);
    } else {
      onError('Error', 'Could not generate resources. Please try again.');
    }
  } finally {
    setIsLoading(false);
  }
};
```

3. Import AIProviderError at top of file.

**Update App.tsx to pass props:**
```typescript
// Create error handler function
const handleComponentError = (title: string, message: string) => {
  setErrorModal({ title, message });
};

<PresentationView
  slides={slides}
  onExit={() => setAppState(AppState.EDITING)}
  studentNames={studentNames}
  initialSlideIndex={presentationStartIndex}
  provider={provider}
  onError={handleComponentError}
/>

<ResourceHub
  lessonText={lessonText}
  slideContext={JSON.stringify(slides)}
  onClose={() => setShowResourceHub(false)}
  provider={provider}
  onError={handleComponentError}
/>
```
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>PresentationView and ResourceHub use provider prop for AI calls and propagate errors to App.tsx</done>
</task>

<task type="auto">
  <name>Task 5: Add provider-switch compatibility warning in SettingsModal</name>
  <files>components/SettingsModal.tsx</files>
  <action>
When user changes the provider dropdown, show a warning about compatibility before the change takes effect.

**1. Add state for pending provider change:**
```typescript
const [pendingProvider, setPendingProvider] = useState<AIProvider | null>(null);
```

**2. Intercept provider dropdown change:**
```typescript
// Instead of directly calling setSettings when provider changes:
const handleProviderChange = (newProvider: AIProvider) => {
  if (newProvider !== settings.provider && settings.apiKey) {
    // User has existing key - show warning
    setPendingProvider(newProvider);
  } else {
    // No existing key or same provider - just change
    setSettings({ ...settings, provider: newProvider, apiKey: '' });
  }
};
```

**3. Add warning modal (inside SettingsModal, after main content):**
```typescript
{pendingProvider && (
  <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-[60]">
    <div className="bg-white dark:bg-slate-800 rounded-2xl p-6 max-w-md mx-4 shadow-2xl">
      <h3 className="text-lg font-bold text-slate-800 dark:text-white mb-2">
        Switch to {pendingProvider === 'gemini' ? 'Gemini' :
                   pendingProvider === 'claude' ? 'Claude' : 'OpenAI'}?
      </h3>
      <p className="text-slate-600 dark:text-slate-300 mb-4">
        Switching providers will clear your current API key. You'll need to enter a new key for {pendingProvider === 'gemini' ? 'Google' :
                   pendingProvider === 'claude' ? 'Anthropic' : 'OpenAI'}.
      </p>
      <p className="text-sm text-amber-600 dark:text-amber-400 mb-6">
        Note: Different AI providers may generate slightly different content for the same lesson.
      </p>
      <div className="flex gap-3 justify-end">
        <button
          onClick={() => setPendingProvider(null)}
          className="px-4 py-2 text-sm font-medium text-slate-600 dark:text-slate-300 hover:underline"
        >
          Cancel
        </button>
        <button
          onClick={() => {
            setSettings({ ...settings, provider: pendingProvider, apiKey: '' });
            setPendingProvider(null);
          }}
          className="px-4 py-2 bg-indigo-600 dark:bg-amber-500 text-white dark:text-slate-900 rounded-lg font-medium hover:opacity-90"
        >
          Switch Provider
        </button>
      </div>
    </div>
  </div>
)}
```

**4. Update the provider select/dropdown to use handleProviderChange instead of direct setSettings.**

This satisfies CONTEXT.md requirement: "Show compatibility warning when user changes provider"
  </action>
  <verify>TypeScript compiles: `npx tsc --noEmit`</verify>
  <done>SettingsModal shows warning when user switches providers</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete multi-provider integration:
- Provider selection from settings
- Loading state shows provider name
- Error modal with user-friendly messages
- Provider-switch compatibility warning
- All AI features work with selected provider
  </what-built>
  <how-to-verify>
1. **Gemini flow:**
   - Set Gemini as provider in Settings with valid API key
   - Upload a PDF or paste lesson text
   - Click "Generate Slideshow"
   - Verify loading says "Generating with Gemini..."
   - Verify slides generate successfully

2. **Claude flow:**
   - Switch to Claude in Settings with valid API key
   - Verify warning modal appears about switching providers
   - Confirm the switch
   - Generate slides again
   - Verify loading says "Generating with Claude..."
   - Verify slides generate (content may differ slightly)

3. **Error handling:**
   - Use invalid API key
   - Try to generate
   - Verify error modal appears with friendly message
   - Verify "Open Settings" button works

4. **OpenAI rejection:**
   - Try to select OpenAI
   - Verify appropriate error message about browser support

5. **Provider switching:**
   - Generate slides with one provider
   - Switch to different provider in Settings
   - Verify warning modal appears
   - Confirm switch
   - Verify slides are NOT lost
   - Generate new slides (appends or replaces per existing behavior)

6. **Quiz/Questions:**
   - Enter presentation mode
   - Test quick question generation
   - Test impromptu quiz
   - Verify both work with selected provider
  </how-to-verify>
  <resume-signal>Type "approved" if all tests pass, or describe issues found</resume-signal>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Compile check**: `npx tsc --noEmit` passes
2. **Runtime check**: `npm run dev` starts without errors
3. **Settings integration**: Provider and apiKey from useSettings used throughout
4. **Loading state**: Shows correct provider name
5. **Error handling**: AIProviderError displays in modal with user-friendly message
6. **Provider warning**: Changing provider shows compatibility warning
7. **No regressions**: Existing Gemini functionality works as before
</verification>

<success_criteria>
1. User can generate slides using Gemini or Claude (whichever configured)
2. User selecting OpenAI sees clear error about browser CORS limitations
3. User can switch providers without losing current presentation
4. User sees compatibility warning when switching providers
5. API errors display user-friendly messages
6. Rate limit and quota errors include specific guidance
7. Loading screen shows provider name
8. All AI features work (slides, images, quiz, questions, resources)
9. TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-multi-provider-ai/02-03-SUMMARY.md`
</output>
