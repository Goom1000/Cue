---
phase: 70-slide-mapper-pipeline-integration
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - services/scriptedParser/scriptedMapper.ts
  - services/scriptedParser/scriptedMapper.test.ts
autonomous: true
requirements: [MAP-01, MAP-02, MAP-03, MAP-04, MAP-05]

must_haves:
  truths:
    - "Say: blocks appear verbatim in speakerNotes segments, not in content[]"
    - "Write on board: and Ask: blocks appear as plain-text content[] bullets with no labels or prefixes"
    - "Ask: blocks set hasQuestionFlag: true on the slide"
    - "Substantial Activity: blocks produce work-together typed slides with step-by-step content[] bullets"
    - "Short single-line Activity: blocks are absorbed as regular content bullets on the current slide"
    - "Every slide has exactly (content.length + 1) pointing-right-delimited segments in speakerNotes"
    - "Section headings always create new slide boundaries with lessonPhase assigned"
    - "Consecutive Say/Write blocks group together on the same slide"
    - "Empty speakerNotes segments are acceptable when no Say: block precedes a content bullet"
    - "Multiple consecutive Say: blocks before a content bullet merge with paragraph breaks preserved"
  artifacts:
    - path: "services/scriptedParser/scriptedMapper.ts"
      provides: "mapBlocksToSlides() pure function"
      exports: ["mapBlocksToSlides"]
    - path: "services/scriptedParser/scriptedMapper.test.ts"
      provides: "Comprehensive mapper test suite"
      min_lines: 300
  key_links:
    - from: "services/scriptedParser/scriptedMapper.ts"
      to: "services/scriptedParser/types.ts"
      via: "imports ScriptedBlock, SectionLabel types"
      pattern: "import.*ScriptedBlock.*from.*types"
    - from: "services/scriptedParser/scriptedMapper.ts"
      to: "types.ts"
      via: "imports Slide, LessonPhase types"
      pattern: "import.*Slide.*LessonPhase.*from.*types"
---

<objective>
Build the pure-function slide mapper that converts ScriptedBlock[] (from Phase 69's parser) into valid Cue Slide[] objects with correct field mapping, segment count invariant enforcement, and slide boundary grouping.

Purpose: This is the core data transformation of scripted import -- it turns a teacher's annotated lesson plan into presentation slides with teleprompter scripts that match the "say this, then show that" progressive disclosure pattern.

Output: `mapBlocksToSlides()` function with comprehensive tests covering all MAP requirements.
</objective>

<execution_context>
@/Users/ricky/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ricky/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/70-slide-mapper-pipeline-integration/70-CONTEXT.md
@.planning/phases/70-slide-mapper-pipeline-integration/70-RESEARCH.md
@.planning/phases/69-scripted-parser/69-01-SUMMARY.md
@services/scriptedParser/types.ts
@services/scriptedParser/scriptedParser.ts
@types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1 RED: Write failing tests for mapBlocksToSlides</name>
  <files>services/scriptedParser/scriptedMapper.test.ts</files>
  <action>
Create the test file with comprehensive test cases for the mapper. Import `ScriptedBlock`, `SectionLabel` from `./types` and `Slide`, `LessonPhase` from `../../types`. Create a stub `mapBlocksToSlides` import from `./scriptedMapper`.

Use the segment delimiter constant: `const SEGMENT_DELIMITER = '\u{1F449}'` (pointing right emoji).

Helper: create a `makeBlock` factory function that produces `ScriptedBlock` objects with sensible defaults (lineNumber: 1, section: null, implicit: false) so tests are concise.

Write tests grouped by requirement:

**MAP-01: Field Mapping**
- Say: block content appears in speakerNotes, not in content[]
- Write on board: block content appears as a plain-text content[] bullet (no "Board:" prefix)
- Ask: block content appears as a plain-text content[] bullet (no "Q:" prefix)
- Ask: block sets hasQuestionFlag: true on the slide
- Activity: block (substantial, multi-line) produces a work-together typed slide with instructions as content[] bullets
- Short single-line Activity: block is absorbed as a content bullet on the current slide (no separate slide)
- Implicit Say: blocks (implicit: true) are treated identically to explicit Say: blocks

**MAP-02: Segment Count Invariant**
- Slide with 0 content bullets has exactly 1 speakerNotes segment (intro only)
- Slide with 3 content bullets has exactly 4 speakerNotes segments
- When fewer Say: blocks than content+1 slots, trailing segments are empty strings
- When more Say: blocks than content+1 slots, excess are merged into the last segment with `\n\n` separator
- Empty segments are valid (no Say: block before a content bullet = empty segment at that position)
- Trailing Say: blocks after the last content bullet fill the final segment
- Multiple consecutive Say: blocks before a single content bullet merge into one segment with `\n\n`

**MAP-03: Slide Boundaries**
- Section heading creates a new slide boundary (blocks before and after heading go to different slides)
- Consecutive Say: and Write on board: blocks group onto the same slide (no boundary between them)
- Ask: block on a slide with existing content triggers a flush after itself (next block starts new slide)
- Ask: block as the first block on a slide stays on that slide without triggering boundary
- Consecutive section headings with no content between them collapse into one slide (no empty slide)
- End-to-end: a realistic lesson plan fixture with 6-8 blocks produces a reasonable slide count (3-5 slides)

**MAP-04: LessonPhase Assignment**
- Section heading "Hook" sets lessonPhase: 'hook' on its slide
- Section heading "I Do" sets lessonPhase: 'i-do'
- Section heading "We Do" sets lessonPhase: 'we-do'
- Section heading "You Do" sets lessonPhase: 'you-do'
- Section heading "Plenary" sets lessonPhase: 'plenary'
- Slides after a section heading inherit the lessonPhase until the next heading
- Slides before any section heading have lessonPhase: undefined

**MAP-05: Work-Together Slides**
- Substantial Activity: block (multi-line with \n) creates a slide with slideType: 'work-together'
- Work-together slide also has layout: 'work-together'
- Activity instructions are split on \n into content[] bullets
- Full activity text goes into speakerNotes for the teleprompter
- Short single-line Activity: is NOT work-together (absorbed as content bullet)

**Slide Construction**
- Each slide has an id matching pattern `scripted-{timestamp}-{index}`
- Slides with no explicit title from a section heading inherit the current section title
- Slides with no section context at all get a title derived from first content bullet (truncated to 60 chars) or 'Untitled'
- imagePrompt is '' (empty) on all slides (Phase 71 handles this)
- layout defaults to 'split' for non-work-together slides

Run: `npx jest services/scriptedParser/scriptedMapper.test.ts` -- all tests MUST FAIL (module not found or function not implemented). Do NOT create the implementation file yet.
  </action>
  <verify>Run `npx jest services/scriptedParser/scriptedMapper.test.ts 2>&1 | tail -20` -- expect all tests to fail (FAIL status). Count the number of test cases. Minimum 25 tests.</verify>
  <done>Test file exists with 25+ failing tests covering all 5 MAP requirements. Zero tests passing.</done>
</task>

<task type="auto">
  <name>Task 2 GREEN: Implement mapBlocksToSlides</name>
  <files>services/scriptedParser/scriptedMapper.ts</files>
  <action>
Create the mapper module at `services/scriptedParser/scriptedMapper.ts`.

**Imports:**
- `ScriptedBlock, SectionLabel` from `./types`
- `Slide, LessonPhase` from `../../types`

**Constants:**
```typescript
const SEGMENT_DELIMITER = '\u{1F449}'; // Pointing right emoji -- teleprompter splits on this
```

**Internal types:**
```typescript
interface PartialSlide {
  title: string;
  contentBullets: string[];
  saySegments: string[];   // Say: block contents collected in order
  hasQuestion: boolean;
  lessonPhase: LessonPhase | undefined;
  isWorkTogether: boolean;
}
```

**Section-to-phase mapping (MAP-04):**
```typescript
const SECTION_TO_PHASE: Record<SectionLabel, LessonPhase> = {
  'Hook': 'hook',
  'I Do': 'i-do',
  'We Do': 'we-do',
  'You Do': 'you-do',
  'Plenary': 'plenary',
};
```

**Core function: `mapBlocksToSlides(blocks: ScriptedBlock[]): Slide[]`**

Use a sequential accumulator pattern (mirroring the parser's state machine):

State: `currentSlide: PartialSlide`, `slides: Slide[]`, `currentPhase: LessonPhase | undefined`, `currentSectionTitle: string | null`.

Walk each block:

1. **section-heading**: Flush current slide (if non-empty). Set `currentSectionTitle = block.content`. Set `currentPhase = SECTION_TO_PHASE[block.content as SectionLabel]`. Initialize new partial slide with title and phase.

2. **say** (or implicit say): Append `block.content` to `currentSlide.saySegments`.

3. **write-on-board**: Append `block.content` to `currentSlide.contentBullets`.

4. **ask**: Append `block.content` to `currentSlide.contentBullets`. Set `currentSlide.hasQuestion = true`. After adding the ask block, check if there are more blocks after this one in the array -- if yes, flush the current slide (the question ends the current teaching sequence). The ask block stays on the CURRENT slide before flush.

5. **activity**: Check `isSubstantialActivity(block.content)` (contains `\n`). If substantial: flush current slide, create a new work-together slide with activity instructions split on `\n` as content[], full text as speakerNotes, `slideType: 'work-together'`, `layout: 'work-together'`. Then flush immediately. If short: absorb as a content bullet on the current slide.

**Flush logic (`flushSlide`):**
- Skip if current slide has zero content bullets AND zero say segments (empty slide from consecutive headings)
- Call `buildSpeakerNotes(saySegments, contentBullets.length)` to construct segment-aligned speakerNotes
- Construct full `Slide` object with `id: \`scripted-${Date.now()}-${slides.length}\``
- If no title and no section context, derive title from first content bullet (truncated to 60 chars) or 'Untitled'
- Push to slides array
- Reset currentSlide to empty partial

**Segment count enforcement (`buildSpeakerNotes`):**
Per CONTEXT.md decisions and TELEPROMPTER_RULES:
- Required segments = contentCount + 1
- If saySegments.length === 0: all empty segments
- If saySegments.length <= requiredCount: place each in order, pad remaining with ''
- If saySegments.length > requiredCount: first (requiredCount - 1) segments map 1:1, excess merge into last segment with `\n\n`
- Join with SEGMENT_DELIMITER
- Post-assertion: verify split count equals contentCount + 1

**Short vs substantial activity heuristic (Claude's discretion, MAP-05):**
`isSubstantialActivity(content: string): boolean` returns `content.includes('\n')` -- multi-line activities are substantial, single-line are short.

**Continuation slide titling (Claude's discretion):**
When a slide is created by an ask-boundary flush, the new slide inherits the current section title. If the same section has multiple slides, later ones get " (cont.)" appended.

Export only `mapBlocksToSlides`.
  </action>
  <verify>Run `npx jest services/scriptedParser/scriptedMapper.test.ts` -- ALL tests MUST PASS. Run `npx tsc --noEmit` -- zero type errors.</verify>
  <done>mapBlocksToSlides() is implemented. All 25+ tests pass. Zero TypeScript errors. The segment count invariant holds for every test case.</done>
</task>

</tasks>

<verification>
1. `npx jest services/scriptedParser/scriptedMapper.test.ts` -- all tests pass
2. `npx tsc --noEmit` -- zero type errors
3. Spot-check: construct a ScriptedBlock[] with 2 Say + 1 Write + 1 Ask + 1 Activity (multi-line) and verify the output has correct slide count, segment counts, and field mapping
4. Verify the segment count invariant: for every output slide, `slide.speakerNotes.split('\u{1F449}').length === slide.content.length + 1`
</verification>

<success_criteria>
- mapBlocksToSlides() converts ScriptedBlock[] to Slide[] with all MAP requirements satisfied
- Segment count invariant holds for every slide in every test case
- Work-together slides have both slideType and layout set to 'work-together'
- Section headings create boundaries and assign lessonPhase
- Consecutive Say/Write blocks group onto the same slide
- Short activities are absorbed, substantial activities get their own slide
- All tests pass, zero type errors
</success_criteria>

<output>
After completion, create `.planning/phases/70-slide-mapper-pipeline-integration/70-01-SUMMARY.md`
</output>
