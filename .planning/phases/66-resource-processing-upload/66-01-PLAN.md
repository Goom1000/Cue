---
phase: 66-resource-processing-upload
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - types.ts
  - services/documentProcessors/pptxProcessor.ts
  - services/uploadService.ts
  - utils/resourceCapping.ts
autonomous: true

must_haves:
  truths:
    - "PPTX files are parsed for text using JSZip + DOMParser with no new npm dependencies"
    - "Upload service accepts PPTX files and routes them to the PPTX processor"
    - "Content capping utility truncates per-resource at 2,000 chars and total at 6,000 chars"
  artifacts:
    - path: "services/documentProcessors/pptxProcessor.ts"
      provides: "PPTX text extraction via JSZip + DOMParser"
      exports: ["processPptx", "PptxProcessResult"]
    - path: "utils/resourceCapping.ts"
      provides: "Content capping utility for generation prompts"
      exports: ["capResourceContent", "PER_RESOURCE_CAP", "TOTAL_RESOURCE_CAP"]
  key_links:
    - from: "services/uploadService.ts"
      to: "services/documentProcessors/pptxProcessor.ts"
      via: "case 'pptx' in processUploadedFile switch"
      pattern: "case 'pptx'"
    - from: "types.ts"
      to: "services/uploadService.ts"
      via: "UploadedResourceType union includes 'pptx'"
      pattern: "'pptx'"
---

<objective>
Build PPTX document processor and extend upload service to accept PowerPoint files, plus create the content-capping utility for generation prompt safety.

Purpose: Teachers need to upload PPTX files as supplementary resources. The processor extracts text from slide XML using JSZip (already installed) and DOMParser (browser API). The content cap prevents token overflow when resources are injected into generation prompts.

Output: Working PPTX processor following existing docxProcessor pattern, extended upload service with PPTX routing, content-capping utility, and updated UploadedResourceType union.
</objective>

<execution_context>
@/Users/ricky/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ricky/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/66-resource-processing-upload/66-RESEARCH.md

# Key reference files
@services/documentProcessors/docxProcessor.ts  — Pattern to follow for pptxProcessor
@services/uploadService.ts  — Router to extend with PPTX case
@types.ts  — UploadedResourceType union to extend
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PPTX processor and extend upload service types</name>
  <files>
    types.ts
    services/documentProcessors/pptxProcessor.ts
    services/uploadService.ts
  </files>
  <action>
1. In `types.ts`, add `'pptx'` to the `UploadedResourceType` union:
   - Change `export type UploadedResourceType = 'pdf' | 'image' | 'docx';` to `export type UploadedResourceType = 'pdf' | 'image' | 'docx' | 'pptx';`

2. Create `services/documentProcessors/pptxProcessor.ts` following the exact pattern of `docxProcessor.ts`:
   - Export `PptxProcessResult` interface: `{ thumbnail: string; pageCount: number; type: 'pptx'; text: string; }`
   - Create a PPTX_ICON constant as inline SVG data URL (similar to DOCX_ICON but with "PPTX" label and orange/red color #D24726 for PowerPoint branding)
   - Export `async function processPptx(file: File): Promise<PptxProcessResult>`
   - Implementation:
     a. Read file as ArrayBuffer via `file.arrayBuffer()`
     b. Load with JSZip: `const zip = await JSZip.loadAsync(arrayBuffer)`
     c. Find slide files: filter `Object.keys(zip.files)` matching `/^ppt\/slides\/slide\d+\.xml$/`, sort numerically by slide number
     d. For each slide file, read as string, parse with `new DOMParser().parseFromString(xml, 'application/xml')`
     e. Extract text using `getElementsByTagNameNS('http://schemas.openxmlformats.org/drawingml/2006/main', 'p')` to get paragraphs, then for each paragraph get child `t` elements in the same namespace, join their textContent
     f. Group non-empty paragraphs per slide with `[Slide N]` headers
     g. Join all slide texts with double newlines
     h. Return `{ thumbnail: PPTX_ICON, pageCount: slideFiles.length, type: 'pptx', text: allText }`
   - IMPORTANT: Use `getElementsByTagNameNS` with full namespace URI `http://schemas.openxmlformats.org/drawingml/2006/main`, NOT `getElementsByTagName('a:t')` -- the prefix-based approach fails with DOMParser's namespace awareness
   - Do NOT extract images from ppt/media/ -- text-only extraction for supplementary resources (images would bloat save files per Pitfall 2 in research)

3. In `services/uploadService.ts`:
   - Add import: `import { processPptx } from './documentProcessors/pptxProcessor';`
   - Extend `ACCEPTED_TYPES` with: `'application/vnd.openxmlformats-officedocument.presentationml.presentation': 'pptx'`
   - Extend `EXTENSION_MAP` with: `'.pptx': 'pptx'`
   - Update `getFileType` return type from `'pdf' | 'image' | 'docx' | null` to `'pdf' | 'image' | 'docx' | 'pptx' | null`
   - Add `case 'pptx': result = await processPptx(file); break;` to the switch in `processUploadedFile`
   - Update the `result` type annotation to include `type: 'pdf' | 'image' | 'docx' | 'pptx'`
   - Add PPTX content handling after the existing content blocks: `else if (result.type === 'pptx' && 'text' in result) { resource.content = { text: result.text }; }`
   - Update `getAcceptedExtensions` to return `'.pdf,.png,.jpg,.jpeg,.docx,.pptx'`
  </action>
  <verify>
    - TypeScript compiles without errors: `npx tsc --noEmit`
    - The pptxProcessor.ts file exports processPptx and PptxProcessResult
    - uploadService.ts has the pptx case in both ACCEPTED_TYPES and the switch statement
    - getAcceptedExtensions() returns string including '.pptx'
  </verify>
  <done>
    - UploadedResourceType includes 'pptx'
    - PPTX files can be processed through uploadService -> pptxProcessor pipeline
    - Extracted text is structured with [Slide N] headers per slide
    - PPTX processor uses JSZip (existing dependency) + DOMParser (browser API) only
  </done>
</task>

<task type="auto">
  <name>Task 2: Create content-capping utility for resource text</name>
  <files>
    utils/resourceCapping.ts
  </files>
  <action>
Create `utils/resourceCapping.ts` with:

1. Export constants:
   - `export const PER_RESOURCE_CAP = 2000;` (chars per resource)
   - `export const TOTAL_RESOURCE_CAP = 6000;` (chars across all resources)
   - `export const MAX_SUPPLEMENTARY_RESOURCES = 5;` (file count limit)

2. Export function `capResourceContent`:
```typescript
export function capResourceContent(
  resources: Array<{ id: string; content?: { text?: string } }>
): Map<string, string> {
  const capped = new Map<string, string>();
  let totalUsed = 0;

  for (const resource of resources) {
    const text = resource.content?.text;
    if (!text) continue;

    const remaining = TOTAL_RESOURCE_CAP - totalUsed;
    if (remaining <= 0) break;

    const perCap = Math.min(PER_RESOURCE_CAP, remaining);
    const truncated = text.substring(0, perCap);
    capped.set(resource.id, truncated);
    totalUsed += truncated.length;
  }

  return capped;
}
```

Key design decisions:
- Takes resources with optional content (matching UploadedResource shape) so it works generically
- Returns a Map<id, cappedText> so callers can look up capped content per resource
- Applies per-resource cap first, then respects total budget across all resources
- Processes resources in array order (first resources get priority)
- Skips resources without text content (images, etc.)
- This is a VIEW function -- it does NOT modify stored resources. Full content stays intact for Phase 68 ResourceHub compatibility. Capping is applied only when building generation prompts.
  </action>
  <verify>
    - TypeScript compiles without errors: `npx tsc --noEmit`
    - File exports PER_RESOURCE_CAP, TOTAL_RESOURCE_CAP, MAX_SUPPLEMENTARY_RESOURCES, capResourceContent
  </verify>
  <done>
    - Content capping utility exists at utils/resourceCapping.ts
    - Per-resource cap is 2,000 characters
    - Total cap across all resources is 6,000 characters
    - Max supplementary resources is 5 files
    - Function is a pure view function that doesn't mutate stored data
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `services/documentProcessors/pptxProcessor.ts` exists and exports `processPptx`
3. `services/uploadService.ts` accepts `.pptx` files and routes to `processPptx`
4. `utils/resourceCapping.ts` exports `capResourceContent` with correct cap constants
5. No new npm dependencies added (verify `package.json` unchanged)
</verification>

<success_criteria>
- PPTX files are processable through the upload pipeline (text extraction only, no images)
- Content capping utility ready for generation prompt construction (Phase 67/68)
- UploadedResourceType union includes 'pptx' throughout the codebase
- Zero new npm dependencies
</success_criteria>

<output>
After completion, create `.planning/phases/66-resource-processing-upload/66-01-SUMMARY.md`
</output>
