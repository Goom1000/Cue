---
phase: 59-gap-analysis
plan: 03
type: execute
wave: 3
depends_on: ["59-01", "59-02"]
files_modified:
  - App.tsx
autonomous: true

must_haves:
  truths:
    - "Check for Gaps button appears in editor top bar when deck has 1+ slides and provider is configured"
    - "Clicking Check for Gaps opens a PDF file picker for the lesson plan"
    - "After PDF upload, AI analyzes deck vs lesson plan and the GapAnalysisPanel opens on the right"
    - "Teacher sees coverage percentage, severity badges, and suggested content for each gap"
    - "Clicking Add Slide on a gap inserts a temp placeholder at the suggested position, then AI replaces it with a full slide"
    - "After adding a slide from a gap, remaining gap positions are adjusted for index drift"
    - "Filled gaps disappear from the panel after slide generation completes"
    - "Re-analyze button re-runs the full AI comparison with current deck state"
    - "Gap panel closes when user clicks Close button"
  artifacts:
    - path: "App.tsx"
      provides: "Gap analysis button, PDF upload handler, gap state management, slide generation from gaps, panel wiring"
      contains: "handleGapPdfUpload"
  key_links:
    - from: "App.tsx"
      to: "components/GapAnalysisPanel.tsx"
      via: "renders GapAnalysisPanel when gapResult is non-null"
      pattern: "GapAnalysisPanel"
    - from: "App.tsx"
      to: "services/aiProvider.ts"
      via: "calls provider.analyzeGaps and provider.generateSlideFromGap"
      pattern: "provider.*analyzeGaps|provider.*generateSlideFromGap"
    - from: "App.tsx"
      to: "processPdf"
      via: "reuses inline processPdf for PDF text + image extraction"
      pattern: "processPdf.*gapPdf"
---

<objective>
Wire gap analysis into App.tsx: button, PDF upload, AI call, panel rendering, and slide generation from gaps.

Purpose: This is the final plan that delivers all 6 GAP requirements (GAP-01 through GAP-06) to the user. It connects the AI infrastructure (Plan 01/02) and the panel UI (Plan 02) into the working application.

Output: Complete gap analysis workflow — from button click to PDF upload to gap display to one-click slide generation.
</objective>

<execution_context>
@/Users/ricky/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ricky/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/59-gap-analysis/59-RESEARCH.md
@.planning/phases/59-gap-analysis/59-01-SUMMARY.md
@.planning/phases/59-gap-analysis/59-02-SUMMARY.md
@App.tsx
@services/aiProvider.ts
@components/GapAnalysisPanel.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add gap analysis state, button, PDF upload, and analysis handler</name>
  <files>App.tsx</files>
  <action>
**1. Add imports** at top of App.tsx:

Add `GapAnalysisResult, IdentifiedGap` to the existing import from `./services/aiProvider`:
```typescript
import { createAIProvider, AIProviderError, AIProviderInterface, GenerationInput, GenerationMode, AIErrorCode, VerbosityLevel, CohesionResult, GapAnalysisResult, IdentifiedGap, withRetry } from './services/aiProvider';
```

Add new component import after the CohesionPreview import:
```typescript
import GapAnalysisPanel from './components/GapAnalysisPanel';
```

**2. Add state variables** after the cohesion state block (after line ~335):

```typescript
// Gap Analysis state (Phase 59)
const [isAnalyzingGaps, setIsAnalyzingGaps] = useState(false);
const [gapResult, setGapResult] = useState<GapAnalysisResult | null>(null);
const [generatingGapId, setGeneratingGapId] = useState<string | null>(null);
const [gapLessonPlanText, setGapLessonPlanText] = useState<string>('');
const [gapLessonPlanImages, setGapLessonPlanImages] = useState<string[]>([]);
const gapFileInputRef = useRef<HTMLInputElement>(null);
```

**3. Add hidden file input** in the JSX. Place it right before or after the existing hidden file inputs (near the top of the JSX return). Add:

```jsx
{/* Hidden file input for gap analysis PDF upload (Phase 59) */}
<input
  type="file"
  ref={gapFileInputRef}
  onChange={handleGapPdfUpload}
  className="hidden"
  accept=".pdf"
/>
```

**4. Add handleGapPdfUpload handler** after the cohesion handlers block (~line 731):

```typescript
// Gap Analysis handlers (Phase 59)
const handleGapPdfUpload = useCallback(async (e: React.ChangeEvent<HTMLInputElement>) => {
  const file = e.target.files?.[0];
  if (!file || !provider) return;

  // Reset file input so the same file can be re-uploaded
  e.target.value = '';

  if (file.type !== 'application/pdf') {
    addToast('Please upload a PDF lesson plan.', 3000, 'error');
    return;
  }

  setIsAnalyzingGaps(true);
  addToast('Processing lesson plan PDF...', 2000, 'info');

  try {
    // Extract text and images from PDF using existing processPdf
    const pdfResult = await new Promise<{ text: string; images: string[] }>((resolve, reject) => {
      processPdf(
        file,
        () => {}, // Progress callback (we manage our own state)
        (text, images) => resolve({ text, images }),
        (errorMsg) => reject(new Error(errorMsg))
      );
    });

    // Store lesson plan data for re-analysis
    setGapLessonPlanText(pdfResult.text);
    setGapLessonPlanImages(pdfResult.images);

    // Strip data URL prefix from images for AI (they need raw base64)
    const rawImages = pdfResult.images.map(img =>
      img.replace(/^data:image\/[a-z]+;base64,/, '')
    );

    addToast('Analyzing gaps against your deck...', 3000, 'info');

    const result = await withRetry<GapAnalysisResult>(() =>
      provider!.analyzeGaps(slides, pdfResult.text, rawImages, 'Year 6 (10-11 years old)')
    );

    if (result.gaps.length === 0) {
      addToast(`Great coverage! Your deck covers ~${result.coveragePercentage}% of the lesson plan.`, 4000, 'success');
    }

    setGapResult(result);
  } catch (error: any) {
    const message = error?.userMessage || error?.message || 'Failed to analyze gaps';
    addToast(message, 5000, 'error');
  } finally {
    setIsAnalyzingGaps(false);
  }
}, [provider, slides, addToast]);
```

**5. Add handleReanalyzeGaps handler** right after handleGapPdfUpload:

```typescript
const handleReanalyzeGaps = useCallback(async () => {
  if (!provider || !gapLessonPlanText) return;

  setIsAnalyzingGaps(true);
  addToast('Re-analyzing gaps...', 2000, 'info');

  try {
    const rawImages = gapLessonPlanImages.map(img =>
      img.replace(/^data:image\/[a-z]+;base64,/, '')
    );

    const result = await withRetry<GapAnalysisResult>(() =>
      provider!.analyzeGaps(slides, gapLessonPlanText, rawImages, 'Year 6 (10-11 years old)')
    );

    setGapResult(result);
    addToast(`Re-analysis complete: ${result.gaps.length} gap${result.gaps.length === 1 ? '' : 's'} found`, 3000, 'success');
  } catch (error: any) {
    const message = error?.userMessage || error?.message || 'Failed to re-analyze gaps';
    addToast(message, 5000, 'error');
  } finally {
    setIsAnalyzingGaps(false);
  }
}, [provider, slides, gapLessonPlanText, gapLessonPlanImages, addToast]);
```

**6. Add "Check for Gaps" button** in the top bar. Find the `{/* Make Cohesive Button — right-aligned */}` block (around line ~2178). The button container currently wraps just the Make Cohesive button. Change the condition from `slides.length >= 2` to `slides.length >= 1` and add the Check for Gaps button BEFORE the Make Cohesive button inside the flex container:

Replace the entire block starting with `{/* Make Cohesive Button — right-aligned, separate from selection controls */}` to include both buttons:

```jsx
{/* Gap Analysis + Make Cohesive — right-aligned */}
{slides.length >= 1 && (
  <div className="ml-auto flex items-center gap-2">
    {/* Check for Gaps button */}
    <button
      onClick={() => gapFileInputRef.current?.click()}
      disabled={!provider || isAnalyzingGaps}
      className={`flex items-center gap-2 px-4 py-2 rounded-xl text-sm font-bold transition-all ${
        !provider || isAnalyzingGaps
          ? 'bg-slate-100 dark:bg-slate-800 text-slate-400 dark:text-slate-500 cursor-not-allowed'
          : 'bg-gradient-to-r from-teal-600 to-emerald-600 dark:from-teal-500 dark:to-emerald-500 text-white dark:text-slate-900 hover:shadow-lg hover:scale-[1.02] active:scale-[0.98]'
      }`}
    >
      {isAnalyzingGaps ? (
        <>
          <svg className="w-4 h-4 animate-spin" fill="none" viewBox="0 0 24 24">
            <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"/>
            <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"/>
          </svg>
          <span>Analyzing...</span>
        </>
      ) : (
        <>
          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4" />
          </svg>
          <span>Check for Gaps</span>
        </>
      )}
    </button>

    {/* Make Cohesive button (existing — keep as-is but only show when 2+ slides) */}
    {slides.length >= 2 && (
      <button
        onClick={handleMakeCohesive}
        disabled={!provider || isProcessingCohesion}
        className={`flex items-center gap-2 px-4 py-2 rounded-xl text-sm font-bold transition-all ${
          !provider || isProcessingCohesion
            ? 'bg-slate-100 dark:bg-slate-800 text-slate-400 dark:text-slate-500 cursor-not-allowed'
            : 'bg-gradient-to-r from-purple-600 to-indigo-600 dark:from-amber-500 dark:to-orange-500 text-white dark:text-slate-900 hover:shadow-lg hover:scale-[1.02] active:scale-[0.98]'
        }`}
      >
        {isProcessingCohesion ? (
          <>
            <svg className="w-4 h-4 animate-spin" fill="none" viewBox="0 0 24 24">
              <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"/>
              <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"/>
            </svg>
            <span>Analyzing deck...</span>
          </>
        ) : (
          <>
            <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15" />
            </svg>
            <span>Make Cohesive</span>
          </>
        )}
      </button>
    )}
  </div>
)}
```

Note: The Make Cohesive button ITSELF still checks `slides.length >= 2` inside the container, but the container now shows at 1+ slides so the Check for Gaps button is visible earlier.

**7. Add GapAnalysisPanel rendering** in the JSX. Place it after the CohesionPreview modal block (~line 2519):

```jsx
{/* Gap Analysis Panel (Phase 59) */}
{gapResult && (
  <GapAnalysisPanel
    result={gapResult}
    onAddSlide={handleAddSlideFromGap}
    onReanalyze={handleReanalyzeGaps}
    onClose={() => setGapResult(null)}
    generatingGapId={generatingGapId}
  />
)}
```
  </action>
  <verify>
Run `npx tsc --noEmit`. Should have only an error for `handleAddSlideFromGap` not being defined yet (Task 2 handles that). Check that all state variables and handlers are referenced correctly.
  </verify>
  <done>
App.tsx has: hidden PDF file input for gap analysis, gap state variables (gapResult, isAnalyzingGaps, generatingGapId, stored lesson plan data), "Check for Gaps" button with teal/emerald gradient in top bar, handleGapPdfUpload that processes PDF and calls provider.analyzeGaps, handleReanalyzeGaps for fresh comparison, and GapAnalysisPanel rendered conditionally when gapResult is non-null.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add handleAddSlideFromGap with temp-slide pattern and position drift correction</name>
  <files>App.tsx</files>
  <action>
Add the `handleAddSlideFromGap` handler after `handleReanalyzeGaps` (from Task 1).

**handleAddSlideFromGap** — follows the exact pattern of `handleInsertElaborateSlide`:

```typescript
const handleAddSlideFromGap = useCallback(async (gap: IdentifiedGap) => {
  if (!provider) return;

  setGeneratingGapId(gap.id);

  const tempId = `gap-slide-${Date.now()}`;
  const tempSlide: Slide = {
    id: tempId,
    title: `Generating: ${gap.suggestedTitle}`,
    content: ['Generating content from gap analysis...'],
    speakerNotes: '',
    imagePrompt: '',
    isGeneratingImage: true,
    layout: 'split'
  };

  // Insert at suggested position (clamped to valid range)
  const insertIndex = Math.min(gap.suggestedPosition, slides.length);
  const newSlides = [...slides];
  newSlides.splice(insertIndex, 0, tempSlide);
  setSlides(newSlides);
  setActiveSlideIndex(insertIndex);

  try {
    const generated = await provider.generateSlideFromGap(
      gap, slides, lessonTitle, deckVerbosity
    );

    // Replace temp slide with generated content
    setSlides(curr => curr.map(s =>
      s.id === tempId
        ? { ...generated, id: tempId, isGeneratingImage: autoGenerateImages }
        : s
    ));

    // Remove the filled gap from the result and adjust positions of remaining gaps
    setGapResult(prev => {
      if (!prev) return null;
      const remainingGaps = prev.gaps
        .filter(g => g.id !== gap.id)
        .map(g => ({
          ...g,
          // Adjust positions: gaps after the insertion point shift by +1
          suggestedPosition: g.suggestedPosition >= insertIndex
            ? g.suggestedPosition + 1
            : g.suggestedPosition
        }));
      return {
        ...prev,
        gaps: remainingGaps
      };
    });

    addToast(`Added slide: ${generated.title || gap.suggestedTitle}`, 3000, 'success');

    // Generate image if auto-generate is enabled
    if (autoGenerateImages) {
      try {
        const img = await provider.generateSlideImage(
          generated.imagePrompt, generated.layout
        );
        setSlides(curr => curr.map(s =>
          s.id === tempId
            ? { ...s, imageUrl: img, isGeneratingImage: false }
            : s
        ));
      } catch (imgErr) {
        // Image generation failure is non-fatal
        console.error('[GapAnalysis] Image generation failed:', imgErr);
        setSlides(curr => curr.map(s =>
          s.id === tempId ? { ...s, isGeneratingImage: false } : s
        ));
      }
    }
  } catch (err) {
    console.error('[GapAnalysis] Slide generation failed:', err);

    // Fallback: replace temp with basic slide using suggested content
    setSlides(curr => curr.map(s =>
      s.id === tempId
        ? {
            ...tempSlide,
            title: gap.suggestedTitle,
            content: gap.suggestedContent,
            speakerNotes: '',
            isGeneratingImage: false
          }
        : s
    ));

    if (err instanceof AIProviderError) {
      setErrorModal({
        title: 'Gap Slide Generation Failed',
        message: err.userMessage
      });
    } else {
      addToast('Slide generation failed. Added basic slide from gap suggestion.', 4000, 'error');
    }
  } finally {
    setGeneratingGapId(null);
  }
}, [provider, slides, lessonTitle, deckVerbosity, autoGenerateImages, addToast]);
```

Key implementation details:
- **Position drift correction**: After removing the filled gap from the array, all remaining gaps with `suggestedPosition >= insertIndex` get incremented by 1 to account for the newly inserted slide shifting the deck.
- **Temp slide pattern**: Matches `handleInsertElaborateSlide` exactly — insert temp, call AI, replace, optionally generate image.
- **Error fallback**: On AI failure, the temp slide is replaced with a basic slide using the gap's suggestedTitle and suggestedContent (not an empty slide).
- **Image generation**: Separated into its own try/catch so image failure doesn't affect the slide itself.
- **generatingGapId**: Set before generation starts, cleared in finally block. The panel uses this to show a spinner on the specific gap being generated.

**Ensure `handleAddSlideFromGap` is referenced** in the GapAnalysisPanel render (already added in Task 1's onAddSlide prop).

**Dependencies check:** Make sure `lessonTitle`, `deckVerbosity`, `autoGenerateImages`, `setSlides`, `setActiveSlideIndex`, `setErrorModal`, and `setGapResult` are all accessible in the closure (they should be — they're all App.tsx state/setters).
  </action>
  <verify>
Run `npx tsc --noEmit`. Should compile with zero errors. Then run `npm run dev` to verify the app starts without runtime errors. In the browser, verify:
1. The "Check for Gaps" button appears in the editor top bar when there are slides
2. Clicking it opens a file picker filtered to PDF
3. The button is disabled and shows "Analyzing..." spinner during processing
  </verify>
  <done>
handleAddSlideFromGap exists with: temp-slide insertion at suggestedPosition, AI generateSlideFromGap call, gap removal from result with position drift correction (+1 for remaining gaps after insertion point), error fallback to basic slide with suggested content, optional image generation, and generatingGapId spinner tracking. Full gap analysis workflow is functional: Check for Gaps button -> PDF upload -> AI analysis -> panel display -> Add Slide -> gap disappears and slide appears at correct position.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run dev` starts without runtime errors
3. "Check for Gaps" button appears in top bar with teal/emerald gradient when 1+ slides exist
4. Clicking button opens PDF file picker (accept=".pdf")
5. After PDF upload, toast shows "Processing lesson plan PDF..." then "Analyzing gaps..."
6. GapAnalysisPanel opens on right side showing coverage %, severity badges, gap list
7. Clicking "Add Slide" on a gap shows spinner on that gap, inserts temp slide, then replaces with AI content
8. Filled gap disappears from panel after generation
9. Remaining gap positions are adjusted for index drift
10. "Re-analyze" button re-runs analysis with current deck state
11. "Close" button dismisses the panel
12. Make Cohesive button still appears and works when 2+ slides exist
</verification>

<success_criteria>
- GAP-01: PDF file picker opens from "Check for Gaps" button click
- GAP-02: provider.analyzeGaps called with deck + lesson plan text + page images
- GAP-03: GapAnalysisPanel shows gap list with topics and descriptions
- GAP-04: Severity badges (red/amber/gray) visible on each gap
- GAP-05: Expandable suggested content preview on each gap
- GAP-06: "Add Slide" button generates slide at suggested position via temp-slide pattern
- Position drift: remaining gaps have positions adjusted after each insertion
- Error handling: AI failures show error modal/toast, temp slide falls back to suggested content
- Re-analyze: fresh AI comparison with current deck state
</success_criteria>

<output>
After completion, create `.planning/phases/59-gap-analysis/59-03-SUMMARY.md`
</output>
