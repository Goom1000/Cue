---
phase: 41-tour-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["41-01"]
files_modified:
  - components/TourButton.tsx
  - hooks/useTour.ts
  - App.tsx
autonomous: true

must_haves:
  truths:
    - "User can trigger tours via button on any screen"
    - "User can skip/dismiss tours at any step using button or Escape"
    - "User sees progress indicator showing current step and total steps"
    - "Tour overlay appears above all existing UI including modals"
    - "User can navigate tours using keyboard (Tab, Enter, Escape)"
  artifacts:
    - path: "components/TourButton.tsx"
      provides: "Tour trigger button with ? icon"
      exports: ["TourButton"]
    - path: "hooks/useTour.ts"
      provides: "Driver.js wrapper hook with lifecycle management"
      exports: ["useTour"]
  key_links:
    - from: "hooks/useTour.ts"
      to: "driver.js"
      via: "driver() function"
      pattern: "import.*driver.*from.*driver.js"
    - from: "components/TourButton.tsx"
      to: "hooks/useTour.ts"
      via: "startTour callback"
      pattern: "useTour\\("
    - from: "hooks/useTour.ts"
      to: "hooks/useTourState.ts"
      via: "onComplete callback passed by consumer"
      pattern: "onComplete.*markComplete"
      note: "Wiring happens at consumer level in Phase 42 - useTour accepts onComplete, screens call useTourState.markComplete in that callback"
---

<objective>
Create TourButton component and useTour hook for driver.js integration with keyboard accessibility.

Purpose: Provide the tour trigger button (TOUR-01) and driver.js wrapper that handles lifecycle, keyboard navigation (A11Y-01), and proper cleanup. This creates the infrastructure that screen-specific tours will use.

Output: TourButton component with "?" icon that triggers tours, and useTour hook that wraps driver.js with proper React lifecycle and accessibility settings.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/41-tour-infrastructure/41-01-SUMMARY.md
@.planning/phases/41-tour-infrastructure/41-RESEARCH.md
@components/Button.tsx
@hooks/useSettings.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useTour hook</name>
  <files>hooks/useTour.ts</files>
  <action>
Create `hooks/useTour.ts` - a React wrapper for driver.js with proper lifecycle management.

Requirements:
1. **Import driver.js:** Import { driver, DriveStep, Config } from 'driver.js'
2. **Cleanup:** Use useEffect to destroy driver instance on unmount to prevent UI stuck issues
3. **Error handling:** Wrap drive() in try/catch, call destroy() on error
4. **Config defaults:** Apply Cue-specific defaults that all tours inherit:
   - showProgress: true (TOUR-04)
   - allowClose: true (TOUR-02)
   - allowKeyboardControl: true (A11Y-01)
   - popoverClass: 'cue-tour-popover' (for CSS theming)
   - overlayColor: 'rgba(0, 0, 0, 0.75)'
   - stagePadding: 10
   - stageRadius: 8
5. **Completion detection:** Track current step index. In onDestroyed, check if currentStepIndex equals steps.length - 1 to determine if tour completed vs was skipped. Only call onComplete if tour actually completed all steps.
6. **Callbacks:** Accept onComplete callback (only fires on completion) and onDestroy callback (fires on any exit)
7. **Stable startTour:** Return memoized startTour function

Hook signature:
```typescript
interface UseTourOptions {
  steps: DriveStep[];
  onComplete?: () => void;  // Called only when user finishes all steps
  onDestroy?: () => void;   // Called on any tour exit (skip, complete, or error)
}

export function useTour(options: UseTourOptions): {
  startTour: () => void;
  isRunning: boolean;
}
```

Implementation pattern:
```typescript
import { useCallback, useEffect, useRef, useState } from 'react';
import { driver, DriveStep, Config } from 'driver.js';

interface UseTourOptions {
  steps: DriveStep[];
  onComplete?: () => void;
  onDestroy?: () => void;
}

export function useTour({ steps, onComplete, onDestroy }: UseTourOptions) {
  const [isRunning, setIsRunning] = useState(false);
  const driverRef = useRef<ReturnType<typeof driver> | null>(null);
  const currentStepRef = useRef<number>(0);
  const totalStepsRef = useRef<number>(0);

  const startTour = useCallback(() => {
    // Cleanup any existing instance
    if (driverRef.current) {
      driverRef.current.destroy();
    }

    // Track total steps for completion detection
    totalStepsRef.current = steps.length;
    currentStepRef.current = 0;

    const config: Config = {
      showProgress: true,
      allowClose: true,
      allowKeyboardControl: true,
      popoverClass: 'cue-tour-popover',
      overlayColor: 'rgba(0, 0, 0, 0.75)',
      stagePadding: 10,
      stageRadius: 8,
      steps,
      onHighlightStarted: (element, step, options) => {
        // Track current step index for completion detection
        // driver.js provides step index through the options
        if (options.state && typeof options.state.activeIndex === 'number') {
          currentStepRef.current = options.state.activeIndex;
        }
      },
      onDestroyed: () => {
        setIsRunning(false);

        // Check if tour was completed (reached last step)
        // Driver.js advances activeIndex before calling onDestroyed on completion
        const completedAllSteps = currentStepRef.current >= totalStepsRef.current - 1;

        if (completedAllSteps && onComplete) {
          onComplete();
        }

        onDestroy?.();
        driverRef.current = null;
      },
      onCloseClick: () => {
        // User clicked X or pressed Escape - this is a skip
        driverRef.current?.destroy();
      },
    };

    try {
      driverRef.current = driver(config);
      setIsRunning(true);
      driverRef.current.drive();
    } catch (e) {
      console.error('Tour error:', e);
      driverRef.current?.destroy();
      setIsRunning(false);
    }
  }, [steps, onComplete, onDestroy]);

  // Cleanup on unmount using useEffect (not useCallback)
  useEffect(() => {
    return () => {
      if (driverRef.current) {
        driverRef.current.destroy();
      }
    };
  }, []);

  return { startTour, isRunning };
}
```

Note: driver.js handles keyboard navigation (Tab between buttons, Enter to advance, Escape to close) when allowKeyboardControl is true. This satisfies A11Y-01.

Integration with useTourState (Phase 42): When screens implement tours, they will call:
```typescript
const { markComplete, isComplete } = useTourState('landing');
const { startTour } = useTour({
  steps: landingTourSteps,
  onComplete: () => markComplete('landing'),  // This wires the two hooks
});
```
  </action>
  <verify>
Run `npm run typecheck` - no TypeScript errors.
Hook is exported and importable.

**Progress indicator verification (TOUR-04):**
Create a temporary test in App.tsx:
1. Import useTour from hooks/useTour
2. Call useTour with 3 test steps: `[{ element: 'body', popover: { title: 'Step 1' } }, { element: 'body', popover: { title: 'Step 2' } }, { element: 'body', popover: { title: 'Step 3' } }]`
3. Add a button to trigger startTour
4. Click the button - confirm popover shows progress text in format "1 of 3", "2 of 3", "3 of 3" as you advance
5. Remove test code after verification
  </verify>
  <done>useTour hook wraps driver.js with useEffect cleanup, step-tracking completion detection, and Cue defaults. Progress indicator displays "N of M" format.</done>
</task>

<task type="auto">
  <name>Task 2: Create TourButton component</name>
  <files>components/TourButton.tsx</files>
  <action>
Create `components/TourButton.tsx` - the tour trigger button with "?" icon.

Requirements (TOUR-01, TOUR-06):
1. **Appearance:**
   - Small button (32x32px) with "?" text
   - Rounded-full
   - Subtle styling: slate-200 dark:slate-700 background
   - Hover: indigo-100 dark:amber-500/20 background, indigo-600 dark:amber-400 text
2. **Accessibility:**
   - aria-label="Start tour" (A11Y-03)
   - focus-visible:ring-2 focus-visible:ring-indigo-500 dark:focus-visible:ring-amber-500 (A11Y-04)
   - tabIndex 0 (keyboard accessible)
3. **Tooltip on hover:** Show "Take a tour" on hover using title attribute or integrate with InfoTooltip
4. **onClick:** Call provided onStart callback

Props:
```typescript
interface TourButtonProps {
  onStart: () => void;
  className?: string;
}
```

Implementation:
```typescript
import React from 'react';

interface TourButtonProps {
  onStart: () => void;
  className?: string;
}

export function TourButton({ onStart, className = '' }: TourButtonProps) {
  return (
    <button
      onClick={onStart}
      className={`w-8 h-8 rounded-full bg-slate-200 dark:bg-slate-700 text-slate-600 dark:text-slate-300 hover:bg-indigo-100 dark:hover:bg-amber-500/20 hover:text-indigo-600 dark:hover:text-amber-400 flex items-center justify-center text-sm font-bold transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-indigo-500 dark:focus-visible:ring-amber-500 ${className}`}
      aria-label="Start tour"
      title="Take a tour"
    >
      ?
    </button>
  );
}
```

The button is intentionally simple - a "?" that users can click to start a tour. It will be placed in screen headers (landing, editor, presentation) in later phases.
  </action>
  <verify>
Run `npm run typecheck` - no TypeScript errors.
Visual test: Import in App.tsx header temporarily, verify:
- Button renders with "?" text
- Hover shows indigo (light) / amber (dark) color
- Tab focuses button with visible ring
- Click calls onStart
- Accessible via keyboard (Tab, Enter)
  </verify>
  <done>TourButton renders with proper styling, accessibility, and hover states.</done>
</task>

<task type="auto">
  <name>Task 3: Import driver.css in App.tsx</name>
  <files>App.tsx</files>
  <action>
Add CSS imports for driver.js theming at the top of App.tsx.

Add after existing imports, before component code:

```typescript
// Tour styling
import './styles/driver.css';
```

This ensures driver.js base styles and Cue theme overrides are loaded when tours are used.

Note: The actual tour content won't be visible yet (no tours are triggered), but the CSS is ready for Phase 42+ when tours are implemented.
  </action>
  <verify>
Run `npm run dev` - no CSS import errors in console.
Run `npm run build` - build succeeds (CSS bundled correctly).
  </verify>
  <done>driver.css imported in App.tsx, CSS ready for tour implementation.</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `npm run typecheck` passes
2. `npm run build` passes (CSS bundling works)
3. useTour hook exported from hooks/useTour.ts
4. TourButton component exported from components/TourButton.tsx
5. driver.css imported in App.tsx
6. TourButton is keyboard accessible (Tab focuses, Enter triggers)
7. TourButton has visible focus indicator
8. **Progress indicator test:** Start a 3-step test tour, confirm "1 of 3", "2 of 3", "3 of 3" displays correctly
9. **Completion detection test:** Complete a tour to last step, verify onComplete fires; skip a tour early, verify onComplete does NOT fire
</verification>

<success_criteria>
- useTour hook provides:
  - startTour() function that triggers driver.js
  - isRunning state for conditional rendering
  - Proper cleanup on unmount via useEffect
  - Cue defaults (progress, keyboard nav, close button)
  - Completion detection: onComplete only fires when all steps viewed
- TourButton component provides:
  - "?" trigger button (TOUR-01)
  - Keyboard accessible (Tab, Enter) (A11Y-01)
  - ARIA label (A11Y-03)
  - Visible focus ring (A11Y-04)
  - Dark mode styling
- driver.css imported and ready for use
- All keyboard navigation requirements met (A11Y-01, A11Y-05):
  - Tab navigates between tour buttons
  - Enter activates buttons
  - Escape closes tour (via driver.js allowClose)
- Progress indicator shows "N of M" format (TOUR-04)
- Integration path with useTourState documented (wiring at consumer level in Phase 42)
</success_criteria>

<output>
After completion, create `.planning/phases/41-tour-infrastructure/41-03-SUMMARY.md`
</output>
