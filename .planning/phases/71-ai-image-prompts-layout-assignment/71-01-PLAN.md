---
phase: 71-ai-image-prompts-layout-assignment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - services/aiProvider.ts
  - services/providers/geminiProvider.ts
  - services/providers/claudeProvider.ts
  - services/generationPipeline.ts
autonomous: true
requirements:
  - PIPE-03
  - PIPE-04

must_haves:
  truths:
    - "After scripted import, each slide has a non-empty imagePrompt field"
    - "After scripted import, each slide has an AI-assigned layout from the curated set (split, full-image, center-text)"
    - "Mapper-assigned layouts (work-together, class-challenge) are never overridden by the AI enrichment"
    - "If the AI enrichment call fails (network error, rate limit, invalid response), slides still import successfully with synthesized fallback prompts"
    - "A warning is surfaced in PipelineResult.warnings when fallback is used"
  artifacts:
    - path: "services/aiProvider.ts"
      provides: "SlideEnrichmentInput/Result types and enrichScriptedSlides on AIProviderInterface"
      contains: "enrichScriptedSlides"
    - path: "services/providers/geminiProvider.ts"
      provides: "Gemini implementation of enrichScriptedSlides using responseSchema"
      contains: "enrichScriptedSlides"
    - path: "services/providers/claudeProvider.ts"
      provides: "Claude implementation of enrichScriptedSlides using tool_use"
      contains: "enrichScriptedSlides"
    - path: "services/generationPipeline.ts"
      provides: "Enrichment step in scripted early-return with try/catch fallback"
      contains: "enrichScriptedSlides"
  key_links:
    - from: "services/generationPipeline.ts"
      to: "provider.enrichScriptedSlides()"
      via: "called inside scripted mode block after mapBlocksToSlides"
      pattern: "provider\\.enrichScriptedSlides"
    - from: "services/generationPipeline.ts"
      to: "synthesizeFallbackEnrichment"
      via: "catch block applies fallback on enrichment failure"
      pattern: "synthesizeFallbackEnrichment"
    - from: "services/generationPipeline.ts"
      to: "mergeEnrichmentResults"
      via: "applies AI results onto slides with layout lock protection"
      pattern: "mergeEnrichmentResults"
---

<objective>
Add AI-powered enrichment of scripted slides with image prompts, layout assignments, and theme colors via a single batch call per provider, with graceful fallback on failure.

Purpose: Scripted slides from the mapper have empty `imagePrompt` fields and default `split` layouts. This plan adds a minimal AI call (~700 tokens) that generates descriptive image prompts for the downstream image generator, assigns appropriate layouts from a curated subset, and optionally assigns theme colors -- all without modifying slide content, titles, or speaker notes.

Output: Both providers implement `enrichScriptedSlides()`, the pipeline wires it into the scripted early-return with try/catch fallback, and slides always have valid imagePrompt/layout values regardless of AI success.
</objective>

<execution_context>
@/Users/ricky/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ricky/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/71-ai-image-prompts-layout-assignment/71-CONTEXT.md
@.planning/phases/71-ai-image-prompts-layout-assignment/71-RESEARCH.md
@.planning/phases/70-slide-mapper-pipeline-integration/70-02-SUMMARY.md

@services/aiProvider.ts
@services/generationPipeline.ts
@services/providers/geminiProvider.ts
@services/providers/claudeProvider.ts
@types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add enrichment types to aiProvider.ts and implement enrichScriptedSlides in both providers</name>
  <files>
    services/aiProvider.ts
    services/providers/geminiProvider.ts
    services/providers/claudeProvider.ts
  </files>
  <action>
**aiProvider.ts -- Types and Interface:**

1. Add `SlideEnrichmentInput` interface near the other type exports (after `ColleagueTransformationResult`):
   ```typescript
   // Scripted slide enrichment types (Phase 71)
   export interface SlideEnrichmentInput {
     index: number;
     title: string;
     firstBullet: string;       // First content bullet, truncated to ~50 chars
     hasQuestion: boolean;
     lessonPhase?: string;       // 'hook' | 'i-do' | 'we-do' | 'you-do' | 'plenary'
     layoutLocked: boolean;      // true for work-together/class-challenge (non-split)
   }

   export interface SlideEnrichmentResult {
     index: number;
     imagePrompt: string;
     layout: 'split' | 'full-image' | 'center-text';
     theme?: 'default' | 'purple' | 'blue' | 'green' | 'warm';
   }
   ```

2. Add `enrichScriptedSlides` to `AIProviderInterface` (after `enhanceDocument`):
   ```typescript
   // Enrich scripted slides with AI-generated image prompts, layouts, and themes (Phase 71)
   enrichScriptedSlides(
     slides: SlideEnrichmentInput[],
     gradeLevel: string
   ): Promise<SlideEnrichmentResult[]>;
   ```

**geminiProvider.ts -- Gemini Implementation:**

Add `enrichScriptedSlides` method to the `GeminiProvider` class. Follow the `analyzeGaps` pattern (uses `ai.models.generateContent` with `responseSchema`).

1. Define the Gemini response schema constant near other schema constants:
   ```typescript
   import { Type } from '@google/genai';  // Already imported

   const ENRICHMENT_RESPONSE_SCHEMA = {
     type: Type.ARRAY,
     items: {
       type: Type.OBJECT,
       properties: {
         index: { type: Type.INTEGER },
         imagePrompt: { type: Type.STRING },
         layout: {
           type: Type.STRING,
           enum: ['split', 'full-image', 'center-text'],
         },
         theme: {
           type: Type.STRING,
           enum: ['default', 'purple', 'blue', 'green', 'warm'],
         },
       },
       required: ['index', 'imagePrompt', 'layout', 'theme'],
     },
   };
   ```

2. Build the prompt function (can be inline or a helper). The prompt must:
   - Include `gradeLevel` for age-appropriate image prompts
   - List each slide compactly: `{index}. "{title}" -- {firstBullet} [{hints}]`
   - Hints include: `QUESTION` if `hasQuestion`, the `lessonPhase` value, `LAYOUT_LOCKED` if locked
   - Instruct: "Return exactly N results" (prevents array length mismatch)
   - Instruct: "For LAYOUT_LOCKED slides, still generate imagePrompt but set layout to 'split'"
   - Instruct: "QUESTION slides may suit 'center-text'; hook/plenary slides may suit 'full-image'"
   - Instruct: each `imagePrompt` should be 1-2 sentences describing an educational illustration specific to the slide topic
   - Include theme assignment: "Assign a color theme to each slide from: default, purple, blue, green, warm. Vary themes across the deck for visual interest."

3. Implement the method:
   ```typescript
   async enrichScriptedSlides(
     slides: SlideEnrichmentInput[],
     gradeLevel: string
   ): Promise<SlideEnrichmentResult[]> {
     const ai = new GoogleGenAI({ apiKey: this.apiKey });
     const prompt = /* build prompt as described above */;

     const response = await ai.models.generateContent({
       model: this.model,
       contents: prompt,
       config: {
         responseMimeType: 'application/json',
         responseSchema: ENRICHMENT_RESPONSE_SCHEMA,
         temperature: 0.7,
       },
     });

     const text = response.text || '[]';
     return JSON.parse(text);
   }
   ```

**claudeProvider.ts -- Claude Implementation:**

Add `enrichScriptedSlides` method to the `ClaudeProvider` class. Use direct `fetch` (NOT the standalone `callClaude` function -- it has a `this.model` bug per RESEARCH.md Pitfall 5). Follow the `generateSlideFromGap` pattern (line ~2060) which uses `fetch` directly.

1. Define the Claude tool schema constant:
   ```typescript
   const ENRICHMENT_TOOL = {
     name: 'enrich_slides',
     description: 'Assign image prompts, layouts, and themes to scripted slides',
     input_schema: {
       type: 'object' as const,
       properties: {
         slides: {
           type: 'array',
           items: {
             type: 'object',
             properties: {
               index: { type: 'integer', description: 'Slide index' },
               imagePrompt: { type: 'string', description: 'Image generation prompt (1-2 sentences)' },
               layout: {
                 type: 'string',
                 enum: ['split', 'full-image', 'center-text'],
                 description: 'Visual layout type',
               },
               theme: {
                 type: 'string',
                 enum: ['default', 'purple', 'blue', 'green', 'warm'],
                 description: 'Color theme',
               },
             },
             required: ['index', 'imagePrompt', 'layout', 'theme'],
           },
         },
       },
       required: ['slides'],
     },
   };
   ```

2. Build the same prompt as Gemini (same rules, same format). The system prompt should be brief: "You are a slide enrichment assistant. Assign image prompts, layouts, and themes to educational slides."

3. Implement the method using direct `fetch`:
   ```typescript
   async enrichScriptedSlides(
     slides: SlideEnrichmentInput[],
     gradeLevel: string
   ): Promise<SlideEnrichmentResult[]> {
     const prompt = /* same prompt builder as Gemini */;

     const response = await fetch('https://api.anthropic.com/v1/messages', {
       method: 'POST',
       headers: {
         'Content-Type': 'application/json',
         'x-api-key': this.apiKey,
         'anthropic-version': '2023-06-01',
         'anthropic-dangerous-direct-browser-access': 'true',
       },
       body: JSON.stringify({
         model: this.model,
         max_tokens: 2048,
         system: 'You are a slide enrichment assistant. Assign image prompts, layouts, and themes to educational slides.',
         tools: [ENRICHMENT_TOOL],
         tool_choice: { type: 'tool', name: 'enrich_slides' },
         messages: [{ role: 'user', content: prompt }],
       }),
     });

     const data = await response.json();
     if (!response.ok) {
       throw new AIProviderError(
         `Enrichment failed: ${data.error?.message || response.statusText}`,
         response.status === 429 ? 'RATE_LIMIT' : 'SERVER_ERROR',
         data
       );
     }

     const toolUse = data.content?.find((c: any) => c.type === 'tool_use');
     return toolUse?.input?.slides || [];
   }
   ```

**Shared prompt builder function:** Since both providers use the same prompt format, extract a shared `buildEnrichmentPrompt(slides: SlideEnrichmentInput[], gradeLevel: string): string` function. Place it in `aiProvider.ts` as an exported utility (same file as the types). This prevents drift between providers.

The prompt format should be:
```
Audience: {gradeLevel}

For each slide below, generate:
1. imagePrompt: A concise description for an educational illustration (1-2 sentences, specific to slide topic, suitable for AI image generation)
2. layout: One of 'split', 'full-image', 'center-text'
3. theme: One of 'default', 'purple', 'blue', 'green', 'warm'

Rules:
- Image prompts should be age-appropriate for the audience
- For LAYOUT_LOCKED slides, still generate an imagePrompt and theme but set layout to 'split'
- QUESTION slides may suit 'center-text' (large text focus) but this is a suggestion, not a rule
- Hook/plenary slides may suit 'full-image' for visual impact
- Vary themes across the deck for visual interest
- Return exactly {N} results in order

SLIDES:
{slideList}
```
  </action>
  <verify>
1. `npx tsc --noEmit` -- zero TypeScript errors (interface matches implementations)
2. Grep: `enrichScriptedSlides` appears in aiProvider.ts (interface + types), geminiProvider.ts (implementation), claudeProvider.ts (implementation)
3. Grep: `buildEnrichmentPrompt` is exported from aiProvider.ts and imported by both providers
4. Grep: `ENRICHMENT_RESPONSE_SCHEMA` exists in geminiProvider.ts, `ENRICHMENT_TOOL` exists in claudeProvider.ts
  </verify>
  <done>
Both providers implement enrichScriptedSlides() that accepts SlideEnrichmentInput[] and gradeLevel, calls their respective AI APIs with structured output schemas, and returns SlideEnrichmentResult[]. The shared prompt builder is in aiProvider.ts. TypeScript compiles cleanly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire enrichment into pipeline scripted block with fallback and merge logic</name>
  <files>
    services/generationPipeline.ts
  </files>
  <action>
Modify the scripted mode early-return block in `runGenerationPipeline` (lines 111-130) to add the enrichment step between `mapBlocksToSlides()` and the return statement.

1. **Add imports** at the top of the file:
   ```typescript
   import { SlideEnrichmentInput, SlideEnrichmentResult } from './aiProvider';
   ```

2. **Add `prepareEnrichmentInputs` helper** (before `runGenerationPipeline` or as a module-level function):
   ```typescript
   function prepareEnrichmentInputs(slides: Slide[]): SlideEnrichmentInput[] {
     return slides.map((slide, i) => ({
       index: i,
       title: slide.title,
       firstBullet: (slide.content[0] || '').slice(0, 50),
       hasQuestion: !!slide.hasQuestionFlag,
       lessonPhase: slide.lessonPhase,
       layoutLocked: slide.layout !== 'split' && slide.layout !== undefined,
     }));
   }
   ```
   Note: `layoutLocked` is true when the mapper set a non-default layout (e.g., `work-together`, `class-challenge`). Slides with `layout: 'split'` or `layout: undefined` are eligible for AI layout assignment.

3. **Add `mergeEnrichmentResults` helper:**
   ```typescript
   function mergeEnrichmentResults(
     slides: Slide[],
     results: SlideEnrichmentResult[]
   ): Slide[] {
     const resultMap = new Map(results.map(r => [r.index, r]));

     return slides.map((slide, i) => {
       const enrichment = resultMap.get(i);
       if (!enrichment) return slide;

       // Layout lock: only override if mapper set default 'split' or undefined
       const layoutLocked = slide.layout !== 'split' && slide.layout !== undefined;
       const newLayout = layoutLocked ? slide.layout : enrichment.layout;

       return {
         ...slide,
         imagePrompt: enrichment.imagePrompt || slide.imagePrompt,
         layout: newLayout,
         theme: enrichment.theme || slide.theme,
       };
     });
   }
   ```

4. **Add `synthesizeFallbackEnrichment` helper:**
   ```typescript
   function synthesizeFallbackEnrichment(slides: Slide[]): Slide[] {
     return slides.map(slide => ({
       ...slide,
       imagePrompt: slide.imagePrompt ||
         `Educational illustration: ${slide.title}${slide.content[0] ? ' \u2014 ' + slide.content[0] : ''}`,
       // layout stays as mapper default (split or work-together) -- no heuristic logic per CONTEXT.md
     }));
   }
   ```

5. **Update the scripted mode block** (replace lines 111-130):
   ```typescript
   if (input.mode === 'scripted') {
     onProgress?.({
       stage: 'generating',
       stageIndex: 0,
       totalStages: 1,
     });

     const parseResult = parseScriptedLessonPlan(lessonPlanText);
     const allBlocks = parseResult.days.flatMap(day => day.blocks);
     let slides = mapBlocksToSlides(allBlocks);

     // Enrich slides with AI-generated image prompts, layouts, and themes
     try {
       const inputs = prepareEnrichmentInputs(slides);
       const results = await provider.enrichScriptedSlides(inputs, gradeLevel);

       // Validate result count -- if mismatched, fall back entirely
       if (results.length === slides.length) {
         // Validate each result individually: use valid ones, fallback for invalid
         const validResults = results.filter(r =>
           typeof r.imagePrompt === 'string' && r.imagePrompt.length > 0 &&
           ['split', 'full-image', 'center-text'].includes(r.layout)
         );

         if (validResults.length === slides.length) {
           slides = mergeEnrichmentResults(slides, validResults);
         } else {
           // Partial success: merge valid results, fallback for the rest
           slides = mergeEnrichmentResults(slides, validResults);
           slides = synthesizeFallbackEnrichment(slides);
           warnings.push('Some slides used auto-generated image prompts (AI enrichment partially succeeded)');
         }
       } else {
         // Array length mismatch -- fall back entirely
         slides = synthesizeFallbackEnrichment(slides);
         warnings.push('Image prompts were auto-generated from slide titles (AI enrichment returned unexpected results)');
       }
     } catch (error) {
       // PIPE-04: Enrichment failure does not block import
       console.warn('Scripted slide enrichment failed, using fallback:', error);
       slides = synthesizeFallbackEnrichment(slides);
       warnings.push('Image prompts were auto-generated from slide titles (AI enrichment unavailable)');
     }

     return {
       slides,
       coveragePercentage: null,
       remainingGaps: [],
       warnings: [...parseResult.warnings, ...warnings],
       wasPartial: false,
     };
   }
   ```

**Key design decisions:**
- The enrichment call happens synchronously (per CONTEXT.md decision: blocks until complete)
- `synthesizeFallbackEnrichment` uses the richer pattern from CONTEXT.md: `"Educational illustration: {title} -- {first bullet}"` instead of just the title
- Layout lock protection is in `mergeEnrichmentResults` (defense in depth -- even if AI returns wrong layout for locked slides, merge ignores it)
- Partial success: valid results are applied, then `synthesizeFallbackEnrichment` fills in remaining empty imagePrompts
- Warnings are pushed for toast display, matching existing pattern (e.g., gap analysis warnings at lines 224-226)
- The `const slides` changes to `let slides` since it's reassigned after enrichment
  </action>
  <verify>
1. `npx tsc --noEmit` -- zero TypeScript errors
2. Grep: `enrichScriptedSlides` called in the scripted mode block of generationPipeline.ts
3. Grep: `synthesizeFallbackEnrichment` exists and is called in the catch block
4. Grep: `mergeEnrichmentResults` exists and handles layout lock
5. Verify the scripted block still has proper `return { slides, coveragePercentage: null, ... }` structure
  </verify>
  <done>
The scripted mode block in generationPipeline.ts calls provider.enrichScriptedSlides() after mapBlocksToSlides(), merges results with layout lock protection, and falls back to synthesized prompts on failure. Three fallback paths are handled: full success, partial success, and total failure. Warnings are surfaced in PipelineResult.warnings for toast display.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- zero TypeScript errors across all modified files
2. All 76 existing parser/mapper tests pass (no regressions): `npx jest --testPathPattern=scriptedParser`
3. `enrichScriptedSlides` method exists on AIProviderInterface and both implementations
4. Scripted mode block in generationPipeline.ts has try/catch around enrichment with fallback
5. Layout lock protection: mergeEnrichmentResults skips layout override for non-split slides
6. Fallback produces non-empty imagePrompt for every slide
</verification>

<success_criteria>
- Both Gemini and Claude providers can enrich scripted slides with a single batch API call returning imagePrompt + layout + theme per slide
- The pipeline gracefully handles enrichment failure (network, rate limit, malformed response) by synthesizing fallback prompts from slide titles and first bullets
- Mapper-assigned layouts (work-together, class-challenge) are never overridden by AI enrichment results
- TypeScript compiles cleanly with zero errors
- All existing tests pass (zero regressions)
</success_criteria>

<output>
After completion, create `.planning/phases/71-ai-image-prompts-layout-assignment/71-01-SUMMARY.md`
</output>
