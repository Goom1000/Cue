---
phase: 65-foundation-types-phase-detection
plan: 02
type: execute
wave: 2
depends_on: ["65-01"]
files_modified:
  - services/geminiService.ts
  - services/providers/claudeProvider.ts
  - App.tsx
autonomous: true

must_haves:
  truths:
    - "After generation in Fresh mode, every slide has a lessonPhase value"
    - "After generation in Blend mode, every slide has a lessonPhase value"
    - "After generation in Refine mode, no slide has a lessonPhase value"
    - "Phase detection runs on FULL lesson plan text before any truncation"
    - "Saving a deck with phase labels and reloading preserves all labels exactly"
    - "Both Gemini and Claude providers produce phase-tagged slides"
  artifacts:
    - path: "services/geminiService.ts"
      provides: "Phase detection wired into Gemini generation flow"
      contains: "assignPhasesToSlides"
    - path: "services/providers/claudeProvider.ts"
      provides: "Phase detection wired into Claude generation flow"
      contains: "assignPhasesToSlides"
  key_links:
    - from: "services/geminiService.ts"
      to: "services/phaseDetection/phaseDetector.ts"
      via: "import detectPhasesInText, assignPhasesToSlides"
      pattern: "import.*detectPhasesInText.*from.*phaseDetect"
    - from: "services/providers/claudeProvider.ts"
      to: "services/phaseDetection/phaseDetector.ts"
      via: "import detectPhasesInText, assignPhasesToSlides"
      pattern: "import.*detectPhasesInText.*from.*phaseDetect"
    - from: "services/geminiService.ts"
      to: "services/aiProvider.ts"
      via: "mode guard using GenerationInput.mode"
      pattern: "mode === 'fresh' \\|\\| .*mode === 'blend'"
---

<objective>
Wire phase detection into the generation flow for both Gemini and Claude providers, gated to Fresh and Blend modes only, and verify persistence survives save/load.

Purpose: Makes phase labels appear on generated slides, completing the Phase 65 success criteria. Phase detection runs on the full lesson plan text before truncation, then assigns phases to generated slides via post-processing.
Output: Both providers produce phase-tagged slides in Fresh/Blend modes. Refine mode produces zero phase labels. Persistence already works (optional field on Slide).
</objective>

<execution_context>
@/Users/ricky/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ricky/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/65-foundation-types-phase-detection/65-RESEARCH.md
@.planning/phases/65-foundation-types-phase-detection/65-01-SUMMARY.md
@services/geminiService.ts
@services/providers/claudeProvider.ts
@services/aiProvider.ts
@App.tsx
@services/saveService.ts
@services/loadService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire phase detection into both generation providers</name>
  <files>services/geminiService.ts, services/providers/claudeProvider.ts</files>
  <action>
Wire phase detection as a post-processing step in both providers' `generateLessonSlides` methods. Follow the exact same pattern used for content preservation detection (detectPreservableContent) and teachable moments (detectTeachableMoments) that already exist in both files.

**In `services/geminiService.ts` -- `generateLessonSlides` function:**

1. Add import at top of file:
```typescript
import { detectPhasesInText, assignPhasesToSlides } from './phaseDetection/phaseDetector';
```

2. BEFORE the existing content detection code (around line 261, before `const sourceText = getDetectionSource(input);`), add phase detection on the FULL lesson plan text. This MUST happen before any text processing/truncation:
```typescript
// Detect lesson phases on FULL lesson plan text (before any truncation)
// Mode-gated: only Fresh and Blend modes use lesson plans with GRR structure
const phaseResult = (input.mode === 'fresh' || input.mode === 'blend')
  ? detectPhasesInText(input.lessonText)
  : { phases: [], hasExplicitPhases: false };

if (phaseResult.hasExplicitPhases) {
  console.log(`[GeminiService] Detected ${phaseResult.phases.length} lesson phases`);
}
```

3. AFTER slides are parsed from the AI response (after the `return data.map(...)` at around line 389-393), replace the return with:
```typescript
const slides = data.map((item: any, index: number) => ({
  ...item,
  id: `slide-${Date.now()}-${index}`,
  isGeneratingImage: false
}));

// Assign lesson phases as post-processing (Fresh/Blend only)
if (input.mode === 'fresh' || input.mode === 'blend') {
  return assignPhasesToSlides(slides, phaseResult);
}
return slides;
```

**In `services/providers/claudeProvider.ts` -- `generateLessonSlides` method:**

Apply the SAME pattern:

1. Add import at top of file:
```typescript
import { detectPhasesInText, assignPhasesToSlides } from '../phaseDetection/phaseDetector';
```

2. Add phase detection BEFORE existing content detection (around line 700):
```typescript
const phaseResult = (input.mode === 'fresh' || input.mode === 'blend')
  ? detectPhasesInText(input.lessonText)
  : { phases: [], hasExplicitPhases: false };

if (phaseResult.hasExplicitPhases) {
  console.log(`[ClaudeProvider] Detected ${phaseResult.phases.length} lesson phases`);
}
```

3. AFTER the return statement (around line 798-802), replace with:
```typescript
const slides = data.map((item: any, index: number) => ({
  ...item,
  id: `slide-${Date.now()}-${index}`,
  isGeneratingImage: false
}));

if (input.mode === 'fresh' || input.mode === 'blend') {
  return assignPhasesToSlides(slides, phaseResult);
}
return slides;
```

IMPORTANT:
- Use `input.mode === 'fresh' || input.mode === 'blend'` explicitly (NOT `input.mode !== 'refine'`) to be safe against future mode additions
- The `phaseResult` variable must be declared in scope that is accessible both at the detection point AND at the post-processing point (function-level scope, not inside the try block if the return is outside it -- match the existing code structure)
- Do NOT modify the AI prompt or response schema -- phase assignment is purely client-side post-processing
  </action>
  <verify>
- `npx tsc --noEmit` -- project compiles with no errors
- `npm test` -- all existing tests still pass (no regressions)
- Manual verification: search both files for `assignPhasesToSlides` to confirm wiring exists
- Manual verification: search both files for the mode guard `mode === 'fresh' || input.mode === 'blend'`
  </verify>
  <done>Both Gemini and Claude providers run phase detection on full lesson plan text and assign phases to generated slides as post-processing, gated to Fresh and Blend modes only. Refine mode returns slides with no lessonPhase values.</done>
</task>

<task type="auto">
  <name>Task 2: Verify persistence and add save/load integration test</name>
  <files>services/phaseDetection/phaseDetector.test.ts</files>
  <action>
Add persistence verification tests to the existing `phaseDetector.test.ts` file (created in Plan 01). These tests verify that `lessonPhase` survives the save/load cycle using the actual `createCueFile` and `isValidCueFile` functions.

Add a new `describe('Phase label persistence')` block:

1. **Test: lessonPhase serializes in CueFile JSON** -- Create a slide with `lessonPhase: 'hook'`, call `createCueFile(...)`, serialize to JSON with `JSON.stringify`, parse back with `JSON.parse`, verify `parsed.content.slides[0].lessonPhase === 'hook'`.

2. **Test: all 6 phase values survive round-trip** -- Create 6 slides, each with a different lessonPhase value. Serialize and parse. Verify all 6 values are preserved exactly.

3. **Test: slide without lessonPhase has undefined after round-trip** -- Create a slide with no lessonPhase. Serialize and parse. Verify `parsed.content.slides[0].lessonPhase === undefined`.

4. **Test: isValidCueFile accepts file with lessonPhase slides** -- Create a CueFile with phase-tagged slides, validate with `isValidCueFile()`. Must return true.

Import from save/load services:
```typescript
import { createCueFile } from '../../services/saveService';
import { isValidCueFile } from '../../services/loadService';
```

These are integration tests that use actual save/load code paths rather than mocking, ensuring the real serialization works. No mocking needed -- `createCueFile` and `isValidCueFile` are pure functions.
  </action>
  <verify>
- `npm test -- --testPathPattern=phaseDetector` -- all tests pass including persistence tests
- `npx tsc --noEmit` -- no type errors
  </verify>
  <done>Persistence tests confirm that lessonPhase values survive the full save/load cycle using real createCueFile and isValidCueFile code paths. All 6 phase values round-trip correctly. Files without lessonPhase remain valid.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- full project compiles
2. `npm test` -- all tests pass (detection + persistence + existing tests)
3. Check geminiService.ts contains: `import { detectPhasesInText, assignPhasesToSlides }` and mode guard
4. Check claudeProvider.ts contains: `import { detectPhasesInText, assignPhasesToSlides }` and mode guard
5. Phase 65 success criteria validation:
   - SC1: Fresh/Blend modes produce slides with lessonPhase (verified by wiring + assignPhasesToSlides)
   - SC2: UK/Australian terms detected (verified by unit tests)
   - SC3: Refine mode produces no phase labels (verified by mode guard)
   - SC4: Save/load preserves labels (verified by persistence tests)
</verification>

<success_criteria>
- Both providers import and call phase detection in their generateLessonSlides methods
- Mode guard explicitly checks for fresh || blend (not !== refine)
- Phase detection runs on FULL lesson plan text before truncation
- Persistence tests prove lessonPhase survives save/load round-trip
- All 6 phase values survive serialization
- No regressions in existing test suite
</success_criteria>

<output>
After completion, create `.planning/phases/65-foundation-types-phase-detection/65-02-SUMMARY.md`
</output>
