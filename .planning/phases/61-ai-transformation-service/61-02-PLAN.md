---
phase: 61-ai-transformation-service
plan: 02
type: execute
wave: 2
depends_on: ["61-01"]
files_modified:
  - services/providers/geminiProvider.ts
  - services/providers/claudeProvider.ts
autonomous: true

must_haves:
  truths:
    - "GeminiProvider.transformForColleague processes slides in batches, produces TransformedSlide[] with expanded bullets"
    - "ClaudeProvider.transformForColleague processes slides in batches, produces TransformedSlide[] with expanded bullets"
    - "Both providers use the shared prompt module (TRANSFORMATION_SYSTEM_PROMPT, schemas, helpers)"
    - "Large decks (>20 slides) are chunked with cross-chunk context summaries"
    - "Gemini JSON is sanitized for control characters (existing pattern from condenseDeck)"
    - "Both providers handle errors using existing AIProviderError + USER_ERROR_MESSAGES pattern"
    - "Both providers return ColleagueTransformationResult with slides array and skippedCount"
  artifacts:
    - path: "services/providers/geminiProvider.ts"
      provides: "transformForColleague method implementation"
      contains: "transformForColleague"
    - path: "services/providers/claudeProvider.ts"
      provides: "transformForColleague method implementation"
      contains: "transformForColleague"
  key_links:
    - from: "services/providers/geminiProvider.ts"
      to: "services/prompts/transformationPrompts.ts"
      via: "imports shared prompts, schemas, and helpers"
      pattern: "import.*from.*transformationPrompts"
    - from: "services/providers/claudeProvider.ts"
      to: "services/prompts/transformationPrompts.ts"
      via: "imports shared prompts, schemas, and helpers"
      pattern: "import.*from.*transformationPrompts"
    - from: "services/providers/geminiProvider.ts"
      to: "services/aiProvider.ts"
      via: "uses TransformedSlide and ColleagueTransformationResult types"
      pattern: "ColleagueTransformationResult"
    - from: "services/providers/claudeProvider.ts"
      to: "services/aiProvider.ts"
      via: "uses TransformedSlide and ColleagueTransformationResult types"
      pattern: "ColleagueTransformationResult"
---

<objective>
Implement `transformForColleague` in both Gemini and Claude providers, completing the AI transformation service.

Purpose: Wire the prompt module from Plan 01 into both providers so either can transform teleprompter scripts into colleague-deliverable bullets. This is the last step before the service is callable from UI code (Phase 63).

Output: Working `transformForColleague` method on both providers, callable via `AIProviderInterface`.
</objective>

<execution_context>
@/Users/ricky/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ricky/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/61-ai-transformation-service/61-CONTEXT.md
@.planning/phases/61-ai-transformation-service/61-RESEARCH.md
@.planning/phases/61-ai-transformation-service/61-01-SUMMARY.md
@services/aiProvider.ts (TransformedSlide, ColleagueTransformationResult, AIProviderError, USER_ERROR_MESSAGES)
@services/prompts/transformationPrompts.ts (all exports from Plan 01)
@services/providers/geminiProvider.ts (condenseDeck method as pattern reference)
@services/providers/claudeProvider.ts (condenseDeck method as pattern reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement transformForColleague in GeminiProvider</name>
  <files>services/providers/geminiProvider.ts</files>
  <action>
Add `transformForColleague` method to GeminiProvider class. Follow the exact pattern from `condenseDeck` (lines ~479-571).

**Imports to add at top of file:**
```typescript
import {
  TRANSFORMATION_SYSTEM_PROMPT,
  buildTransformationUserPrompt,
  buildTransformationContext,
  filterTransformableSlides,
  chunkSlides,
  buildChunkSummary,
  TRANSFORMATION_RESPONSE_SCHEMA,
} from '../prompts/transformationPrompts';
import { ColleagueTransformationResult, TransformedSlide } from '../aiProvider';
```

(Note: TransformedSlide may already be importable from aiProvider if the existing import block already pulls types from there -- check existing imports and add to the existing import statement.)

**Method implementation:**

```typescript
async transformForColleague(
  slides: Slide[],
  deckVerbosity: VerbosityLevel,
  gradeLevel: string
): Promise<ColleagueTransformationResult> {
  try {
    const ai = new GoogleGenAI({ apiKey: this.apiKey });
    const transformable = filterTransformableSlides(slides, deckVerbosity);
    const skippedCount = slides.length - transformable.length;

    if (transformable.length === 0) {
      return { slides: [], skippedCount };
    }

    const chunks = chunkSlides(transformable);
    const allTransformed: TransformedSlide[] = [];

    for (let i = 0; i < chunks.length; i++) {
      const chunk = chunks[i];
      const context = buildTransformationContext(chunk);
      const userPrompt = buildTransformationUserPrompt(gradeLevel);

      // Include summary of prior chunks for narrative coherence
      const priorSummary = i > 0 ? buildChunkSummary(allTransformed) : '';
      const fullPrompt = priorSummary
        ? `${userPrompt}\n\nPREVIOUS SLIDES SUMMARY (for coherence -- do NOT repeat this content):\n${priorSummary}\n\n${context}`
        : `${userPrompt}\n\n${context}`;

      const response = await ai.models.generateContent({
        model: this.model,
        contents: fullPrompt,
        config: {
          systemInstruction: TRANSFORMATION_SYSTEM_PROMPT,
          responseMimeType: 'application/json',
          responseSchema: TRANSFORMATION_RESPONSE_SCHEMA,
          temperature: 0.7,
          maxOutputTokens: 8192,
        },
      });

      const rawText = response.text || '{}';

      // Sanitize control characters inside JSON string values
      // (Gemini sometimes emits raw newlines/tabs) -- same pattern as condenseDeck
      let sanitized = '';
      let inStr = false;
      let esc = false;
      for (let j = 0; j < rawText.length; j++) {
        const ch = rawText[j];
        if (esc) { sanitized += ch; esc = false; continue; }
        if (ch === '\\' && inStr) { sanitized += ch; esc = true; continue; }
        if (ch === '"') { inStr = !inStr; sanitized += ch; continue; }
        if (inStr && ch.charCodeAt(0) < 32) {
          if (ch === '\n') sanitized += '\\n';
          else if (ch === '\r') sanitized += '\\r';
          else if (ch === '\t') sanitized += '\\t';
          continue;
        }
        sanitized += ch;
      }

      const parsed = JSON.parse(sanitized);
      const chunkSlides = parsed.slides || [];
      allTransformed.push(...chunkSlides);
    }

    return { slides: allTransformed, skippedCount };
  } catch (error) {
    console.error('[GeminiProvider] transformForColleague error:', error);
    throw this.wrapError(error);
  }
}
```

Key details:
- Temperature 0.7 (creative writing, not analytical) -- this is intentional; the AI is composing delivery text, not analyzing content
- maxOutputTokens 8192 for large slide batches
- JSON sanitization uses the exact same inline pattern from condenseDeck (the research suggested extracting it, but follow existing patterns -- do NOT refactor into a shared utility in this plan)
- Chunking iterates sequentially with `buildChunkSummary` providing cross-chunk context
- Error handling uses existing `this.wrapError(error)` pattern from GeminiProvider
  </action>
  <verify>
- `npx tsc --noEmit` passes
- `grep "transformForColleague" services/providers/geminiProvider.ts` shows the method
- `grep "TRANSFORMATION_SYSTEM_PROMPT" services/providers/geminiProvider.ts` confirms prompt import
  </verify>
  <done>
GeminiProvider has a working `transformForColleague` method that filters slides, resolves verbosity, chunks large decks, calls Gemini with structured output schema, sanitizes JSON, and returns ColleagueTransformationResult.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement transformForColleague in ClaudeProvider</name>
  <files>services/providers/claudeProvider.ts</files>
  <action>
Add `transformForColleague` method to ClaudeProvider class. Follow the exact pattern from `condenseDeck` (lines ~1806-1912).

**Imports to add at top of file:**
```typescript
import {
  TRANSFORMATION_SYSTEM_PROMPT,
  buildTransformationUserPrompt,
  buildTransformationContext,
  filterTransformableSlides,
  chunkSlides,
  buildChunkSummary,
  TRANSFORMATION_TOOL,
} from '../prompts/transformationPrompts';
import { ColleagueTransformationResult, TransformedSlide } from '../aiProvider';
```

(Same note: check existing imports from aiProvider and add to the existing import block rather than creating a duplicate.)

**Method implementation:**

```typescript
async transformForColleague(
  slides: Slide[],
  deckVerbosity: VerbosityLevel,
  gradeLevel: string
): Promise<ColleagueTransformationResult> {
  try {
    const transformable = filterTransformableSlides(slides, deckVerbosity);
    const skippedCount = slides.length - transformable.length;

    if (transformable.length === 0) {
      return { slides: [], skippedCount };
    }

    const chunks = chunkSlides(transformable);
    const allTransformed: TransformedSlide[] = [];

    for (let i = 0; i < chunks.length; i++) {
      const chunk = chunks[i];
      const context = buildTransformationContext(chunk);
      const userPrompt = buildTransformationUserPrompt(gradeLevel);

      // Include summary of prior chunks for narrative coherence
      const priorSummary = i > 0 ? buildChunkSummary(allTransformed) : '';
      const messageText = priorSummary
        ? `${userPrompt}\n\nPREVIOUS SLIDES SUMMARY (for coherence -- do NOT repeat this content):\n${priorSummary}\n\n${context}`
        : `${userPrompt}\n\n${context}`;

      const contentArray: any[] = [
        { type: 'text', text: messageText }
      ];

      const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': this.apiKey,
          'anthropic-version': '2023-06-01',
          'anthropic-dangerous-direct-browser-access': 'true',
        },
        body: JSON.stringify({
          model: this.model,
          max_tokens: 8192,
          system: TRANSFORMATION_SYSTEM_PROMPT,
          tools: [TRANSFORMATION_TOOL],
          tool_choice: { type: 'tool', name: 'transform_for_colleague' },
          messages: [{ role: 'user', content: contentArray }],
        }),
      });

      if (!response.ok) {
        const errorText = await response.text().catch(() => 'Unknown error');
        throw new AIProviderError(
          USER_ERROR_MESSAGES[this.getErrorCode(response.status)],
          this.getErrorCode(response.status),
          errorText
        );
      }

      const data = await response.json();

      // Extract tool_use result
      const toolUse = data.content?.find((c: any) => c.type === 'tool_use');
      const result = toolUse?.input;
      if (!result) {
        throw new AIProviderError(
          USER_ERROR_MESSAGES.PARSE_ERROR,
          'PARSE_ERROR',
          'No tool result in transformation response'
        );
      }

      const chunkSlides = result.slides || [];
      allTransformed.push(...chunkSlides);
    }

    return { slides: allTransformed, skippedCount };
  } catch (error) {
    if (error instanceof AIProviderError) {
      throw error;
    }
    console.error('[ClaudeProvider] transformForColleague error:', error);
    throw new AIProviderError(
      USER_ERROR_MESSAGES.UNKNOWN_ERROR,
      'UNKNOWN_ERROR',
      error
    );
  }
}
```

Key details:
- Uses `tool_choice: { type: 'tool', name: 'transform_for_colleague' }` to force structured output (same pattern as condenseDeck)
- Claude does NOT need JSON sanitization (unlike Gemini) -- the tool_use result is already parsed JSON
- Error handling re-throws AIProviderError and wraps other errors (same pattern as condenseDeck in ClaudeProvider)
- Sequential chunking with cross-chunk summary context, identical to Gemini implementation
- The `anthropic-dangerous-direct-browser-access` header is required for browser CORS (existing pattern)
  </action>
  <verify>
- `npx tsc --noEmit` passes
- `grep "transformForColleague" services/providers/claudeProvider.ts` shows the method
- `grep "TRANSFORMATION_TOOL" services/providers/claudeProvider.ts` confirms tool import
- `npx jest --passWithNoTests` -- existing tests still pass
  </verify>
  <done>
Both Gemini and Claude providers implement `transformForColleague`, completing the AI Transformation Service. Either provider can be called via `AIProviderInterface.transformForColleague(slides, deckVerbosity, gradeLevel)` and will return `ColleagueTransformationResult` with expanded talking-point bullets for each slide that has teleprompter content.
  </done>
</task>

</tasks>

<verification>
- `npx tsc --noEmit` passes with no errors
- `npx jest --passWithNoTests` -- all existing tests pass
- Both providers export `transformForColleague` matching the interface signature
- GeminiProvider uses `responseSchema` for structured output, ClaudeProvider uses `tool_choice`
- Both providers import from the shared prompt module (no duplicated prompts)
- Both handle chunking for decks > 20 slides
- Error handling follows existing AIProviderError pattern
</verification>

<success_criteria>
The complete AI transformation service is functional: given a deck of slides and a verbosity setting, either provider can produce expanded talking-point bullets suitable for a colleague to deliver the lesson. The service correctly resolves verbosity cache, filters empty slides, chunks large decks, and returns structured TransformedSlide[] output.
</success_criteria>

<output>
After completion, create `.planning/phases/61-ai-transformation-service/61-02-SUMMARY.md`
</output>
