---
phase: 60-deck-condensation
plan: 02
type: execute
wave: 2
depends_on: ["60-01"]
files_modified:
  - services/providers/claudeProvider.ts
autonomous: true

must_haves:
  truths:
    - "Claude provider has condenseDeck method matching AIProviderInterface"
    - "Claude provider makeDeckCohesive is removed"
    - "condenseDeck uses tool_choice with propose_condensation tool"
    - "Multimodal lesson plan images are sent as base64 image blocks"
  artifacts:
    - path: "services/providers/claudeProvider.ts"
      provides: "condenseDeck implementation for Claude/Anthropic API"
      contains: "async condenseDeck"
  key_links:
    - from: "services/providers/claudeProvider.ts"
      to: "services/prompts/condensationPrompts.ts"
      via: "import prompts and tool schema"
      pattern: "import.*from.*condensationPrompts"
    - from: "services/providers/claudeProvider.ts"
      to: "services/aiProvider.ts"
      via: "import CondensationResult type"
      pattern: "import.*CondensationResult"
---

<objective>
Implement condenseDeck in the Claude provider, matching the Gemini implementation from Plan 01. Also remove the old makeDeckCohesive method.

Purpose: Ensures both AI providers support deck condensation, maintaining the dual-provider parity established across all features.

Output: Working condenseDeck on Claude provider. Combined with Plan 01, both providers are ready for UI integration in Plan 03.
</objective>

<execution_context>
@/Users/ricky/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ricky/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/60-deck-condensation/60-01-SUMMARY.md
@services/providers/claudeProvider.ts
@services/prompts/condensationPrompts.ts
@services/aiProvider.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement condenseDeck in Claude provider</name>
  <files>services/providers/claudeProvider.ts</files>
  <action>
  1. Update imports at top of file:
     - REMOVE: `COHESION_SYSTEM_PROMPT`, `buildCohesionUserPrompt`, `COHESION_TOOL` from cohesionPrompts
     - ADD: `CONDENSATION_SYSTEM_PROMPT`, `buildCondensationUserPrompt`, `buildCondensationContext`, `CONDENSATION_TOOL` from `../prompts/condensationPrompts`
     - Keep `buildDeckContextForCohesion` import from cohesionPrompts (still used by gap analysis and gap slide generation)
     - Update aiProvider imports: remove `CohesionResult`, add `CondensationResult`

  2. REPLACE the `makeDeckCohesive` method (around line 1805) with `condenseDeck`. Follow the EXACT pattern of the existing `analyzeGaps` method (around line 1893):

  ```typescript
  async condenseDeck(
    slides: Slide[],
    lessonPlanText: string,
    lessonPlanImages: string[],
    gradeLevel: string
  ): Promise<CondensationResult> {
    try {
      const context = buildCondensationContext(slides, lessonPlanText);
      const userPrompt = buildCondensationUserPrompt(gradeLevel);

      // Build multimodal content array: text + optional page images
      const contentArray: any[] = [
        { type: 'text', text: userPrompt + '\n\n' + context }
      ];

      // Append up to 5 lesson plan page images for multimodal analysis
      if (lessonPlanImages.length > 0) {
        const limitedImages = lessonPlanImages.slice(0, 5);
        for (const img of limitedImages) {
          contentArray.push({
            type: 'image',
            source: { type: 'base64', media_type: 'image/jpeg', data: img }
          });
        }
      }

      const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': this.apiKey,
          'anthropic-version': '2023-06-01',
          'anthropic-dangerous-direct-browser-access': 'true',
        },
        body: JSON.stringify({
          model: this.model,
          max_tokens: 8192,
          system: CONDENSATION_SYSTEM_PROMPT,
          tools: [CONDENSATION_TOOL],
          tool_choice: { type: 'tool', name: 'propose_condensation' },
          messages: [{ role: 'user', content: contentArray }]
        })
      });

      if (!response.ok) {
        const errorText = await response.text().catch(() => 'Unknown error');
        throw new AIProviderError(
          USER_ERROR_MESSAGES[this.getErrorCode(response.status)],
          this.getErrorCode(response.status),
          errorText
        );
      }

      const data = await response.json();

      // Extract tool_use result
      const toolUse = data.content?.find((c: any) => c.type === 'tool_use');
      const result = toolUse?.input;
      if (!result) {
        throw new AIProviderError(
          USER_ERROR_MESSAGES.PARSE_ERROR,
          'PARSE_ERROR',
          'No tool result in condensation response'
        );
      }

      // Enrich actions (same post-processing as Gemini)
      const actions = (result.actions || []).map((action: any) => {
        const slide = slides[action.slideIndex];
        if (!slide) return null;
        return {
          slideIndex: action.slideIndex,
          action: action.action || 'keep',
          reason: action.reason || '',
          proposedTitle: action.proposedTitle || undefined,
          proposedContent: action.proposedContent || undefined,
          proposedSpeakerNotes: action.proposedSpeakerNotes || undefined,
          mergeWithSlideIndices: action.mergeWithSlideIndices || undefined,
          mergedTitle: action.mergedTitle || undefined,
          mergedContent: action.mergedContent || undefined,
          mergedSpeakerNotes: action.mergedSpeakerNotes || undefined,
        };
      }).filter(Boolean);

      return {
        actions,
        summary: result.summary || 'Condensation analysis complete',
        originalSlideCount: slides.length,
        proposedSlideCount: result.proposedSlideCount ?? slides.length,
        essentialTopicsPreserved: result.essentialTopicsPreserved || []
      };
    } catch (error) {
      if (error instanceof AIProviderError) {
        throw error;
      }
      console.error('[ClaudeProvider] condenseDeck error:', error);
      throw new AIProviderError(
        USER_ERROR_MESSAGES.UNKNOWN_ERROR,
        'UNKNOWN_ERROR',
        error
      );
    }
  }
  ```

  3. Delete the entire old `makeDeckCohesive` method.
  </action>
  <verify>
  1. `npx tsc --noEmit 2>&1 | grep claudeProvider` — no errors in claudeProvider.ts
  2. `grep 'makeDeckCohesive' services/providers/claudeProvider.ts` — returns nothing
  3. `grep 'condenseDeck' services/providers/claudeProvider.ts` — returns the method
  4. `grep 'propose_condensation' services/providers/claudeProvider.ts` — confirms tool_choice name
  </verify>
  <done>
  Claude provider has condenseDeck method with multimodal support, tool_choice forcing, and error handling matching the established pattern. Old makeDeckCohesive is removed. Both providers now implement condenseDeck.
  </done>
</task>

<task type="auto">
  <name>Task 2: Verify dual-provider compilation and cohesion cleanup</name>
  <files>services/providers/claudeProvider.ts</files>
  <action>
  1. Run `npx tsc --noEmit` and verify ZERO errors in both provider files (geminiProvider.ts from Plan 01, claudeProvider.ts from this plan).

  2. Verify no remaining references to old cohesion types in either provider:
     - `grep -rn 'CohesionResult\|CohesionChange\|makeDeckCohesive' services/providers/` should return nothing
     - `grep -rn 'COHESION_SYSTEM_PROMPT\|COHESION_TOOL\|COHESION_RESPONSE_SCHEMA\|buildCohesionUserPrompt' services/providers/` should return nothing

  3. Verify `buildDeckContextForCohesion` is still imported in both providers (used by gap analysis):
     - `grep 'buildDeckContextForCohesion' services/providers/geminiProvider.ts` — should find import
     - `grep 'buildDeckContextForCohesion' services/providers/claudeProvider.ts` — should find import

  If any stray references remain, clean them up.
  </action>
  <verify>
  `npx tsc --noEmit 2>&1 | grep -c 'error'` returns 0 for both provider files. All old cohesion references are gone from providers. buildDeckContextForCohesion still used by gap analysis code.
  </verify>
  <done>
  Both Gemini and Claude providers compile cleanly with condenseDeck. No residual cohesion references in provider layer. Gap analysis code unaffected.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit 2>&1 | grep -E 'geminiProvider|claudeProvider'` — no errors in either provider
2. `grep -rn 'makeDeckCohesive' services/` — returns nothing anywhere in services/
3. `grep 'condenseDeck' services/providers/claudeProvider.ts services/providers/geminiProvider.ts` — both have the method
4. `grep 'buildDeckContextForCohesion' services/providers/*.ts` — still imported in both (for gap analysis)
</verification>

<success_criteria>
- Claude provider condenseDeck method matches interface signature and follows analyzeGaps pattern
- Multimodal lesson plan images sent as base64 image blocks (up to 5)
- tool_choice forces propose_condensation tool
- Error handling follows established AIProviderError pattern
- Old makeDeckCohesive completely removed from Claude provider
- Both providers compile clean with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/60-deck-condensation/60-02-SUMMARY.md`
</output>
