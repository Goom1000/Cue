---
phase: 54-quality-assurance
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - services/contentPreservation/leakage.test.ts
  - services/prompts/teachableMomentRules.test.ts
autonomous: true

must_haves:
  truths:
    - "No answer text appears in problem bullets during detection"
    - "No answer text appears in scaffolding prompts"
    - "Each scaffolding question is under 20 words"
  artifacts:
    - path: "services/contentPreservation/leakage.test.ts"
      provides: "Answer leakage detection tests"
      min_lines: 100
    - path: "services/prompts/teachableMomentRules.test.ts"
      provides: "Scaffolding word count validation tests"
      min_lines: 80
  key_links:
    - from: "services/contentPreservation/leakage.test.ts"
      to: "services/contentPreservation/detector.ts"
      via: "import detectTeachableMoments"
      pattern: "import.*detectTeachableMoments.*from"
    - from: "services/prompts/teachableMomentRules.test.ts"
      to: "services/prompts/teachableMomentRules.ts"
      via: "import getTeachableMomentRules"
      pattern: "import.*getTeachableMomentRules.*from"
---

<objective>
Validate QUA-01: No answer leakage in problem statements or scaffolding prompts

Purpose: Ensure the delay answer reveal feature never accidentally exposes answers before the teacher is ready to reveal them. This is critical for the core user value - giving students thinking time.

Output: Two test files validating leakage prevention and word count constraints
</objective>

<execution_context>
@/Users/ricky/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ricky/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/54-quality-assurance/54-RESEARCH.md

@services/contentPreservation/detector.ts
@services/contentPreservation/detector.test.ts
@services/prompts/teachableMomentRules.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create answer leakage detection tests</name>
  <files>services/contentPreservation/leakage.test.ts</files>
  <action>
Create a new test file `leakage.test.ts` that validates QUA-01 answer leakage prevention.

Use the canary string methodology from the research:
1. Define test cases with unique "canary" strings as answers that are easy to detect
2. Run detection on input containing problem + canary answer
3. Verify the canary answer does NOT appear in:
   - The problem.text field of detected moments
   - The scaffolding rules output from getTeachableMomentRules

Test structure:
```typescript
import { detectTeachableMoments } from './detector';
import { getTeachableMomentRules } from '../prompts/teachableMomentRules';

describe('QUA-01: Answer Leakage Prevention', () => {
  const LEAKAGE_TEST_CASES = [
    {
      name: 'math problem',
      input: 'What is 3 + 4? Answer: CANARY_SEVEN_42',
      canary: 'CANARY_SEVEN_42',
      category: 'math'
    },
    {
      name: 'vocabulary definition',
      input: 'Define: Photosynthesis means CANARY_PLANT_PROCESS_99',
      canary: 'CANARY_PLANT_PROCESS_99',
      category: 'vocabulary'
    },
    {
      name: 'comprehension answer',
      input: 'Why did the character leave? Answer: Because CANARY_REASON_123',
      canary: 'CANARY_REASON_123',
      category: 'comprehension'
    },
    {
      name: 'science explanation',
      input: 'What causes rust? Answer: CANARY_OXIDATION_77',
      canary: 'CANARY_OXIDATION_77',
      category: 'science'
    }
  ];

  describe('Problem bullet leakage', () => {
    LEAKAGE_TEST_CASES.forEach(({ name, input, canary }) => {
      it(`does not leak answer in problem bullet for ${name}`, () => {
        const moments = detectTeachableMoments(input);
        expect(moments.length).toBeGreaterThan(0);

        // Problem text must NOT contain the canary answer
        moments.forEach(m => {
          expect(m.problem.text).not.toContain(canary);
        });
      });
    });
  });

  describe('Scaffolding prompt leakage', () => {
    LEAKAGE_TEST_CASES.forEach(({ name, input, canary }) => {
      it(`scaffolding does not reveal answer for ${name}`, () => {
        const moments = detectTeachableMoments(input);
        const rules = getTeachableMomentRules(moments);

        // Scaffolding rules must NOT contain the canary answer
        expect(rules).not.toContain(canary);
      });
    });
  });

  describe('Answer correctly captured', () => {
    LEAKAGE_TEST_CASES.forEach(({ name, input, canary }) => {
      it(`answer is correctly detected for ${name}`, () => {
        const moments = detectTeachableMoments(input);
        const momentsWithAnswers = moments.filter(m => m.answer !== null);

        // At least one moment should have the answer captured
        const hasCanary = momentsWithAnswers.some(m =>
          m.answer?.text.includes(canary)
        );
        expect(hasCanary).toBe(true);
      });
    });
  });
});
```

Include additional edge case tests:
- Multi-part answers (e.g., "Answer: First, X. Second, Y.")
- Answers with special characters
- Very short answers (single digit, single word)
- Answers that look like problem text (e.g., numbers in both)
  </action>
  <verify>
Run: `npm test -- leakage.test.ts`

Expected: All tests pass. Specifically:
- 4+ "does not leak answer in problem bullet" tests pass
- 4+ "scaffolding does not reveal answer" tests pass
- 4+ "answer is correctly detected" tests pass
  </verify>
  <done>
leakage.test.ts exists with 12+ test cases covering math, vocabulary, comprehension, and science categories. All tests pass confirming no answer leakage.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create scaffolding word count validation tests</name>
  <files>services/prompts/teachableMomentRules.test.ts</files>
  <action>
Create a new test file `teachableMomentRules.test.ts` that validates scaffolding word count constraints.

The Phase 53 requirement is that each scaffolding question must be under 20 words for verbal deliverability.

Test approach:
1. Generate scaffolding rules for each content category
2. Extract individual questions (split by [PAUSE] markers)
3. Count words in each question
4. Verify each is under 20 words

```typescript
import { getTeachableMomentRules } from './teachableMomentRules';
import { TeachableMoment, ContentCategory } from '../contentPreservation/types';

describe('Scaffolding Word Count Validation', () => {
  // Helper to create mock teachable moments
  const createMockMoment = (category: ContentCategory): TeachableMoment => ({
    problem: {
      type: 'question',
      text: 'What is the answer?',
      confidence: 'high',
      detectionMethod: 'punctuation',
      startIndex: 0,
      endIndex: 20
    },
    answer: {
      type: 'answer',
      text: 'The answer',
      confidence: 'high',
      detectionMethod: 'context',
      startIndex: 30,
      endIndex: 40
    },
    contentCategory: category,
    confidence: 'high',
    proximityChars: 10
  });

  // Helper to count words in text
  const countWords = (text: string): number => {
    return text.split(/\s+/).filter(w => w.length > 0).length;
  };

  // Helper to extract scaffolding questions from rules
  const extractQuestions = (rules: string): string[] => {
    // Find content between quotes that ends with ?
    // Also extract example questions in template
    const questionPattern = /"([^"]+\?)"/g;
    const questions: string[] = [];
    let match;
    while ((match = questionPattern.exec(rules)) !== null) {
      questions.push(match[1]);
    }
    return questions;
  };

  const CONTENT_CATEGORIES: ContentCategory[] = [
    'math',
    'vocabulary',
    'comprehension',
    'science',
    'general'
  ];

  describe('Word count per scaffolding question (<20 words)', () => {
    CONTENT_CATEGORIES.forEach(category => {
      it(`${category} scaffolding questions are each under 20 words`, () => {
        const moment = createMockMoment(category);
        const rules = getTeachableMomentRules([moment]);

        // Rules should contain the category-specific template
        expect(rules.length).toBeGreaterThan(0);

        // Extract example questions from the template
        const questions = extractQuestions(rules);

        questions.forEach(question => {
          const wordCount = countWords(question);
          expect(wordCount).toBeLessThanOrEqual(20);
        });
      });
    });
  });

  describe('Template structure validation', () => {
    it('includes [PAUSE] markers for wait time', () => {
      const moment = createMockMoment('math');
      const rules = getTeachableMomentRules([moment]);

      expect(rules).toContain('[PAUSE]');
    });

    it('includes verbal deliverability guidance', () => {
      const moment = createMockMoment('math');
      const rules = getTeachableMomentRules([moment]);

      expect(rules).toContain('under 20 words');
    });

    it('returns empty string when no moments provided', () => {
      const rules = getTeachableMomentRules([]);
      expect(rules).toBe('');
    });
  });

  describe('Category-specific templates included', () => {
    it('includes math template for math moments', () => {
      const rules = getTeachableMomentRules([createMockMoment('math')]);
      expect(rules).toContain('MATH PROBLEM SCAFFOLDING');
    });

    it('includes vocabulary template for vocabulary moments', () => {
      const rules = getTeachableMomentRules([createMockMoment('vocabulary')]);
      expect(rules).toContain('VOCABULARY SCAFFOLDING');
    });

    it('includes comprehension template for comprehension moments', () => {
      const rules = getTeachableMomentRules([createMockMoment('comprehension')]);
      expect(rules).toContain('COMPREHENSION SCAFFOLDING');
    });

    it('includes science template for science moments', () => {
      const rules = getTeachableMomentRules([createMockMoment('science')]);
      expect(rules).toContain('SCIENCE SCAFFOLDING');
    });

    it('includes general template for general moments', () => {
      const rules = getTeachableMomentRules([createMockMoment('general')]);
      expect(rules).toContain('GENERAL SCAFFOLDING');
    });
  });
});
```

This validates:
- Each example question in templates is under 20 words
- [PAUSE] markers are present
- Category-specific templates are included when that category is detected
- Empty input returns empty string (no cluttering)
  </action>
  <verify>
Run: `npm test -- teachableMomentRules.test.ts`

Expected: All tests pass:
- 5 category word count tests pass
- 3 template structure tests pass
- 5 category-specific template tests pass
  </verify>
  <done>
teachableMomentRules.test.ts exists with 13+ test cases. All scaffolding example questions are confirmed to be under 20 words. Template structure is validated.
  </done>
</task>

</tasks>

<verification>
Run the full test suite for the new test files:

```bash
npm test -- leakage.test.ts teachableMomentRules.test.ts
```

All tests should pass. No flaky tests (run 3 times to confirm determinism).
</verification>

<success_criteria>
1. leakage.test.ts has 12+ test cases covering all 4 content categories
2. teachableMomentRules.test.ts has 13+ test cases
3. All tests pass on every run (deterministic)
4. No answer text leaks into problem bullets (canary detection)
5. No answer text leaks into scaffolding prompts
6. All scaffolding questions are under 20 words
</success_criteria>

<output>
After completion, create `.planning/phases/54-quality-assurance/54-01-SUMMARY.md`
</output>
