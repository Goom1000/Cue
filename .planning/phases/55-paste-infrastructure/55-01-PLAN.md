---
phase: 55-paste-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - types.ts
  - hooks/usePaste.ts
autonomous: true

must_haves:
  truths:
    - "Slide type includes source provenance field"
    - "Paste events are captured at window level"
    - "HTML and plain text clipboard data can be extracted"
  artifacts:
    - path: "types.ts"
      provides: "SlideSource type and source field on Slide"
      contains: "source?: SlideSource"
    - path: "hooks/usePaste.ts"
      provides: "usePaste hook for clipboard event handling"
      exports: ["usePaste", "PasteResult"]
  key_links:
    - from: "hooks/usePaste.ts"
      to: "window paste event"
      via: "addEventListener('paste')"
      pattern: "addEventListener.*paste"
---

<objective>
Create the foundational types and paste event capture hook for clipboard paste functionality.

Purpose: Establish the data structures and event handling that all paste features will build upon.
Output: Updated types.ts with provenance fields, new usePaste.ts hook that captures paste events.
</objective>

<execution_context>
@/Users/ricky/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ricky/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/55-paste-infrastructure/55-CONTEXT.md
@.planning/research/v4.0-SUMMARY-clipboard-cohesion.md

@types.ts
@hooks/useDragDrop.ts (pattern reference for window-level event handling)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add slide provenance types</name>
  <files>types.ts</files>
  <action>
Add a `SlideSource` type to track where slide content originated from. This is needed for future Phase 58 (Cohesion) to know which slides are safe to modify vs user-edited.

Add near the top of types.ts (after the Slide interface):

```typescript
// Slide content provenance for cohesion tracking (Phase 55+)
export type SlideSource =
  | { type: 'ai-generated' }           // Created by initial generation
  | { type: 'pasted'; pastedAt: string } // Pasted from clipboard (ISO 8601)
  | { type: 'manual' };                // User-created or manually edited
```

Update the Slide interface to include an optional `source` field:

```typescript
// In Slide interface, add after contributions/challengePrompt:
source?: SlideSource;
```

This field is optional for backward compatibility with existing slides (they'll be treated as ai-generated by default).

Do NOT add any imports. The type is self-contained.
  </action>
  <verify>Run `npm run build` - should compile without errors. Grep for "SlideSource" in types.ts to confirm export exists.</verify>
  <done>SlideSource type exported from types.ts, Slide interface has optional source field</done>
</task>

<task type="auto">
  <name>Task 2: Create usePaste hook</name>
  <files>hooks/usePaste.ts</files>
  <action>
Create a new hook that captures window-level paste events, following the useDragDrop.ts pattern.

Create `hooks/usePaste.ts`:

```typescript
import { useEffect, useCallback, useRef } from 'react';

/**
 * Result of a paste operation with extracted content
 */
export interface PasteResult {
  /** HTML content from clipboard (PowerPoint copies as HTML) */
  html: string | null;
  /** Plain text fallback */
  text: string | null;
  /** Image blob if present (for Phase 57) */
  imageBlob: Blob | null;
  /** Whether this looks like rich content (not just plain text) */
  isRichContent: boolean;
}

/**
 * Options for paste handling
 */
export interface UsePasteOptions {
  /** Callback when paste is detected with rich content (HTML or image) */
  onPaste: (result: PasteResult) => void;
  /** Whether to listen for paste events (default: true) */
  enabled?: boolean;
  /** Whether to prevent default paste behavior for rich content (default: true) */
  preventDefault?: boolean;
}

/**
 * Hook for window-level paste event handling.
 *
 * Captures Ctrl+V/Cmd+V paste events and extracts clipboard content.
 * Only triggers onPaste for rich content (HTML/images) - plain text
 * in form fields is handled normally.
 *
 * Per CONTEXT.md: "Content type detection - rich HTML content (from PowerPoint)
 * creates new slide; plain text pastes into active text field normally"
 *
 * @example
 * usePaste({
 *   onPaste: (result) => handlePasteSlide(result),
 *   enabled: appState === AppState.EDITING,
 * });
 */
export function usePaste({
  onPaste,
  enabled = true,
  preventDefault = true,
}: UsePasteOptions): void {
  // Use ref to avoid stale closure in event handler
  const onPasteRef = useRef(onPaste);
  onPasteRef.current = onPaste;

  const handlePaste = useCallback((e: ClipboardEvent) => {
    // Skip if disabled
    if (!enabled) return;

    // Skip if user is typing in an input/textarea (let normal paste work)
    const activeElement = document.activeElement;
    const isInTextField = activeElement instanceof HTMLInputElement ||
      activeElement instanceof HTMLTextAreaElement ||
      activeElement?.getAttribute('contenteditable') === 'true' ||
      activeElement?.getAttribute('contenteditable') === 'plaintext-only';

    // Get clipboard data
    const clipboardData = e.clipboardData;
    if (!clipboardData) return;

    // Extract content
    const html = clipboardData.getData('text/html') || null;
    const text = clipboardData.getData('text/plain') || null;

    // Check for image
    let imageBlob: Blob | null = null;
    const items = clipboardData.items;
    for (let i = 0; i < items.length; i++) {
      if (items[i].type.startsWith('image/')) {
        imageBlob = items[i].getAsFile();
        break;
      }
    }

    // Determine if this is "rich" content vs plain text
    // Rich = has HTML (from PPT/Word/web) or has image
    const isRichContent = !!html || !!imageBlob;

    // If in text field and NOT rich content, let browser handle normally
    if (isInTextField && !isRichContent) {
      return; // Don't prevent default, don't call onPaste
    }

    // If in text field WITH rich content, we should still allow paste
    // but this is edge case - for now, also skip (user expects to paste into field)
    if (isInTextField) {
      return;
    }

    // Rich content outside text field -> create slide
    if (isRichContent) {
      if (preventDefault) {
        e.preventDefault();
      }

      onPasteRef.current({
        html,
        text,
        imageBlob,
        isRichContent,
      });
    }
  }, [enabled, preventDefault]);

  useEffect(() => {
    if (!enabled) return;

    window.addEventListener('paste', handlePaste);

    return () => {
      window.removeEventListener('paste', handlePaste);
    };
  }, [enabled, handlePaste]);
}

export default usePaste;
```

Key design decisions:
- Uses ref pattern (from useDragDrop.ts) to avoid stale closures
- Detects text fields and skips paste handling to allow normal editing
- Only triggers for rich content (HTML or images)
- Returns structured PasteResult for handler to process
- Supports enabled flag for conditional listening
  </action>
  <verify>
Run `npm run build` - should compile without errors.
Verify hook exports: `grep -n "export.*usePaste\|export.*PasteResult" hooks/usePaste.ts`
  </verify>
  <done>usePaste hook exists in hooks/usePaste.ts, exports usePaste function and PasteResult interface</done>
</task>

</tasks>

<verification>
1. `npm run build` completes without TypeScript errors
2. `grep "SlideSource" types.ts` shows type definition
3. `grep "source\?: SlideSource" types.ts` shows field in Slide interface
4. `grep "export.*usePaste" hooks/usePaste.ts` shows hook export
5. `grep "export interface PasteResult" hooks/usePaste.ts` shows interface export
</verification>

<success_criteria>
- SlideSource type added to types.ts with three variants (ai-generated, pasted, manual)
- Slide interface has optional source field
- usePaste hook created following useDragDrop pattern
- Hook extracts HTML, text, and image data from clipboard
- Hook skips paste when user is in text field
- Build passes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/55-paste-infrastructure/55-01-SUMMARY.md`
</output>
