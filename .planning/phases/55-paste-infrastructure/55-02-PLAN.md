---
phase: 55-paste-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["55-01"]
files_modified:
  - App.tsx
  - components/EditorToolbar.tsx
autonomous: true

must_haves:
  truths:
    - "User can press Cmd+V to paste a slide"
    - "Pasted slide appears after selected slide"
    - "Loading indicator shows during paste"
    - "Paste Slide button available in toolbar"
  artifacts:
    - path: "App.tsx"
      provides: "handlePasteSlide handler and usePaste integration"
      contains: "handlePasteSlide"
    - path: "components/EditorToolbar.tsx"
      provides: "Paste Slide button in editor toolbar"
      contains: "Paste Slide"
  key_links:
    - from: "App.tsx"
      to: "hooks/usePaste.ts"
      via: "usePaste hook call"
      pattern: "usePaste\\("
    - from: "App.tsx handlePasteSlide"
      to: "setSlides"
      via: "slide insertion"
      pattern: "setSlides.*splice"
---

<objective>
Implement the paste slide handler and UI integration for keyboard and button-based paste.

Purpose: Enable users to paste PowerPoint content into Cue as new slides via Cmd+V or toolbar button.
Output: Working paste flow with loading state and toolbar button.
</objective>

<execution_context>
@/Users/ricky/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ricky/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/55-paste-infrastructure/55-CONTEXT.md
@.planning/phases/55-paste-infrastructure/55-01-SUMMARY.md

@App.tsx (lines 612-730 for handleInsert* pattern)
@hooks/usePaste.ts
@types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement handlePasteSlide and integrate usePaste</name>
  <files>App.tsx</files>
  <action>
Add the paste slide handler and hook integration to App.tsx. This is a significant addition but follows the established handleInsert* pattern.

**1. Add import at top of App.tsx (with other hook imports):**

```typescript
import { usePaste, PasteResult } from './hooks/usePaste';
```

**2. Add handlePasteSlide handler (after handleInsertClassChallengeSlide, around line 830):**

```typescript
// Paste slide from clipboard (Cmd+V with rich content)
// Per CONTEXT.md: Immediate creation, no confirmation step
const handlePasteSlide = useCallback(async (result: PasteResult) => {
  // Only process if we have content
  if (!result.html && !result.text && !result.imageBlob) {
    return;
  }

  // Create temp slide with loading state
  const tempId = `paste-${Date.now()}`;
  const tempSlide: Slide = {
    id: tempId,
    title: "Pasting...",
    content: ["Processing clipboard content..."],
    speakerNotes: "",
    imagePrompt: "",
    isGeneratingImage: true, // Shows loading indicator
    layout: 'split',
    source: { type: 'pasted', pastedAt: new Date().toISOString() },
  };

  // Insert after currently selected slide, or at end if none selected
  // Per CONTEXT.md: "Insert after currently selected slide, if no slide selected append to end"
  const insertIndex = activeSlideIndex >= 0 ? activeSlideIndex : slides.length - 1;

  const newSlides = [...slides];
  newSlides.splice(insertIndex + 1, 0, tempSlide);
  setSlides(newSlides);
  setActiveSlideIndex(insertIndex + 1);

  // Extract content from paste
  try {
    // For Phase 55, we do raw paste without AI enhancement (that's Phase 56)
    // Parse HTML to extract title and bullets
    const parsedContent = parseClipboardContent(result);

    // Update slide with parsed content
    setSlides(curr => curr.map(s => {
      if (s.id !== tempId) return s;
      return {
        ...s,
        title: parsedContent.title,
        content: parsedContent.bullets,
        speakerNotes: parsedContent.notes || "Pasted from clipboard. Edit speaker notes as needed.",
        imagePrompt: `Educational illustration for: ${parsedContent.title}`,
        isGeneratingImage: false,
      };
    }));

    // Show success toast
    setToast({ message: 'Slide pasted successfully', type: 'success' });
  } catch (err) {
    console.error("Paste error:", err);
    // Fallback to blank slide with raw content
    setSlides(curr => curr.map(s => {
      if (s.id !== tempId) return s;
      return {
        ...s,
        title: "Pasted Slide",
        content: result.text ? [result.text.substring(0, 200)] : ["Paste content could not be processed"],
        speakerNotes: "Pasted from clipboard - please edit as needed.",
        imagePrompt: "Educational illustration",
        isGeneratingImage: false,
      };
    }));
    setToast({ message: 'Pasted with limited formatting', type: 'info' });
  }
}, [activeSlideIndex, slides]);

// Helper to parse clipboard HTML/text into slide structure
function parseClipboardContent(result: PasteResult): { title: string; bullets: string[]; notes?: string } {
  // If we have HTML, try to extract structure
  if (result.html) {
    // Create a temporary DOM element to parse HTML safely
    const parser = new DOMParser();
    const doc = parser.parseFromString(result.html, 'text/html');

    // Security: Don't execute scripts (DOMParser doesn't by default)
    // But we should still sanitize before using

    // Try to find a title (h1, h2, or first strong/b element)
    const titleEl = doc.querySelector('h1, h2, h3, [class*="title"], strong, b');
    let title = titleEl?.textContent?.trim() || '';

    // Get all text content, split into lines
    const bodyText = doc.body?.textContent || result.text || '';
    const lines = bodyText.split(/\n+/).map(l => l.trim()).filter(l => l.length > 0);

    // If no title found, use first line
    if (!title && lines.length > 0) {
      title = lines[0].substring(0, 80);
      lines.shift();
    }

    // Use remaining lines as bullets (max 6)
    const bullets = lines.slice(0, 6).map(line => {
      // Clean up bullet prefixes
      return line.replace(/^[\u2022\u2023\u25E6\u2043\u2219â€¢\-\*]\s*/, '').trim();
    }).filter(b => b.length > 0);

    // Ensure we have at least one bullet
    if (bullets.length === 0) {
      bullets.push("Add your content here...");
    }

    return { title: title || "Pasted Slide", bullets };
  }

  // Plain text fallback
  if (result.text) {
    const lines = result.text.split(/\n+/).map(l => l.trim()).filter(l => l.length > 0);
    const title = lines[0]?.substring(0, 80) || "Pasted Slide";
    const bullets = lines.slice(1, 7).filter(l => l.length > 0);

    if (bullets.length === 0) {
      bullets.push(lines[0] || "Add your content here...");
    }

    return { title, bullets };
  }

  // No content (shouldn't happen)
  return { title: "Pasted Slide", bullets: ["Add your content here..."] };
}
```

**3. Add usePaste hook call (near other hooks, around line 300):**

```typescript
// Paste slide handler - only active in editing mode
usePaste({
  onPaste: handlePasteSlide,
  enabled: appState === AppState.EDITING,
});
```

Note: The handlePasteSlide callback needs to be defined BEFORE the usePaste call due to hoisting. Either:
- Move handlePasteSlide definition above the usePaste call, OR
- Use a ref pattern to avoid this ordering issue

Recommended: Move the handlePasteSlide definition to be near the other handlers (after handleInsertClassChallengeSlide), and use a stable reference:

```typescript
// Near top of App component, after state declarations:
const handlePasteSlideRef = useRef<(result: PasteResult) => void>(() => {});

// After defining handlePasteSlide:
handlePasteSlideRef.current = handlePasteSlide;

// Then in usePaste call:
usePaste({
  onPaste: (result) => handlePasteSlideRef.current(result),
  enabled: appState === AppState.EDITING,
});
```

**4. Ensure parseClipboardContent is defined outside the component or memoized:**

Move `parseClipboardContent` outside the App component (before the function declaration) since it's a pure function with no dependencies on component state.
  </action>
  <verify>
Run `npm run build` - should compile without errors.
Run `npm run dev` and test:
1. In editing mode, copy text from a document
2. Press Cmd+V (not in a text field)
3. Verify a new slide appears with parsed content
  </verify>
  <done>handlePasteSlide creates slides from clipboard content, usePaste hook integrated, loading state shown during paste</done>
</task>

<task type="auto">
  <name>Task 2: Add Paste Slide button to toolbar</name>
  <files>App.tsx</files>
  <action>
Add a "Paste Slide" button to the editor toolbar area. Per CONTEXT.md: "Button lives in the editor toolbar alongside other slide actions."

The toolbar is currently inline in App.tsx. Look for the area where slide action buttons are rendered (near the slide list).

**Option A: Add to InsertPoint dropdown**

Update the InsertPoint component to include a "Paste" option. This keeps paste alongside other slide insertion actions.

```typescript
// Update InsertPoint props
const InsertPoint = ({
  onClickBlank,
  onClickExemplar,
  onClickElaborate,
  onClickWorkTogether,
  onClickClassChallenge,
  onClickPaste,  // NEW
}: {
  // ... existing props ...
  onClickPaste: () => void,
}) => {
```

Add a paste button in the dropdown (after Class Challenge, or as first option):

```typescript
<button
  onClick={(e) => { e.stopPropagation(); onClickPaste(); setIsOpen(false); }}
  className="flex items-center gap-1.5 px-3 py-1.5 bg-emerald-600 hover:bg-emerald-700 text-white rounded-lg transition-colors shadow-sm"
>
  <svg className="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
  </svg>
  <span className="text-[10px] font-bold uppercase tracking-wider whitespace-nowrap">Paste Slide</span>
</button>
```

**Option B: Add standalone button in editor header**

If InsertPoint gets too cluttered, add a separate paste button in the editor header area.

**Go with Option A** - it keeps all slide insertion actions together.

**Update all InsertPoint usages to include onClickPaste:**

Find all places InsertPoint is used (search for `<InsertPoint`) and add:
```typescript
onClickPaste={() => handlePasteFromButton(idx)}
// or for -1 index:
onClickPaste={() => handlePasteFromButton(-1)}
```

**Create handlePasteFromButton:**

This triggers the system paste dialog since we can't read clipboard without user gesture.

```typescript
// Trigger paste via execCommand (for button click)
// Note: Modern browsers require this to be in response to user action
const handlePasteFromButton = useCallback(async (index: number) => {
  try {
    // Try modern Clipboard API first (requires permission)
    if (navigator.clipboard && navigator.clipboard.read) {
      const items = await navigator.clipboard.read();
      // Process clipboard items...
      // This may fail due to permissions, fall back to prompt
    }
  } catch {
    // Clipboard API not available or permission denied
    // Show helpful message
    setToast({
      message: 'Press Cmd+V (or Ctrl+V) to paste a slide',
      type: 'info'
    });
  }
}, []);
```

Actually, reading clipboard programmatically is complex due to browser permissions. The button should:
1. Focus a hidden element
2. Prompt user to paste
3. Or show a tooltip explaining Cmd+V

**Simplified approach:** The button shows a tooltip/toast explaining to use Cmd+V.

```typescript
const handlePasteFromButton = useCallback(() => {
  // Clipboard read API requires secure context and permission
  // Instead of complex permission flow, guide user to keyboard shortcut
  setToast({
    message: 'Use Cmd+V (Mac) or Ctrl+V (Windows) to paste slide content',
    type: 'info'
  });
}, []);
```

This is acceptable for v1 - the button provides discoverability, keyboard does the work.
  </action>
  <verify>
Run `npm run build` - should compile without errors.
Run `npm run dev` and test:
1. Click the + button between slides
2. Verify "Paste Slide" option appears in dropdown
3. Click it and verify toast appears with Cmd+V instruction
  </verify>
  <done>Paste Slide button visible in InsertPoint dropdown, clicking shows keyboard shortcut hint</done>
</task>

</tasks>

<verification>
1. `npm run build` completes without TypeScript errors
2. `grep "handlePasteSlide" App.tsx` shows handler defined
3. `grep "usePaste" App.tsx` shows hook imported and called
4. `grep "Paste Slide" App.tsx` shows button text in InsertPoint
5. Manual test: Copy text, press Cmd+V in editing mode, new slide appears
6. Manual test: Click +, see Paste Slide option, click shows toast
</verification>

<success_criteria>
- Cmd+V pastes slide content when in editing mode (not in text field)
- Pasted slide appears after currently selected slide
- Loading indicator shows briefly during paste processing
- Paste Slide button appears in InsertPoint dropdown menu
- Button click shows toast with keyboard shortcut guidance
- Build passes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/55-paste-infrastructure/55-02-SUMMARY.md`
</output>
