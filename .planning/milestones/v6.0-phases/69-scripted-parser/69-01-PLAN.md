---
phase: 69-scripted-parser
plan: 01
type: tdd
wave: 1
depends_on: []
files_modified:
  - services/scriptedParser/types.ts
  - services/scriptedParser/scriptedParser.ts
  - services/scriptedParser/scriptedParser.test.ts
autonomous: true
requirements: [PARSE-01, PARSE-02, PARSE-03, PARSE-04, PARSE-05, PARSE-06, PARSE-07, PARSE-08]

must_haves:
  truths:
    - "Say: markers at line start are detected and extract verbatim multi-line teacher script"
    - "Ask: markers extract questions with multi-line continuation"
    - "Write on board: markers (multi-word, case-insensitive) extract student-facing content"
    - "Activity: markers extract activity instructions"
    - "Section headings (## Hook, ### I Do, ### We Do, ### You Do, ### Plenary) create slide boundary blocks"
    - "Unmarked prose >= 20 chars between markers becomes implicit Say: blocks"
    - "## Day N boundaries split lesson plans into separate day sections with accurate block counts"
    - "Parser returns ScriptedParseResult with days, blocks, stats, and warnings"
    - "Multi-line Say: blocks capture all paragraphs until the next marker -- not truncated at first line"
    - "Consecutive same-type markers stay as separate blocks"
    - "Blank lines are preserved within blocks but ignored between blocks"
    - "Case-insensitive matching: say:, SAY:, Say: all produce type 'say'"
  artifacts:
    - path: "services/scriptedParser/types.ts"
      provides: "ScriptedBlock, DaySection, ScriptedParseResult, ParseStats, SectionLabel types"
      exports: ["ScriptedBlockType", "SectionLabel", "ScriptedBlock", "DaySection", "ScriptedParseResult", "ParseStats", "BLOCK_TYPE_LABELS"]
    - path: "services/scriptedParser/scriptedParser.ts"
      provides: "Pure-function parser for marker-annotated lesson plans"
      exports: ["parseScriptedLessonPlan"]
      min_lines: 120
    - path: "services/scriptedParser/scriptedParser.test.ts"
      provides: "Comprehensive unit tests covering all 8 PARSE requirements"
      min_lines: 150
  key_links:
    - from: "services/scriptedParser/scriptedParser.ts"
      to: "services/scriptedParser/types.ts"
      via: "import types for parser input/output"
      pattern: "import.*ScriptedParseResult.*from.*types"
    - from: "services/scriptedParser/scriptedParser.test.ts"
      to: "services/scriptedParser/scriptedParser.ts"
      via: "import parseScriptedLessonPlan for testing"
      pattern: "import.*parseScriptedLessonPlan.*from.*scriptedParser"
---

<objective>
Create the typed data structures and TDD-build the pure-function scripted parser that extracts typed blocks (Say, Ask, Write on board, Activity) from marker-annotated lesson plans.

Purpose: This is the foundation parser for v6.0 Scripted Import. It takes raw lesson plan text with markers and produces structured data that downstream phases (Slide Mapper, Pipeline) consume. No AI, no side effects -- pure function, input text in, structured data out.
Output: types.ts with all type definitions, scriptedParser.ts with parseScriptedLessonPlan(), and comprehensive test suite validating all 8 PARSE requirements.
</objective>

<execution_context>
@/Users/ricky/.claude/get-shit-done/workflows/execute-plan.md
@/Users/ricky/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/69-scripted-parser/69-RESEARCH.md
@.planning/phases/69-scripted-parser/69-CONTEXT.md
@services/phaseDetection/phasePatterns.ts
@services/phaseDetection/phaseDetector.ts
@services/phaseDetection/phaseDetector.test.ts
@jest.config.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ScriptedParser type definitions and constants</name>
  <files>services/scriptedParser/types.ts</files>
  <action>
Create `services/scriptedParser/types.ts` with all type definitions for the scripted parser module.

**Types to define:**

1. `ScriptedBlockType` -- string literal union: `'say' | 'ask' | 'write-on-board' | 'activity' | 'section-heading'`

2. `SectionLabel` -- string literal union: `'Hook' | 'I Do' | 'We Do' | 'You Do' | 'Plenary'`

3. `ScriptedBlock` interface:
   - `type: ScriptedBlockType` -- the block type
   - `content: string` -- text content after the marker (trimmed, multi-line preserved with \n)
   - `lineNumber: number` -- 1-indexed line where block starts
   - `section: SectionLabel | null` -- nearest preceding section heading label, null if none
   - `implicit: boolean` -- true if unmarked prose treated as implicit Say:

4. `DaySection` interface:
   - `dayNumber: number` -- 1-indexed
   - `title: string | null` -- optional title from "## Day 1: Title"
   - `blocks: ScriptedBlock[]` -- all blocks in this day

5. `ParseStats` interface:
   - `sayCount: number`
   - `askCount: number`
   - `writeOnBoardCount: number`
   - `activityCount: number`
   - `sectionHeadingCount: number`
   - `implicitSayCount: number` -- subset of sayCount that were implicit
   - `totalLines: number` -- input line count
   - `parsedLines: number` -- lines that produced blocks

6. `ScriptedParseResult` interface:
   - `days: DaySection[]`
   - `totalBlocks: number` -- sum of content blocks across all days (excluding section-heading blocks)
   - `totalDays: number` -- days.length
   - `warnings: string[]` -- e.g., "Day 3 has no content blocks"
   - `stats: ParseStats`

**Constants to export:**

7. `BLOCK_TYPE_LABELS` -- `Record<ScriptedBlockType, string>` mapping type values to Title Case display labels: `{ 'say': 'Say', 'ask': 'Ask', 'write-on-board': 'Write On Board', 'activity': 'Activity', 'section-heading': 'Section Heading' }`

8. `SUPPORTED_MARKERS` -- readonly string array of the 4 canonical markers: `['Say', 'Ask', 'Write on board', 'Activity'] as const`. This constant will be shared with Phase 73 (Claude Chat Tips) to keep the tips page and parser in sync.

Follow the pattern from `services/phaseDetection/phasePatterns.ts` (exported types and constants, no logic).
  </action>
  <verify>
Run `npx tsc --noEmit services/scriptedParser/types.ts` -- no type errors. Visually confirm all 6 interfaces/types and 2 constants are exported.
  </verify>
  <done>
types.ts exports ScriptedBlockType, SectionLabel, ScriptedBlock, DaySection, ParseStats, ScriptedParseResult, BLOCK_TYPE_LABELS, and SUPPORTED_MARKERS with correct shapes matching the research document.
  </done>
</task>

<task type="auto">
  <name>Task 2: TDD - Build parseScriptedLessonPlan with RED-GREEN cycle</name>
  <files>services/scriptedParser/scriptedParser.test.ts, services/scriptedParser/scriptedParser.ts</files>
  <action>
**RED phase -- Write failing tests first in `services/scriptedParser/scriptedParser.test.ts`:**

Use `import { describe, it, expect } from '@jest/globals';` (ES module pattern from phaseDetector.test.ts).
Import `parseScriptedLessonPlan` from `./scriptedParser`.
Import types from `./types` as needed.

Write test groups organized by requirement ID:

**PARSE-01: Say marker detection**
- Detects `Say:` at line start, extracts content after colon (trimmed)
- Captures multi-line Say: block (3+ paragraphs) until next marker -- content includes all lines joined by `\n`
- Case-insensitive: `say:`, `SAY:`, `Say:` all produce type `'say'`
- Flexible whitespace: `Say:text`, `Say: text`, `Say:  text` all extract trimmed content

**PARSE-02: Ask marker detection**
- Detects `Ask:` and extracts question text
- Multi-line continuation captures expected answers on following lines

**PARSE-03: Write on board marker detection**
- Detects `Write on board:` (multi-word, case-insensitive)
- `WRITE ON BOARD: content` works
- `write on board:content` (no space after colon) works

**PARSE-04: Activity marker detection**
- Detects `Activity:` and extracts instructions
- Multi-line continuation for activity descriptions

**PARSE-05: Section heading detection**
- `## Hook` creates a section-heading block with content `'Hook'`
- `### I Do`, `### We Do`, `### You Do`, `### Plenary` detected at `##` or `###` level
- Subsequent blocks get `section` field set to the nearest preceding heading label
- Headings in any order accepted (no enforcement of pedagogical sequence)

**PARSE-06: Implicit Say blocks**
- Unmarked prose >= 20 chars becomes implicit Say: block (`implicit: true`)
- Short text < 20 chars with no current block is skipped
- Unmarked continuation lines extend the current block (not start a new implicit)

**PARSE-07: Multi-day splitting**
- `## Day 1` and `## Day 2` split into separate day sections
- Day with optional title: `## Day 1: Introduction to Fractions` extracts title `'Introduction to Fractions'`
- No day headers = single Day 1 with `title: null`
- Each day has its own block array with accurate counts

**PARSE-08: Parse result structure**
- `totalBlocks` counts content blocks only (excludes section-heading)
- `totalDays` equals `days.length`
- `stats` fields are accurate counts
- Empty days produce warnings: `"Day N has no content blocks"`
- `stats.implicitSayCount` is subset of `stats.sayCount`

**Additional behavior tests:**
- Consecutive same-type markers stay separate (two `Say:` blocks, not merged)
- Blank lines preserved within blocks (paragraph breaks as `\n`)
- Blank lines between blocks are ignored
- `## Day 1` in body text is NOT matched (must be at line start with ## prefix -- but this IS at line start, so test that mid-paragraph "On Day 1" is not matched)
- Formatting-only lines (`---`, `***`, `===`) are not treated as implicit Say blocks
- Parser never throws -- empty input returns valid result with 0 blocks and Day 1 default
- `lineNumber` is 1-indexed and points to the line where the block's marker appeared

Create a stub `services/scriptedParser/scriptedParser.ts` that exports `parseScriptedLessonPlan` returning a minimal valid result (empty days array). This makes tests importable but failing.

Run `npx jest services/scriptedParser/scriptedParser.test.ts` -- tests MUST fail (RED).

**GREEN phase -- Implement the parser in `services/scriptedParser/scriptedParser.ts`:**

Implement `parseScriptedLessonPlan(text: string): ScriptedParseResult` using a line-by-line state machine:

1. **Regex patterns** (at module level, not recreated per call):
   - `MARKER_PATTERNS` array ordered longest-first: `Write on board` before others. Each has `{ type: ScriptedBlockType, regex: RegExp }`. All case-insensitive (`/i`), line-start anchored.
   - `DAY_BOUNDARY`: `/^##\s*Day\s+(\d+)\s*(?::\s*(.+))?$/i`
   - `SECTION_HEADING`: `/^#{2,3}\s*(Hook|I\s+Do|We\s+Do|You\s+Do|Plenary)\s*$/i`
   - `FORMATTING_LINE`: `/^[\s\-*=#]+$/` -- filters pure formatting from implicit Say detection

2. **Parser state** (internal, not exported):
   ```
   currentBlock: { type, content, lineNumber, section, implicit } | null
   currentDay: { dayNumber, title, blocks, section }
   days: DaySection[]
   warnings: string[]
   ```

3. **Line processing priority** (for each line):
   - Priority 1: Day boundary match → flush block, flush day, start new day
   - Priority 2: Section heading match → flush block, update section, add section-heading block
   - Priority 3: Marker match → flush block, start new block with captured content
   - Priority 4: Blank line → if current block exists, append `\n` (paragraph break); otherwise ignore
   - Priority 5: Content line → if current block exists, append `\n` + line; else if line.trim().length >= 20 AND not formatting-only, start implicit Say block; else skip

4. **Flush block**: When flushing current block, `.trimEnd()` content to remove trailing whitespace/newlines, then push to current day's blocks array.

5. **Flush day**: Push current day to days array. Check if day has content blocks (non-section-heading); if none, add warning.

6. **After loop**: Flush remaining block and day.

7. **Build result**: Calculate stats by iterating all blocks across all days. `totalBlocks` = count of non-section-heading blocks. Build ParseStats from type counts. If no day headers were detected, ensure the default Day 1 is named accordingly.

8. **Section label normalization**: Use a lookup map to normalize captured heading text to canonical `SectionLabel` values (e.g., `'i  do'` → `'I Do'`). Match on `.trim().toLowerCase()` with normalized spaces.

**Key implementation details per user decisions:**
- Markers recognized at line start ONLY (prevent false positives in body text)
- Case-insensitive matching via regex `/i` flag
- Flexible whitespace after colon via `\s*` in regex
- Content trimmed of leading whitespace via regex capture group + `.trim()`
- Consecutive same-type markers = separate blocks (each marker starts a new block)
- Parser NEVER throws -- empty/malformed input returns valid empty result
- Never mutate input (follow phaseDetector.ts immutability pattern)

Run `npx jest services/scriptedParser/scriptedParser.test.ts` -- ALL tests MUST pass (GREEN).
  </action>
  <verify>
`npx jest services/scriptedParser/scriptedParser.test.ts` -- all tests pass. Zero failures, zero skipped. RED commit shows failures, GREEN commit shows passes.
  </verify>
  <done>
parseScriptedLessonPlan correctly parses all 4 marker types (Say, Ask, Write on board, Activity), detects 5 section headings as slide boundaries, handles multi-line block accumulation, splits multi-day plans on ## Day N, captures implicit Say blocks from unmarked prose, and returns a complete ScriptedParseResult with accurate stats and warnings. All tests pass.
  </done>
</task>

</tasks>

<verification>
1. `npx jest services/scriptedParser/scriptedParser.test.ts` -- all tests pass
2. `npx tsc --noEmit services/scriptedParser/types.ts services/scriptedParser/scriptedParser.ts` -- no type errors
3. Types file exports all 6 interfaces/types + 2 constants
4. Parser handles a multi-day lesson plan with all 4 marker types, section headings, and implicit Say blocks correctly
5. Parser never throws on empty or malformed input
</verification>

<success_criteria>
- All 8 PARSE requirements validated by passing tests
- parseScriptedLessonPlan is a pure function with no side effects
- Multi-line blocks capture full content, not just the first line
- Multi-day splitting produces accurate block counts per day
- Implicit Say blocks capture unmarked prose >= 20 chars
- Section headings detected as slide boundary markers with correct labels
- Stats and warnings are accurate
- SUPPORTED_MARKERS constant exported for Phase 73 consumption
</success_criteria>

<output>
After completion, create `.planning/phases/69-scripted-parser/69-01-SUMMARY.md`
</output>
