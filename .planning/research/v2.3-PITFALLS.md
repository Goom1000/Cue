# Domain Pitfalls: Bug Fix Milestone v2.3

**Focus:** Fixing 4 production bugs without regression
**Researched:** 2026-01-20

This document covers common mistakes when fixing BroadcastChannel sync, CSS scaling, API error handling, and flexbox layout bugs. Each pitfall includes prevention strategies and testing approaches.

---

## Bug 1: Game Activity Not Showing in Student View (BroadcastChannel Sync)

### Critical Pitfalls

#### Pitfall 1.1: Missing Message Types in Receiver

**What goes wrong:** Adding new message types to the sender (PresentationView) without adding corresponding handlers in the receiver (StudentView).

**Why it happens:** The `useBroadcastSync` hook is generic - it passes all messages through. Developers add `postMessage({ type: 'GAME_STATE', ... })` in one component but forget to add `if (lastMessage.type === 'GAME_STATE')` in the other.

**Consequences:** Feature appears to work in teacher view but student view silently ignores the message. No errors thrown because BroadcastChannel doesn't validate message types.

**Prevention:**
- When adding a new message type, grep for `lastMessage.type ===` to find ALL handlers
- Consider a central `PresentationMessage` type union in `types.ts` that enforces known message types
- Add explicit "unknown message type" logging in development

**Detection:** Test with both windows open simultaneously. If teacher sees something student doesn't, suspect missing message handler.

#### Pitfall 1.2: State Payload Incomplete

**What goes wrong:** Broadcasting partial state that doesn't include all fields the receiver needs.

**Current code broadcasts:**
```typescript
payload: { currentIndex, visibleBullets, slides }
```

**If game state requires additional fields (e.g., `isGameActive`, `gameQuestions`, `currentQuestionIndex`), the receiver will have stale/missing data.**

**Prevention:**
- Define a complete `PresentationState` type that includes ALL shared state
- Derive what to display from this single source of truth
- Never add UI state to sender without adding to broadcast payload

**Testing approach:**
1. Open teacher + student windows
2. Trigger game mode in teacher
3. Verify student shows game UI (not slide content)
4. Navigate through game states - verify sync at each step

#### Pitfall 1.3: Component Conditional Rendering Excludes New Features

**What goes wrong:** The StudentView component only renders `SlideContentRenderer`. If game mode requires a different component (e.g., `QuizOverlay`), the student view won't show it because the component isn't included.

**Current StudentView.tsx (line 62-67):**
```tsx
return (
  <div className="h-screen w-screen bg-black flex items-center justify-center overflow-hidden">
    <div className="w-full h-full max-w-[1920px] max-h-[1080px] aspect-video bg-white">
      <SlideContentRenderer slide={currentSlide} visibleBullets={visibleBullets} />
    </div>
  </div>
);
```

**No conditional for game mode - this MUST be added.**

**Prevention:**
- When adding modal/overlay features to teacher view, check if they should appear in student view
- Student view should mirror teacher's "projected" state, not just slides

#### Pitfall 1.4: Race Condition on Initial Connection

**What goes wrong:** Game starts in teacher view BEFORE student view connects. Student connects, sends `STATE_REQUEST`, teacher sends current slide state (not game state).

**Why it happens:** The current `STATE_REQUEST` handler only sends slide state:
```typescript
if (lastMessage?.type === 'STATE_REQUEST') {
  postMessage({
    type: 'STATE_UPDATE',
    payload: { currentIndex, visibleBullets, slides }
  });
}
```

**Prevention:**
- Include ALL relevant state in `STATE_UPDATE` response
- Game state must be part of the payload when active
- Consider adding game-specific message type: `GAME_STATE_UPDATE`

### Moderate Pitfalls

#### Pitfall 1.5: Channel Name Mismatch

**What goes wrong:** Using different channel names in different components.

**Current code uses `BROADCAST_CHANNEL_NAME` constant from `types.ts` - this is correct.**

**Detection:** If sync worked before and stopped, check that all usages import the constant rather than hardcoding strings.

#### Pitfall 1.6: Message Echo Loop

**What goes wrong:** Component reacts to its own messages, causing infinite loops.

**Why it happens:** BroadcastChannel doesn't echo to sender by default, but if you store `lastMessage` and use it to trigger side effects that send more messages, you can create loops.

**Prevention:**
- Avoid sending messages in response to receiving messages (except for specific ack patterns)
- If needed, add a `source` field to messages and filter out your own

### Testing Checklist for Bug 1

- [ ] Open teacher view, launch student view
- [ ] Start game in teacher view
- [ ] Student view shows game UI (not slides)
- [ ] Navigate through game questions - both views in sync
- [ ] Close game - student view returns to slides
- [ ] Reconnect student mid-game - should show current game state
- [ ] Multiple tabs: open 2 student views - both should sync

---

## Bug 2: Slide Preview Cutoff in Teacher View (CSS Scaling)

### Critical Pitfalls

#### Pitfall 2.1: Using `aspect-ratio` Without Constraining Both Dimensions

**What goes wrong:** Setting `aspect-ratio: 16/9` on a container but not constraining height, causing content to overflow.

**Current PresentationView.tsx (line 621):**
```tsx
<div className="w-full h-full max-w-[1600px] aspect-video bg-white rounded-lg overflow-hidden shadow-2xl relative">
  <SlideContentRenderer slide={currentSlide} visibleBullets={visibleBullets} />
</div>
```

**The issue:** `aspect-video` (16:9) combined with `w-full h-full` creates conflict. If parent is not 16:9, child overflows.

**Prevention:**
- Use `max-w-full` AND `max-h-full` together
- Calculate scale factor based on container dimensions
- Use `object-fit: contain` pattern for child content

**Correct approach for scaled preview:**
```tsx
// Container with known dimensions
<div className="w-full h-full flex items-center justify-center p-4">
  {/* Scaled slide that fits within container */}
  <div
    className="bg-white shadow-2xl origin-center"
    style={{
      width: '1920px',
      height: '1080px',
      transform: `scale(${scaleFactor})`,
    }}
  >
    <SlideContentRenderer ... />
  </div>
</div>
```

#### Pitfall 2.2: Transform Scale Without Explicit Dimensions

**What goes wrong:** Using `transform: scale(0.5)` on an element that doesn't have explicit width/height. The element scales based on content size, which varies.

**Prevention:**
- Always set explicit dimensions on the element being scaled
- Use a reference dimension (e.g., 1920x1080 for slides)
- Calculate scale factor: `Math.min(containerWidth/1920, containerHeight/1080)`

#### Pitfall 2.3: Overflow Hidden Breaking Child Positioning

**What goes wrong:** Adding `overflow-hidden` clips transformed content incorrectly in some browsers.

**Why it happens:** CSS transforms create a new stacking context. Safari has known bugs with `overflow: hidden` + `transform` + `border-radius`.

**Workaround:**
- Apply `overflow-hidden` to the container, not the scaled element
- Or use a wrapper div approach:
```tsx
<div className="overflow-hidden"> {/* Clips here */}
  <div style={{ transform: `scale(${scale})` }}> {/* Scaled content */}
    ...
  </div>
</div>
```

#### Pitfall 2.4: Not Accounting for Container Padding

**What goes wrong:** Calculating scale based on container dimensions but forgetting padding reduces available space.

**Example:**
```tsx
// Container is 800x600 with p-4 (16px padding)
// Actual available space: 768x568
// Scale calculation must use 768x568, not 800x600
```

**Prevention:**
- Use `ref` and `getBoundingClientRect()` on the inner content area
- Or calculate: `(containerWidth - paddingLeft - paddingRight)`

### Moderate Pitfalls

#### Pitfall 2.5: Scale Applied But Transform Origin Wrong

**What goes wrong:** Element scales from top-left corner by default (`transform-origin: 0 0`), causing it to appear offset.

**Prevention:**
- Add `transform-origin: center` or use Tailwind's `origin-center`
- Ensure parent container uses `flex items-center justify-center` to center the scaled element

#### Pitfall 2.6: Responsive Breakpoints Breaking Layout

**What goes wrong:** Scale calculation works at one breakpoint but breaks at another because different CSS applies.

**Prevention:**
- Calculate scale dynamically using a resize observer
- Test at multiple viewport sizes: mobile, tablet, desktop
- Use CSS custom properties for scale factor if static breakpoints needed

### Testing Checklist for Bug 2

- [ ] Slide preview shows complete content (no cutoff)
- [ ] Text at bottom of slide is visible
- [ ] Images are not cropped unexpectedly
- [ ] Preview maintains 16:9 aspect ratio
- [ ] Works in both layout modes (row and column)
- [ ] Resize browser window - preview adjusts without cutoff
- [ ] Test with slides that have lots of content (5+ bullet points)
- [ ] Test with different slide layouts (default, flowchart, grid)

---

## Bug 3: AI Slide Revision Error (API Error Handling)

### Critical Pitfalls

#### Pitfall 3.1: Not Catching All Error Types

**What goes wrong:** Using `try/catch` but only handling specific error types, letting others propagate as uncaught.

**Current pattern in codebase:**
```typescript
try {
  const result = await provider.reviseSlide(slide, instruction);
} catch (e) {
  if (e instanceof AIProviderError) {
    onError('Revision Failed', e.userMessage);
  } else {
    onError('Error', 'Could not revise slide. Please try again.');
  }
}
```

**This is correct! But ensure the provider's `reviseSlide` method wraps ALL errors in `AIProviderError`.**

**Prevention:**
- In provider implementations, wrap ALL caught errors:
```typescript
} catch (error) {
  if (error instanceof AIProviderError) throw error;
  throw new AIProviderError(
    USER_ERROR_MESSAGES.UNKNOWN_ERROR,
    'UNKNOWN_ERROR',
    error
  );
}
```

#### Pitfall 3.2: JSON Parse Errors from Malformed AI Response

**What goes wrong:** AI returns malformed JSON, `JSON.parse()` throws, error isn't caught properly.

**Why it happens:** LLMs sometimes return partial JSON, markdown-wrapped JSON, or explanatory text instead of pure JSON.

**Prevention:**
- Wrap JSON.parse in try/catch
- Use a sanitization step to extract JSON from markdown code blocks
- Validate parsed object has expected shape before using

**Example pattern:**
```typescript
function parseAIResponse(text: string): Partial<Slide> {
  // Remove markdown code blocks if present
  let cleaned = text.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();

  try {
    const parsed = JSON.parse(cleaned);
    // Validate shape
    if (typeof parsed.title !== 'string' && parsed.title !== undefined) {
      throw new Error('Invalid title type');
    }
    return parsed;
  } catch (e) {
    throw new AIProviderError(
      USER_ERROR_MESSAGES.PARSE_ERROR,
      'PARSE_ERROR',
      e
    );
  }
}
```

#### Pitfall 3.3: Network Timeout Not Handled

**What goes wrong:** API call hangs indefinitely when network is slow, user sees nothing.

**Prevention:**
- Implement AbortController timeout (10-30 seconds)
- Show loading state immediately
- Provide cancel button for long operations

**Example:**
```typescript
const controller = new AbortController();
const timeoutId = setTimeout(() => controller.abort(), 15000);

try {
  const response = await fetch(url, { signal: controller.signal });
} catch (e) {
  if (e.name === 'AbortError') {
    throw new AIProviderError('Request timed out', 'NETWORK_ERROR');
  }
  throw e;
} finally {
  clearTimeout(timeoutId);
}
```

#### Pitfall 3.4: State Update After Unmount

**What goes wrong:** User navigates away while API call is in progress, call completes, setState is called on unmounted component.

**Prevention:**
- Use AbortController to cancel requests on unmount
- Or use a mounted ref:
```typescript
const mountedRef = useRef(true);
useEffect(() => () => { mountedRef.current = false; }, []);

// In async handler:
if (mountedRef.current) {
  setResult(data);
}
```

### Moderate Pitfalls

#### Pitfall 3.5: Error Message Not User-Friendly

**What goes wrong:** Showing technical error messages to users (e.g., "TypeError: Cannot read property 'x' of undefined").

**Prevention:**
- Always map to user-friendly messages via `USER_ERROR_MESSAGES`
- Log technical details to console for debugging
- Never expose raw error.message to UI

#### Pitfall 3.6: Not Preserving Original Slide on Error

**What goes wrong:** Revision fails but original slide state was already mutated optimistically.

**Prevention:**
- Never mutate original slide until API confirms success
- Create a copy for optimistic UI if needed
- On error, simply discard the copy

### Testing Checklist for Bug 3

- [ ] Successful revision updates slide content
- [ ] API error shows user-friendly message (not technical error)
- [ ] Network timeout shows appropriate message
- [ ] Invalid API key shows "Invalid API key" message
- [ ] Rate limit shows "Too many requests" message
- [ ] Loading state visible during request
- [ ] User can retry after error
- [ ] Navigate away during request - no React warnings in console
- [ ] Malformed AI response shows parse error message (not crash)

---

## Bug 4: Flowchart Layout Arrows and Whitespace (Flexbox Layout)

### Critical Pitfalls

#### Pitfall 4.1: Arrow Vertical Centering Wrong Container

**What goes wrong:** Arrows are centered within their own container, but the container isn't aligned with the boxes.

**Current FlowchartLayout code (lines 139-145):**
```tsx
<div className={`... h-full pb-20 ...`}>
  <svg className="w-8 h-8 md:w-16 md:h-16 ..." ...>
```

**The `pb-20` (padding-bottom: 5rem) is a hacky offset. This breaks if box heights vary.**

**Root cause:** The arrow container has `h-full` but uses `items-center`, which centers the SVG in the full height including the artificial padding.

**Prevention:**
- Remove arbitrary padding hacks
- Make arrow container height match box height exactly
- Use `self-center` on the SVG, not the container

**Better approach:**
```tsx
<div className="flex-1 flex items-center gap-4">
  {/* Box */}
  <div className="flex-1 aspect-[4/3] ...">content</div>

  {/* Arrow - same height context as box */}
  <div className="flex items-center justify-center shrink-0">
    <svg ... />
  </div>

  {/* Next Box */}
  <div className="flex-1 aspect-[4/3] ...">content</div>
</div>
```

#### Pitfall 4.2: Fixed Aspect Ratio Preventing Vertical Fill

**What goes wrong:** Boxes have `aspect-[4/3]` which constrains their height based on width, preventing them from filling vertical space.

**Current code (line 150):**
```tsx
<div className={`aspect-[4/3] rounded-3xl ... h-full w-full ...`}>
```

**`aspect-[4/3]` and `h-full` conflict. Aspect ratio wins, leaving whitespace below.**

**Prevention:**
- Choose ONE: either fixed aspect ratio OR fill available space
- If aspect ratio is required, center boxes vertically in the remaining space
- If vertical fill is required, remove aspect ratio constraint

**Option A - Keep aspect ratio, center vertically:**
```tsx
<div className="flex-1 flex items-center justify-center">
  <div className="flex gap-4 items-center">
    {/* Boxes will be centered vertically */}
  </div>
</div>
```

**Option B - Fill vertical space, no fixed aspect ratio:**
```tsx
<div className="flex-1 flex items-stretch gap-4">
  <div className="flex-1 rounded-3xl p-8 flex items-center justify-center">
    {/* Will stretch to fill height */}
  </div>
</div>
```

#### Pitfall 4.3: items-start Causing Top Alignment

**What goes wrong:** Current code uses `items-start` which aligns boxes to the top.

**Current code (line 135):**
```tsx
<div className="flex w-full px-4 gap-4 md:gap-6 flex-1 items-start justify-center">
```

**`items-start` = align items to start of cross-axis (top). Change to `items-center` for vertical centering.**

**Prevention:**
- Use `items-center` for vertical centering in a row layout
- Use `justify-center` for horizontal centering

### Moderate Pitfalls

#### Pitfall 4.4: SVG Viewbox Not Matching Arrow Direction

**What goes wrong:** Arrow points wrong direction or appears clipped because viewBox doesn't match path.

**Current arrow path:**
```tsx
<path ... d="M17 8l4 4m0 0l-4 4m4-4H3" />
```

**This is a right-pointing arrow. Ensure viewBox is `0 0 24 24` and stroke alignment is correct.**

**Prevention:**
- Test arrow appearance at different sizes
- Ensure `strokeWidth` doesn't cause clipping at viewBox edges
- Add small padding in viewBox if needed: `viewBox="-1 -1 26 26"`

#### Pitfall 4.5: Gap Values Inconsistent at Breakpoints

**What goes wrong:** `gap-4 md:gap-6` creates layout shift at breakpoint that looks jarring.

**Prevention:**
- Test at exact breakpoint width (768px for `md:`)
- Consider using fluid gap: `gap-[2vw]` or similar
- Ensure gap changes don't break arrow alignment

#### Pitfall 4.6: flex-1 on Boxes Causing Unequal Widths

**What goes wrong:** `flex-1` distributes space equally, but if content varies significantly, boxes can appear different widths when text wraps differently.

**Prevention:**
- Use `flex-1` combined with `min-w-0` to allow shrinking
- Set explicit `max-w` if boxes should never exceed certain width
- Test with varying content lengths

### Testing Checklist for Bug 4

- [ ] Arrows are vertically centered with boxes
- [ ] Arrow points from center-right of one box to center-left of next
- [ ] Boxes fill vertical space appropriately (no large gap below)
- [ ] Boxes remain readable (not stretched too thin)
- [ ] Works with 2, 3, and 4 boxes in flowchart
- [ ] Responsive: tablet and desktop layouts look correct
- [ ] Animation: arrows appear/disappear smoothly with bullet reveal
- [ ] Different content lengths don't break alignment

---

## Cross-Cutting Concerns

### Regression Prevention

#### Test All Affected Views

For any bug fix:
1. **Teacher View (PresentationView)** - Primary editing/control interface
2. **Student View (StudentView)** - Projected display
3. **Edit View (App.tsx slide editor)** - Where slides are created

A fix to flowchart layout affects ALL THREE because `SlideContentRenderer` is shared.

#### Browser Testing Matrix

| Browser | BroadcastChannel | CSS Transform | CSS Flexbox |
|---------|------------------|---------------|-------------|
| Chrome | Yes | Yes | Yes |
| Firefox | Yes | Yes | Yes |
| Safari | Yes | Has bugs with transform+overflow | Yes |
| Edge | Yes | Yes | Yes |

**Safari-specific concerns:**
- `overflow: hidden` + `transform` may clip incorrectly
- Test slide preview scaling in Safari specifically

#### State Sync Verification

After any change to state broadcasting:
1. Start presentation in teacher view
2. Open student view (via "Launch Student View" button)
3. Verify initial sync (slide content matches)
4. Navigate slides - verify continuous sync
5. Trigger game mode - verify game shows in student view
6. Close student view, reopen - verify reconnection sync

### Performance Considerations

#### Don't Over-Broadcast

Current code broadcasts on every state change:
```typescript
useEffect(() => {
  postMessage({ type: 'STATE_UPDATE', payload: { ... } });
}, [currentIndex, visibleBullets, slides, postMessage]);
```

This is fine for simple state, but if game state adds large payloads (questions, images), consider:
- Broadcasting only changed fields
- Throttling updates for rapidly changing state (e.g., timer countdown)

#### Layout Thrashing

CSS fixes that cause reflows on every frame:
- Avoid calculating layout in render without memoization
- Use `ResizeObserver` instead of recalculating on every render
- Memoize scale calculations

---

## Summary: Fix Strategy by Bug

| Bug | Root Cause Hypothesis | Key Pitfall to Avoid |
|-----|----------------------|---------------------|
| Game not in student view | Missing message type handler + component conditional | Add handler AND component, not just one |
| Slide preview cutoff | aspect-ratio + dimension conflict | Calculate scale, set explicit dimensions |
| AI revision error | Unhandled error type or parse failure | Wrap ALL errors, sanitize AI response |
| Flowchart arrows | items-start + pb-20 hack | Use items-center, remove padding hack |

---

## Sources

### BroadcastChannel
- [MDN BroadcastChannel API](https://developer.mozilla.org/en-US/docs/Web/API/Broadcast_Channel_API)
- [MDN BroadcastChannel](https://developer.mozilla.org/en-US/docs/Web/API/BroadcastChannel)
- [React Multi-Tab Desync - DEV Community](https://dev.to/idanshalem/the-forgotten-problem-why-your-app-breaks-when-you-open-a-second-tab-911)
- [Building React Multi-Tab Sync - DEV Community](https://dev.to/idanshalem/building-react-multi-tab-sync-a-custom-hook-with-the-broadcastchannel-api-c6d)

### CSS Transform/Scale/Overflow
- [CSS-Tricks Overflow](https://css-tricks.com/almanac/properties/o/overflow/)
- [CSS-Tricks Aspect Ratio Boxes](https://css-tricks.com/aspect-ratio-boxes/)
- [MDN aspect-ratio](https://developer.mozilla.org/en-US/docs/Web/CSS/aspect-ratio)
- [Safari border-radius + overflow fix](https://gist.github.com/ayamflow/b602ab436ac9f05660d9c15190f4fd7b)
- [Breaking Out of the Box: Overflow Pitfalls](https://blog.pixelfreestudio.com/breaking-out-of-the-box-dealing-with-overflow-pitfalls-in-css/)

### React Error Handling
- [How to Handle Errors in React - developerway](https://www.developerway.com/posts/how-to-handle-errors-in-react)
- [Guide to Error Handling in React - Sentry](https://blog.sentry.io/guide-to-error-and-exception-handling-in-react/)
- [Best Practices for API Errors and Loading States](https://www.c-sharpcorner.com/article/best-practices-for-handling-api-errors-and-loading-states-in-react/)

### Flexbox Layout
- [CSS Flexbox Guide - CSS-Tricks](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)
- [Flexbugs - Community Curated Issues](https://github.com/philipwalton/flexbugs)
- [Flow Charts with CSS Anchor Positioning](https://coryrylan.com/blog/flow-charts-with-css-anchor-positioning)
- [6 Common SVG Fails - CSS-Tricks](https://css-tricks.com/6-common-svg-fails-and-how-to-fix-them/)
